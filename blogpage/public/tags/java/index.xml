<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on 个人主页</title>
    <link>http://lalalaxiaowifi.gitee.io/pictures/tags/java/</link>
    <description>Recent content in java on 个人主页</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2020-2099</copyright>
    <lastBuildDate>Tue, 01 Dec 2020 00:00:00 +0000</lastBuildDate><atom:link href="http://lalalaxiaowifi.gitee.io/pictures/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>cost账本</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/%E4%B8%AA%E4%BA%BA%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/cost%E8%B4%A6%E6%9C%AC/cost%E8%B4%A6%E6%9C%AC/</link>
      <pubDate>Tue, 01 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/%E4%B8%AA%E4%BA%BA%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/cost%E8%B4%A6%E6%9C%AC/cost%E8%B4%A6%E6%9C%AC/</guid>
      <description>前言 之前因为某些原因吧，打算做一个个人记账和统计的app,毕竟自己是Android搬砖工，这点小Demo还是可以整的。然后自己整了一半，由于一些原因就放弃了(没钱)，每个月入不敷出的，我写记账的欲望都没有。 什么？你说这就应该开始记账，避免花钱大手大脚的？
顺便推一下博客主页</description>
    </item>
    
    <item>
      <title>java部分修饰符</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/java-%E4%BF%AE%E9%A5%B0/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/java-%E4%BF%AE%E9%A5%B0/</guid>
      <description>前言 明明刚刚在写另外一篇博客的，然后准备资料的时候发现了一些懵逼的东西。这个明显触及到了我的知识点盲区。主要是有一种很乱的感觉，没错是我菜，见识短浅啊。
直接上教程runoob Java 教程。本篇主要介绍两个修饰符 final，volatile。当然了runoob java 修饰符 这个教程把修饰符都讲完了。为啥写，主要是缺点笔记。
还有是为了认真工作嘛。
如果领导路过不打招呼又在摸鱼影响不好，反正都是在认真工作的样子。。
那么我们就开始罗列知识点:（具体使用请参考 上面教程）   final 变量：
final 表示&amp;quot;最后的、最终的&amp;quot;含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。
final 修饰符通常和 static 修饰符一起使用来创建类常量。
  final 方法
父类中的 final 方法可以被子类继承，但是不能被子类重写。
声明 final 方法的主要目的是防止该方法的内容被修改。
  final 类
final 类不能被继承，没有类能够继承 final 类的任何特性。
  volatile 修饰符
volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。
  顺便推一下博客目录 。
正文 我去，上面总结完了，现在正文写啥？
先说final 吧，修饰常量，Android 可以定义在xml 中 通过Context的getResources() 获取string或者int 值。常量是存储在内存中的，那么和Android 从xml 中获取到底谁的性能更加优秀？
然后是在单例中使用，Android 中使用单例的机会也不是太多，大多数和生命周期绑定使用，只有哪些初始化成本比较高，使用较为频繁的功能才可能考虑单例。比如数据库的db对象和SharedPreferences.都是创建成本高，而且对象方法加锁执行，可能导致线程阻塞，如果是异步处理volatile 从逻辑上讲更好啊，
final 修饰方法，这个主要是用于功能设计的底层逻辑编写。
final 修饰类，类不能被继承，核心功能类设计吧，通常和包限制共同使用。</description>
    </item>
    
    <item>
      <title>object与map项目转换</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96objec%E5%92%8Cmap%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96objec%E5%92%8Cmap%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/</guid>
      <description>前言 搬砖生活中，有一种转换叫做序列化和反序列化。但是本文和这个没有多少关系，我们知道JAVA 的对象的存储是分键和值的，emmmm？map 好像也是哦，我们可能会遇到一个判断一个对象中是否包含多个值或者一个json 中只需要某个值的情况，那么是否可以针对简单对象提供一个json 转map的能力呢？emmmm？gson 实现了，比如这个样子：
1new Gson().fromJson(&amp;#34;&amp;#34;,new TypeToken&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt;(){}.getType()) 但是，这个和本文还是没有关系。我只是顺便引导一下。需要对象转map 的情况通常在与服务器互动过程中。我们定义了一个专门用于传递参数的对象，如果服务器不要求传递json,那么就需要转map了，或者手动赋值。手动？那是不可能的。JAVA 中一个骚操作，叫反射，但是它有一个问题，那就是无法反射到父类的参数。比如有一个每个接口都需要传递的参数，要么每次添加，要么创建对象时候生成。但是这都不是问题。
获取所以内容 1//这个方法可以解决获取不到父类的情况 2private static Field[] getAllFieldsByObject(Object object){ 3 Class clazz = object.getClass(); 4 List&amp;lt;Field&amp;gt; fieldList = new ArrayList&amp;lt;&amp;gt;(); 5 while (clazz != null){ 6 fieldList.addAll(new ArrayList&amp;lt;&amp;gt;(Arrays.asList(clazz.getDeclaredFields()))); 7 clazz = clazz.getSuperclass(); 8 } 9 Field[] fields = new Field[fieldList.size()]; 10 fieldList.toArray(fields); 11 return fields; 12} 13 14	/** 15 * 获取对象中所有可用字段。 16 * @param clazz 17 * @return 18 */ 19 private static Field[] getAllFieldsByClass(Class clazz){ 20 List&amp;lt;Field&amp;gt; fieldList = new ArrayList&amp;lt;&amp;gt;(); 21 while (clazz !</description>
    </item>
    
  </channel>
</rss>
