<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>viewpager on 个人主页</title>
    <link>http://lalalaxiaowifi.gitee.io/pictures/series/viewpager/</link>
    <description>Recent content in viewpager on 个人主页</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2020-2099</copyright><atom:link href="http://lalalaxiaowifi.gitee.io/pictures/series/viewpager/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>重学Viewpager</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/%E9%87%8D%E5%AD%A6viewpager/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/%E9%87%8D%E5%AD%A6viewpager/</guid>
      <description>》 顺便推一下博客主页
前言  viewpager 通常用于加载Fragment或者banner图，因为其良好的交互效果，被设计大佬广泛使用。默认情景下，viewpager 会加载缓存左右的view。滑出去之后就会删除对应的item。 这么就导致了fragment中layout的重复创建和重复赋值，不停的网络请求，所以才有了懒加载等等相关逻辑，但是viewpager某种意义上就是懒加载逻辑呀。 往往为了解决重复请求，重复加载等等问题，我们通常是设置缓存个数和重写item的删除逻辑，为了更加通透的理解viewpager，所以重学是必要的。
 正文 viewPager 结束 </description>
    </item>
    
  </channel>
</rss>
