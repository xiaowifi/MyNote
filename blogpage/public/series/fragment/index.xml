<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>fragment on 个人主页</title>
    <link>http://lalalaxiaowifi.gitee.io/pictures/series/fragment/</link>
    <description>Recent content in fragment on 个人主页</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2020-2099</copyright>
    <lastBuildDate>Mon, 28 Dec 2020 00:00:00 +0000</lastBuildDate><atom:link href="http://lalalaxiaowifi.gitee.io/pictures/series/fragment/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>fragment生命周期导致数据初始化问题</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/fragment%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
      <pubDate>Mon, 28 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/fragment%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
      <description>前言 话说，activity 和fragment 都是有生命周期的，而且加载也并不是new完对象就加载出来了的，new 一个activity并不多见，但是基于activity new 一个fragment还是很常见的，但是很少有需要在activity中调用fragment方法的时候，但是存在可能性。 因为fragment加载的特性，所以像loading层保证唯一，这样子的就不能直接判断fragmentmanger 中是否包含了，需要一个其他值去判断。而且传参方面，也是这个样子。 比如说我的createPresenter() 方法是当fragment 走oncreate() 的时候创建调用的，但是我上一行代码创建完fragment就直接调用presenter 就会抛空指针异常。
解决思路 思路1 绑定生命周期 我们知道 fragment.getLifecycle().addObserver(observer) 这个可以添加生命周期监听，那么我们对fragment 添加了监听，等走到对应的生命周期的方法才执行对应的代码就好。这样也就避免了，activity 不知道fragment什么时候加载完成导致调用问题了。 但是这种情况下，如果我fragment中再嵌套一个fragment呢？内部的fragment 生命周期万一也关联到外部的activity调用呢？用多个observer去调出来，就是有点怪怪的。那么只能从代码设计上更改了。
思路2 更改设计模式 修改绑定生命周期部分 这个思路肯定是不行的，绑定生命周期就是为了优化内存使用的，而且绑定生命周期也对view的加载显示控制提供了生命范围，防止错误的时间，错误的地点导致操作崩溃。
那就修改功能对应的界面的设计  先说功能吧，对某个数据表进行 折线图，饼图，柱状图等图表的显示，这些图表支持 日周月年的时间切换。先进入某个功能点，确定数据来源，然后选择图表类型，进入下一个界面，最后是选择时间切换。默认加载天的数据。 我就一想，既然每个图表需求显示的view是固定的，那么activity只需要加载一个fragment，由fragment 内部加载不同的图表fragment，图表fragment 只需要显示fragment传入的数据就行。fragment进行数据获取和数据转换，activity进行时间更改转化，然后传入进去。 那么问题就来了，因为activity控制时间，所以第一次的时间需要由activity传入到fragment中，然而，activity并不知道fragment是否加载完成，所以activity需要知道fragment的生命周期，fragment拿到数据知道，也不知道图表fragment是否加载完成，所以也需要拿到生命周期，如果不做延时处理，那么activity就需要拿到两层fragment的生命周期，再传入值。 但是做线程延时，判断生命周期调用，也需要先将 我传入的值存储到两个fragment里面，等到需要的生命周期再显示，这个和我直接通过对象方法传参没有任何区别吧。所以还是生命周期传参导致的问题。 那么就优化设计逻辑，activity 只持有一层图表fragment，图表fragment进行数据拉取和处理显示就好，只是图表层的presenter 需要将所有的功能点的数据全部拉取一遍罢了。当然进行时间切换的时候，也需要判断当前fragment是否加载出来。
 总结 感觉，mvp和mvvm 其实也是一种代码规范，感觉通过activity 向fragment对象方法传参就有点违背了这种规范的初衷吧。所以像eventbus 这种传参，就很实用,完全不需要考虑生命周期，当然Android 提供的广播也是可以的。 EventBus GitHub
activity中注册后，在fragment中就不用再注册监听了，提供方法就直接会调用。因为fragment属于延时加载，所以尽量使用postSticky 。接收：
1 @Subscribe(threadMode = ThreadMode.MAIN, sticky = true) 2 public void onChangeData(ChartDetailsMessage message){ 3 getPresenter().getDatas(message); 4 } </description>
    </item>
    
    <item>
      <title>摸鱼Android Fragmentmanger</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android-fragmentmanger/</link>
      <pubDate>Tue, 20 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android-fragmentmanger/</guid>
      <description>前言 话说，搬砖多年，我们的好朋友fragment已经需要适配到AndroidX了，毕竟我之前老是喜欢用V4包下的fragment。但是这个笔记却不是关于更新到Android X的,毕竟如果要整Android X，要改的地方应该有点多，还不知道 Android X和support 包可以共存吗？感觉没法共存，毕竟从activity 到view好像都变了，毕竟第3方包如果没有适配Android X就没法改。自己整是不可能自己整的，毕竟老板没有要求，那我们就永远不适配AndroidX的代码。感觉有点和Android 最新时代已经脱轨了。
好了，回归正文，我们主要是整fragmentmanager。
顺便推一下博客主页
正文 显示fragment吧，这个老朋友了，不需要介绍，app 下的fragment和v4下的fragment调用对应的fragmentmanager就好了。而显示fragment 一般有几种:
 通过ViewPager 加载 通过FrameLayout 通过dialogFragment 显示  这个地方主要整:基于FrameLayout 显示fragment。
显示fragment 代码大概是需要显示成这个样子。
1public Fragment showFragment(String className, FragmentManager fragmentManager, int id) { 2 Fragment fragment = null; 3 try { 4 5 FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); 6 //隐藏所有的那个啥。 7 for (Fragment fra : fragmentManager.getFragments()) { 8 fragmentTransaction.hide(fra); 9 } 10 Fragment fragmentByTag = fragmentManager.findFragmentByTag(className); 11 if (fragmentByTag !</description>
    </item>
    
    <item>
      <title>摸鱼DialogFragment</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/%E6%91%B8%E9%B1%BCdialogfragment/</link>
      <pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/%E6%91%B8%E9%B1%BCdialogfragment/</guid>
      <description>前言 话说dialogfragment。这个调调，我用的还是蛮多的。像popwindow,loading，或者一些dialog如果能够用dialogfragment 实现，我一般会选择用这个调调。毕竟有生命周期，感觉和写fragment没有区别。这就导致我基于dialog 实现自定义dialog的能力比较差，主要还是主题设置，设置好了还是感觉差不多的。当然了popwindow的优点还是dialog 或者dialogfragment 无法比拟的。还有一个原因，我比较喜欢将一些值存储到activity的intent中(这么写，还是要提供完整的注释的，要不然不习惯这种写法的会看得很难受)，感觉dialog 中获取activity 没有fragment中那么方便。但是我看好多UI库都是自己写了一个dialog(比如说QMUI) ?搞得我有点懵逼。但是我看别人的代码，很少用dialogfragment 为啥我看到的代码里面，大家都用dialog 而不是dialogfragment ?这个以后探讨吧。
顺便推一下博客主页
正文 话说这个调调DialogFragment和其他控件差不多，也是从28以后移出出去了。看来把代码适配更新到Android X是需要提上日程了。关于基础用法这个网络上很多大佬写过博客的，我觉得没有重复的必要的，和fragment 差不多，还是重要的一点，配置style会影响dialogfragment的显示效果的，状态栏也可以按照需求配置的。
主题 我所使用的主题。通常是全屏的。这个需要通过自己的需求配置
1&amp;lt;style name=&amp;#34;Dialog.FullScreen&amp;#34; parent=&amp;#34;AppTheme&amp;#34;&amp;gt; 2 &amp;lt;item name=&amp;#34;android:windowNoTitle&amp;#34;&amp;gt;true&amp;lt;/item&amp;gt; 3 &amp;lt;item name=&amp;#34;android:windowBackground&amp;#34;&amp;gt;@color/transparent&amp;lt;/item&amp;gt; 4 &amp;lt;item name=&amp;#34;android:windowIsFloating&amp;#34;&amp;gt;false&amp;lt;/item&amp;gt; 5 &amp;lt;item name=&amp;#34;android:textColor&amp;#34;&amp;gt;@color/color_333333&amp;lt;/item&amp;gt; 6 &amp;lt;item name=&amp;#34;android:textSize&amp;#34;&amp;gt;14sp&amp;lt;/item&amp;gt; 7 &amp;lt;item name=&amp;#34;android:backgroundDimEnabled&amp;#34;&amp;gt;true&amp;lt;/item&amp;gt; 8&amp;lt;/style&amp;gt; 9 10&amp;lt;style name=&amp;#34;DialogNoDim&amp;#34; parent=&amp;#34;Dialog.FullScreen&amp;#34;&amp;gt; 11 &amp;lt;item name=&amp;#34;android:backgroundDimEnabled&amp;#34;&amp;gt;false&amp;lt;/item&amp;gt; 12 &amp;lt;/style&amp;gt; 使用:
1@Override 2public void onCreate(@Nullable Bundle savedInstanceState) { 3 super.onCreate(savedInstanceState); 4 setStyle(STYLE_NORMAL, R.style.Dialog_FullScreen); 5} 其他设置：
1@Nullable 2@Override 3public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) { 4 getDialog().</description>
    </item>
    
  </channel>
</rss>
