<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jetpack on 个人主页</title>
    <link>http://lalalaxiaowifi.gitee.io/pictures/series/jetpack/</link>
    <description>Recent content in Jetpack on 个人主页</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2020-2099</copyright><atom:link href="http://lalalaxiaowifi.gitee.io/pictures/series/jetpack/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>探索 Jetpack 库</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/jetpack/%E6%8E%A2%E7%B4%A2-jetpack-%E5%BA%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/jetpack/%E6%8E%A2%E7%B4%A2-jetpack-%E5%BA%93/</guid>
      <description>顺便推一下博客主页
 正文  还是老规矩，先上官网 官网 ，然后就是 jetpack 支持些什么。支持与包含 ，最后是找到demo地址，然后拉demo源码 学习了。demo地址 这里就需要着重点一下设计模式了。常见的mvc.mvp,mvvm.而 jetpack 就支持了mvvm.当然也不是说，用了jetpack就不能写MVC不能写mvp了。 但是一个项目中最好固定一种设计模式。一套写法是最好的。而mvvm 只要注释写得好，比其他两个更好维护和阅读。 既然是mvvm.和mvp和mvc 还是有区别的，mvp和mvc Google并没有提供对应的组件，一般都是自己封装，需要注意生命周期什么的。但是mvvm,Google 开始提供对应的组件。同时开始优化开发流程和代码可读性了。
 ViewModel 教程地址 提供数据，这里面可以写的和 P层差不多，获取数据，处理数据什么的。 LiveData 提供数据更新观察能力，和生命周期绑定。和viewModel绑定，而P层大概就是ViewModel+liveDate的集合体。 databinding 主要是负责 界面渲染数据，这个可以少一层，findviewbyid。 然后模块解耦，虽然这个mvvm是一个整体，但是搬砖过程中，难免会遇到 不同模块的子模块有相同的，不解耦的话，就会出现一个东西重复出现调用，虽然可以通过设计模式设置不同的server实现。也可以了解下依赖注入。 最后就是数据缓存 sqlite 和room的使用了。room骚的是 他基本上是一个表一个库，所以需要注意连接池中的连接逻辑，通常只有一个数据库处于连接状态（待确认）。   ViewModel  教程地址 Android 框架可以管理界面控制器（如 Activity 和 Fragment）的生命周期。Android 框架可能会决定销毁或重新创建界面控制器，以响应完全不受您控制的某些用户操作或设备事件。 如果系统销毁或重新创建界面控制器，则存储在其中的任何瞬态界面相关数据都会丢失。例如，应用可能会在它的某个 Activity 中包含用户列表。为配置更改重新创建 Activity 后，新 Activity 必须重新提取用户列表。对于简单的数据，Activity 可以使用 onSaveInstanceState() 方法从 onCreate() 中的捆绑包恢复其数据，但此方法仅适合可以序列化再反序列化的少量数据，而不适合数量可能较大的数据，如用户列表或位图。 另一个问题是，界面控制器经常需要进行可能需要一些时间才能返回的异步调用。界面控制器需要管理这些调用，并确保系统在其销毁后清理这些调用以避免潜在的内存泄漏。此项管理需要大量的维护工作，并且在为配置更改重新创建对象的情况下，会造成资源的浪费，因为对象可能需要重新发出已经发出过的调用。 诸如 Activity 和 Fragment 之类的界面控制器主要用于显示界面数据、对用户操作做出响应或处理操作系统通信（如权限请求）。如果要求界面控制器也负责从数据库或网络加载数据，那么会使类越发膨胀。为界面控制器分配过多的责任可能会导致单个类尝试自己处理应用的所有工作，而不是将工作委托给其他类。以这种方式为界面控制器分配过多的责任也会大大增加测试的难度。 从界面控制器逻辑中分离出视图数据所有权的操作更容易且更高效。
 主要还是图片问题，无论是自己绘制的还是网络过来的，虽然可以有多级缓存。但是还是得自己去整一套吧。这个用得少，问题1，他缓存的数据我们应该不用管，然后正常关闭的再打开的数据，应该还是要从本地或者服务器拉去吧、 在配置更改期间会自动保留 ViewModel 对象，以便它们存储的数据立即可供下一个 Activity 或 Fragment 实例使用。这句话，感觉没懂，再配置更改期间是什么意思。 那么懂 “配置更改期间” 这个范围就很重要了。处理配置变更 这个里面对配置变更就有描述:</description>
    </item>
    
  </channel>
</rss>
