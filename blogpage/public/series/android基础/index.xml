<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>android基础 on 个人主页</title>
    <link>http://lalalaxiaowifi.gitee.io/pictures/series/android%E5%9F%BA%E7%A1%80/</link>
    <description>Recent content in android基础 on 个人主页</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2020-2099</copyright>
    <lastBuildDate>Mon, 04 Jan 2021 00:00:00 +0000</lastBuildDate><atom:link href="http://lalalaxiaowifi.gitee.io/pictures/series/android%E5%9F%BA%E7%A1%80/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Rxjava观察者</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E5%88%9B%E5%BB%BA%E8%A7%82%E5%AF%9F%E8%80%85/</link>
      <pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E5%88%9B%E5%BB%BA%E8%A7%82%E5%AF%9F%E8%80%85/</guid>
      <description>前言 本Demo 主要是针对 Rxjava Android 版本进行实践
Rxjava Android 版本 github 地址 Rxjava 地址 Rxjava 官方文档地址 观察者创建 observer  2.0 import io.reactivex.Observer; 观察者用于接收 被观察者提供的数据信息。暂时不清楚被观察者调用其他观察者的逻辑。
  new Observer&amp;lt;泛型&amp;gt;(){};需要需要实现方法。Android上网络请求通常使用这个就好了。  其他观察者 其他观察者 2.2.20 提供观察者 位于io.reactivex.functions 包下 
 Action BiConsumer BiFunction BiPredicate BooleanSupplier Cancellable Consumer Function Function3 Function4 Function5 Function6 Function7 Function8 Function9 IntFunction LongConsumer Predicate  action 一个类似于Runnable的功能接口，但允许抛出一个已检查的异常。
1 2 </description>
    </item>
    
    <item>
      <title>Rxjava使用CompositeDisposable进行统一注销监听</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E4%B8%ADcompositedisposable%E8%BF%9B%E8%A1%8C%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86%E6%B3%A8%E9%94%80/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E4%B8%ADcompositedisposable%E8%BF%9B%E8%A1%8C%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86%E6%B3%A8%E9%94%80/</guid>
      <description>前言 本Demo 主要是针对 Rxjava Android 版本进行实践
Rxjava Android 版本 github 地址 Rxjava 地址 Rxjava 官方文档地址 正文  在观察者的回调方法中，有一个onSubscribe(Disposable d) 开始连接方法，Disposable 可以控制是否关闭后面的回调。JAVA 对象是有生命周期的。 这个时候，对于某些监听回调，就可以统一安排处理了。
 1 private final CompositeDisposable mDisposable = new CompositeDisposable(); 2// subscribe 需要使用返回 一个Disposable的那个方法。 3 Disposable md = Observable.create(new ObservableOnSubscribe&amp;lt;Integer&amp;gt;() { 4 @Override 5 public void subscribe(ObservableEmitter&amp;lt;Integer&amp;gt; e) throws Exception { 6 7 } 8 }).subscribe(integer -&amp;gt; Log.e(TAG, &amp;#34;demo2: &amp;#34; + integer)); 9 disposable.add(md); 10 11@Override 12 protected void onStop() { 13 super.</description>
    </item>
    
    <item>
      <title>Rxjava其他运算</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E5%85%B6%E4%BB%96%E8%BF%90%E7%AE%97/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E5%85%B6%E4%BB%96%E8%BF%90%E7%AE%97/</guid>
      <description>前言 本Demo 主要是针对 Rxjava Android 版本进行实践
Rxjava Android 版本 github 地址 Rxjava 地址 Rxjava 官方文档地址 正文 链式调用 Observable  背压运算符 Backpressure Operators 背压运算符-处理可观察对象的策略，可观察对象的产生速度比观察者消耗它们的速度快 可连接的可观察算子 具有更精确控制的订阅动态的专业可观察物  Connect -指示可连接的Observable开始向其订阅者发送项目 Publish —将普通的Observable转换为可连接的Observable RefCount -使Connectable Observable表现得像普通的Observable Replay —确保所有观察者看到相同的发射项目序列，即使他们在Observable开始发射项目之后进行订阅  运营商转换可观察物  To —将O​​bservable转换为另一个对象或数据结构 Rxjava所有方法 可观察算子的字母顺序列表
Rxjava所有方法 可观察算子的字母顺序列表</description>
    </item>
    
    <item>
      <title>Rxjava创建被观察者Observable</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E5%88%9B%E5%BB%BA%E8%A2%AB%E8%A7%82%E5%AF%9F%E8%80%85/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E5%88%9B%E5%BB%BA%E8%A2%AB%E8%A7%82%E5%AF%9F%E8%80%85/</guid>
      <description>前言 本Demo 主要是针对 Rxjava Android 版本进行实践
Rxjava Android 版本 github 地址 Rxjava 地址 Rxjava 官方文档地址 正文 Observable 主要是创建一个新的被观察者Observable
Create —通过编程调用观察者方法从头开始创建Observable Defer —在观察者订阅之前不要创建Observable，并为每个观察者创建一个新的Observable Empty/ Never/Throw -创建具有非常精确和限制行为观测量 From —将其他一些对象或数据结构转换为可观察的 Interval —创建一个Observable，它发出以特定时间间隔隔开的整数序列 Just —将一个对象或一组对象转换为发出该对象或那些对象的Observable Range —创建一个Observable，它发出一系列连续整数 Repeat —创建一个Observable，它反复发出特定的项目或项目序列 Start —创建一个Observable，它发出函数的返回值 Timer —创建一个Observable，它在给定的延迟后发出单个项目 Rxjava所有方法 可观察算子的字母顺序列表</description>
    </item>
    
    <item>
      <title>Rxjava数学运算符和聚合运算符Observable</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%81%9A%E5%90%88%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%81%9A%E5%90%88%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>前言 本Demo 主要是针对 Rxjava Android 版本进行实践
Rxjava Android 版本 github 地址 Rxjava 地址 Rxjava 官方文档地址 正文 Observable 对Observable发出的整个项目序列进行操作的运算符
Average —计算Observable发出的数字的平均值，并发出该平均值 Concat —从两个或多个可观测对象发射的发射，而不会相互干扰 Count —计算源Observable发出的项目数，仅发出此值 Max —确定并发出Observable发出的最大价值的物品 Min —确定并发出Observable发出的最小值项 Reduce —将函数依次应用于Observable发出的每个项目，并发出最终值 Sum —计算一个Observable发出的数字的总和，并发出该总和 Rxjava所有方法 可观察算子的字母顺序列表</description>
    </item>
    
    <item>
      <title>Rxjava最简单的使用</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>前言 本Demo 主要是针对 Rxjava Android 版本进行实践
Rxjava Android 版本 github 地址 Rxjava 地址 Rxjava 官方文档地址 正文 链式调用 Observable 1 Observable.create(new ObservableOnSubscribe&amp;lt;Integer&amp;gt;() { 2 @Override 3 public void subscribe(ObservableEmitter&amp;lt;Integer&amp;gt; e) throws Exception { 4 e.onNext(5); 5 e.onComplete(); 6 } 7 }).observeOn(Schedulers.newThread()).subscribeOn(AndroidSchedulers.mainThread()) 8 .subscribe(new Observer&amp;lt;Integer&amp;gt;() { 9 @Override 10 public void onSubscribe(Disposable d) { 11 12 } 13 14 @Override 15 public void onNext(Integer value) { 16 17 } 18 19 @Override 20 public void onError(Throwable e) { 21 22 } 23 24 @Override 25 public void onComplete() { 26 27 } 28 }); Lambda 表达式版本 1 Observable.</description>
    </item>
    
    <item>
      <title>Rxjava条件运算符和布尔运算符Observable</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>前言 本Demo 主要是针对 Rxjava Android 版本进行实践
Rxjava Android 版本 github 地址 Rxjava 地址 Rxjava 官方文档地址 正文 Observable 条件运算符和布尔运算符 评估一个或多个可观察对象或可观察对象发出的项目的运算符
All —确定可观察对象发出的所有项目是否都满足某些条件 Amb —给定两个或多个源Observable，仅从这些Observable中的第一个发出所有项目以发出一个项目 Contains —确定一个Observable是否发出特定项目 DefaultIfEmpty —从源Observable发射项目，如果源Observable不发射任何东西，则为默认项目 SequenceEqual —确定两个可观察对象是否发出相同的项目序列 SkipUntil —丢弃可观察对象发出的物品，直到第二个可观察对象发出物品为止 SkipWhile —丢弃Observable发出的项目，直到指定条件为假 TakeUntil —在第二个Observable发出项目或终止后，丢弃Observable发出的项目 TakeWhile —在指定条件为假之后，丢弃Observable发出的项目 Rxjava所有方法 可观察算子的字母顺序列表</description>
    </item>
    
    <item>
      <title>Rxjava组合结合被观察者Observable</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E7%BB%93%E5%90%88%E7%BB%84%E5%90%88%E8%A2%AB%E8%A7%82%E5%AF%9F%E8%80%85/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E7%BB%93%E5%90%88%E7%BB%84%E5%90%88%E8%A2%AB%E8%A7%82%E5%AF%9F%E8%80%85/</guid>
      <description>前言 本Demo 主要是针对 Rxjava Android 版本进行实践
Rxjava Android 版本 github 地址 Rxjava 地址 Rxjava 官方文档地址 正文 Observable And/ Then/When -联合组由两个或更多发射观测量项借助于Pattern与Plan中介 CombineLatest —当两个Observable之一发射一个项目时，通过指定的函数合并每个Observable发射的最新项目，并根据此函数的结果发射项目 Join —在根据另一个可观察对象发出的项目定义的时间窗口中，只要发射了一个可观察对象的项目，则合并两个可观察对象发出的项目 Merge -通过合并排放量将多个可观测值合并为一个 StartWith —在开始从源中发出项目之前，发出指定的项目序列 Switch —将发出Observable的Observable转换为发出可观察到的最新事物的单个Observable Zip —通过指定的函数将多个可观测对象的发射合并在一起，并根据此函数的结果为每个组合发射单个项目 Rxjava所有方法 可观察算子的字母顺序列表</description>
    </item>
    
    <item>
      <title>Rxjava转换被观察者Observable</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E8%BD%AC%E6%8D%A2%E8%A2%AB%E8%A7%82%E5%AF%9F%E8%80%85/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E8%BD%AC%E6%8D%A2%E8%A2%AB%E8%A7%82%E5%AF%9F%E8%80%85/</guid>
      <description>前言 本Demo 主要是针对 Rxjava Android 版本进行实践
Rxjava Android 版本 github 地址 Rxjava 地址 Rxjava 官方文档地址 正文 Observable 主要是转换被观察者Observable
Buffer —定期将来自一个Observable的项目收集成束，然后发出这些束，而不是一次发出一个 FlatMap —将可观察对象发出的项目转换为可观察项目，然后将这些项目的排放平展为单个可观察项目 GroupBy —将一个Observable划分为一组Observable，它们分别与原始Observable发射一组不同的项，并按key进行组织 Map —通过对每个项目应用函数来转换Observable发出的项目 Scan —将函数依次应用于Observable发出的每个项目，并发出每个连续的值 Window —定期将项目从“可观察”窗口细分为“可观察”窗口，然后发出这些窗口，而不是一次发出一个窗口 Rxjava所有方法 可观察算子的字母顺序列表</description>
    </item>
    
    <item>
      <title>Rxjava过滤被观察者Observable</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E8%BF%87%E6%BB%A4%E8%A2%AB%E8%A7%82%E5%AF%9F%E8%80%85/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E8%BF%87%E6%BB%A4%E8%A2%AB%E8%A7%82%E5%AF%9F%E8%80%85/</guid>
      <description>前言 本Demo 主要是针对 Rxjava Android 版本进行实践
Rxjava Android 版本 github 地址 Rxjava 地址 Rxjava 官方文档地址 正文 Observable 主要是过滤被观察者Observable
Debounce —仅在经过特定时间跨度时才从Observable发出一项，而不发出另一项 Distinct -抑制可观察对象发出的重复项 ElementAt—仅发射可观察对象发射的项目n Filter —仅从可观察对象中发出通过谓词测试的项 First —仅从Observable发射第一项或满足条件的第一项 IgnoreElements —不要从Observable发出任何项目，而是镜像其终止通知 Last —只发射可观察对象发射的最后一个项目 Sample —定期发射Observable发射的最新项目 Skip—抑制Observable发出的前n个项目 SkipLast—抑制Observable发出的最后n个项目 Take—仅发射可观察对象发射的前n个项目 TakeLast—只发射可观察对象发射的最后n个项目 Rxjava所有方法 可观察算子的字母顺序列表</description>
    </item>
    
    <item>
      <title>Rxjava错误处理被观察者Observable</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E8%A2%AB%E8%A7%82%E5%AF%9F%E8%80%85/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E8%A2%AB%E8%A7%82%E5%AF%9F%E8%80%85/</guid>
      <description>前言 本Demo 主要是针对 Rxjava Android 版本进行实践
Rxjava Android 版本 github 地址 Rxjava 地址 Rxjava 官方文档地址 正文 Observable 有助于从Observable的错误通知中恢复的运算符
Catch-onError通过继续执行顺序而没有错误地从通知中恢复 Retry—如果源Observable发送了onError通知，请重新订阅该通知，以希望它可以完成而不会出错 Rxjava所有方法 可观察算子的字母顺序列表</description>
    </item>
    
    <item>
      <title>Rxjava错误处理被观察者Observable</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/%E5%8F%AF%E8%A7%82%E5%AF%9F%E7%9A%84%E5%85%AC%E7%94%A8%E4%BA%8B%E4%B8%9A%E8%BF%90%E8%90%A5%E5%95%86/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/%E5%8F%AF%E8%A7%82%E5%AF%9F%E7%9A%84%E5%85%AC%E7%94%A8%E4%BA%8B%E4%B8%9A%E8%BF%90%E8%90%A5%E5%95%86/</guid>
      <description>前言 本Demo 主要是针对 Rxjava Android 版本进行实践
Rxjava Android 版本 github 地址 Rxjava 地址 Rxjava 官方文档地址 正文 Observable 一个有用的运算符的工具箱，用于处理Observables
Delay —将排放量从可观察的时间向前移特定量 Do -注册一项行动以应对各种可观察到的生命周期事件 Materialize/Dematerialize —表示发出的项目和作为发出的项目发送的通知，或者逆转此过程 ObserveOn -指定观察者将在其上观察此Observable的调度程序 Serialize -强制Observable进行序列化调用并保持良好行为 Subscribe -根据观测对象的排放和通知进行操作 SubscribeOn —指定Observable订阅时应使用的调度程序 TimeInterval —将发射项目的Observable转换为发射项目，以指示两次发射之间经过的时间 Timeout —镜像源Observable，但如果经过特定时间但没有任何发射项，则发出错误通知 Timestamp —将时间戳记附加到Observable发出的每个项目 Using -创建与可观察对象具有相同使用寿命的可使用资源 Rxjava所有方法 可观察算子的字母顺序列表</description>
    </item>
    
    <item>
      <title>Android中关于Rxjava Flowable相关笔记整理</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E5%85%B3%E4%BA%8Eflowable/</link>
      <pubDate>Wed, 30 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E5%85%B3%E4%BA%8Eflowable/</guid>
      <description>前言 本Demo 主要是针对 Rxjava Android 版本进行实践
Rxjava Android 版本 github 地址 Rxjava 地址 Rxjava 官方文档地址 Rxjava javaDoc地址
正文  如果上游发射的很快而下游处理的很慢，会怎样呢？ 将会产生很多下游没来得及处理的数据，这些数据既不会丢失，也不会被垃圾回收机制回收，而是存放在一个异步缓存池中，如果缓存池中的数据一直得不到处理，越积越多，最后就会造成内存溢出，这便是Rxjava中的背压问题。 Flowable类实现了反应式流模式，并提供了工厂方法，中间运算符以及使用反应式数据流的能力.
 1Flowable.create(new FlowableOnSubscribe&amp;lt;Integer&amp;gt;() { 2 @Override 3 public void subscribe(FlowableEmitter&amp;lt;Integer&amp;gt; emitter) throws Exception { 4 emitter.onNext(1); 5 emitter.onNext(2); 6 emitter.onNext(3); 7 emitter.onNext(4); 8 emitter.onComplete(); 9 } 10 }, BackpressureStrategy.BUFFER).subscribe(new Subscriber&amp;lt;Integer&amp;gt;() { 11 @Override 12 public void onSubscribe(Subscription s) { 13 s.request(Long.MAX_VALUE); 14 System.out.print(&amp;#34;onSubscribe&amp;#34; + s); 15 } 16 17 @Override 18 public void onNext(Integer integer) { 19 System.</description>
    </item>
    
    <item>
      <title>Android中关于Rxjava Flowable相关笔记整理(转载)</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E4%B8%ADflowable%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0%E8%BD%AC%E8%BD%BD/</link>
      <pubDate>Wed, 30 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E4%B8%ADflowable%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0%E8%BD%AC%E8%BD%BD/</guid>
      <description>前言 本Demo 主要是针对 Rxjava Android 版本进行实践
Rxjava Android 版本 github 地址 Rxjava 地址 Rxjava 官方文档地址 Rxjava javaDoc地址
正文 数据流发射，处理，响应可能在各自的线程中独立进行，上游在发射数据的时候，不知道下游是否处理完，也不会等下游处理完之后再发射。
这样，如果上游发射的很快而下游处理的很慢，会怎样呢？
将会产生很多下游没来得及处理的数据，这些数据既不会丢失，也不会被垃圾回收机制回收，而是存放在一个异步缓存池中，如果缓存池中的数据一直得不到处理，越积越多，最后就会造成内存溢出，这便是Rxjava中的背压问题。
例如，运行以下代码：
demo1.jpg
创建一个可观察对象Obervable在Schedulers.newThread()()的线程中不断发送数据，而观察者Observer在Schedulers.newThread()的另一个线程中每隔5秒接收一条数据，运行后，查看内存使用如下：
backpressure.gif
由于上下游分别在各自的线程中独立处理数据（如果上下游在同一线程中，下游对数据的处理会堵塞上游数据的发送，上游发送一条数据后会等下游处理完之后再发送下一条），而上游发送数据速度远大于下游接收数据的速度，造成上下游流速不均，导致数据累计，最后引起内存溢出。
Flowable
Flowable是为了解决背压（backpressure）问题，而在Observable的基础上优化后的产物，与Observable不是同一组观察者模式下的成员，Flowable是Publisher与Subscriber这一组观察者模式中Publisher的典型实现，Observable是ObservableSource/Observer这一组观察者模式中ObservableSource的典型实现；
所以在使用Flowable的时候，可观察对象不再是Observable,而是Flowable;观察者不再是Observer，而是Subscriber。Flowable与Subscriber之间依然通过subscribe()进行关联。
有些朋友可能会想，既然Flowable是在Observable的基础上优化后的产物，Observable能解决的问题Flowable都能进行解决，何不抛弃Observable而只用Flowable呢。其实，这是万万不可的，他们各有自己的优势和不足。
由于基于Flowable发射的数据流，以及对数据加工处理的各操作符都添加了背压支持，附加了额外的逻辑，其运行效率要比Observable低得多。
因为只有上下游运行在各自的线程中，且上游发射数据速度大于下游接收处理数据的速度时，才会产生背压问题。
所以，如果能够确定上下游在同一个线程中工作，或者上下游工作在不同的线程中，而下游处理数据的速度高于上游发射数据的速度，则不会产生背压问题，就没有必要使用Flowable，以免影响性能。
通过Flowable发射处理数据流的基础代码如下：
demo2.jpg
执行结果如下：
System.out: 发射----&amp;gt; 1System.out: 发射----&amp;gt; 2System.out: 发射----&amp;gt; 3System.out: 发射----&amp;gt; 完成System.out: 接收----&amp;gt; 1System.out: 接收----&amp;gt; 2System.out: 接收----&amp;gt; 3System.out: 接收----&amp;gt; 完成
我们发现运行结果与Observerable没有区别，但是的代码中，除了为上下游指定各自的运行线程外，还有三点不同
一、create方法中多了一个BackpressureStrategy类型的参数。
二、onSubscribe回调的参数不是Disposable而是Subscription，多了行代码：
s.request(Long.MAX_VALUE);
三、Flowable发射数据时，使用的发射器是FlowableEmitter而不是ObservableEmitter
BackpressureStrategy背压策略
在Flowable的基础创建方法create中多了一个BackpressureStrategy类型的参数，
BackpressureStrategy是个枚举，源码如下：
publicenumBackpressureStrategy { ERROR,BUFFER,DROP,LATEST,MISSING}
其作用是什么呢？
Flowable的异步缓存池不同于Observable，Observable的异步缓存池没有大小限制，可以无限制向里添加数据，直至OOM,而Flowable的异步缓存池有个固定容量，其大小为128。
BackpressureStrategy的作用便是用来设置Flowable通过异步缓存池存储数据的策略。
ERROR
在此策略下，如果放入Flowable的异步缓存池中的数据超限了，则会抛出MissingBackpressureException异常。
运行如下代码：</description>
    </item>
    
    <item>
      <title>Android中关于Rxjava相关笔记整理</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/android%E4%B8%ADrxjava%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/</link>
      <pubDate>Wed, 30 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/android%E4%B8%ADrxjava%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/</guid>
      <description>前言 本Demo 主要是针对 Rxjava Android 版本进行实践
Rxjava Android 版本 github 地址 Rxjava 地址 Rxjava 官方文档地址 Rxjava javaDoc地址
正文 被观察者 创建可观察物 产生新的Observable的运算符。
 Create —通过编程调用观察者方法从头开始创建Observable Defer -在观察者订阅之前不要创建Observable，并为每个观察者创建一个新的Observable Empty/ Never/Throw -创建具有非常精确和限制行为观测量 From —将其他一些对象或数据结构转换为可观察的 Interval —创建一个Observable，它发出以特定时间间隔隔开的整数序列 Just —将一个对象或一组对象转换为发出该对象或那些对象的Observable Range —创建一个Observable，它发出一系列连续整数 Repeat —创建一个Observable，它反复发出特定的项目或项目序列 Start —创建一个Observable，它发出函数的返回值 Timer —创建一个Observable，它在给定的延迟后发出单个项目  转换可观察物 转换由Observable发出的项目的运算符。
 Buffer —定期将来自一个Observable的项目收集成束，然后发出这些束，而不是一次发出一个 FlatMap —将可观察对象发出的项目转换为可观察项目，然后将这些项目的排放平展为单个可观察项目 GroupBy —将一个Observable划分为一组Observable，它们分别与原始Observable发射一组不同的项，并按key进行组织 Map —通过对每个项目应用函数来转换Observable发出的项目 Scan —将一个函数依次应用于Observable发出的每个项目，并发出每个连续的值 Window —定期将项目从“可观察”窗口细分为“可观察”窗口，然后发出这些窗口，而不是一次发出一个窗口  过滤可观察物 有选择地从Observable源发出项目的运算符。
 Debounce —仅在经过特定时间跨度时才从Observable中发出一项，而不发出另一项 Distinct -抑制可观察对象发出的重复项 ElementAt —仅发射可观察对象发射的项目n Filter —仅从可观察对象中发出通过谓词测试的项 First —仅从Observable发出第一项或满足条件的第一项 IgnoreElements —不要从Observable发出任何项目，而是镜像其终止通知 Last —只发射可观察对象发射的最后一个项目 Sample —定期发射Observable发射的最新项目 Skip —抑制Observable发出的前n个项目 SkipLast —抑制Observable发出的最后n个项目 Take —仅发射可观察对象发射的前n个项目 TakeLast —只发射可观察对象发射的最后n个项目  结合可观察物 与多个源Observables一起创建单个Observable的运算符</description>
    </item>
    
    <item>
      <title>sql分组查询</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/sql%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Tue, 29 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/sql%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/</guid>
      <description>当前笔记复制来源于：https://www.cnblogs.com/friday69/p/9389720.html
 1.SQL分组查询GroupBy+Group_concat group by 是分组，是分组，是分组，分组并不是去重，而是分组
将查询结果按一个或多个进行分组，字段值相同的为一组
GroupBy+Group_concat ： 表示分组之后，根据分组结果，使用 group_contact() 来放置每一组的每字段的值的集合
1select deparmant, GROUP_CONCAT(`name`) from employee GROUP BY deparmant 根据 department 分组，通过 group_concat（&#39;name&#39;）,查看每组里面的姓名都有哪些
1SELECT gender,GROUP_CONCAT(`name`) from employee GROUP BY gender 根据gender 分类，看 不同的 性别都有哪些 人
分组注意事项： 在分组时，select后面跟的的字段一般都会出现在 group by 后
1SELECT name,gender from employee GROUP BY gender,name 2-- 先按gender分组，再按姓名分组...  2.SQL分组+聚合函数 1select deparmant, GROUP_CONCAT(salary), SUM(salary),AVG(salary) 平均工资,MAX(salary) 最高工资 from employee GROUP BY deparmant; 2-- 根据department 分组，计算各部门下工资总数，平均工资，最高工资![1532919789347](D:\Python\python_learning\Python_Blog\02\SQL\4.png) 1-- 查询每个部门的部门名称以及每个部门的人数 2SELECT deparmant, GROUP_CONCAT(`name`), COUNT(*) from employee GROUP BY deparmant 1-- 查询每个部门的部门名称以及每个部门工资大于1500的人数 2SELECT deparmant,GROUP_CONCAT(salary), COUNT(*) from employee WHERE salary &amp;gt; 1500 GROUP BY deparmant 3.</description>
    </item>
    
    <item>
      <title>SQL知识点汇总</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/sql%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</link>
      <pubDate>Mon, 28 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/sql%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</guid>
      <description>前言  最近写Demo的时候，经常发现自己对于sql好多都忘记了。
 简单使用  SELECT 查询 后面接查询字段 SELECT DISTINCT 查询 去重 WHERE 多条件查询，用and 连接 and or 多条件查询拼接 order by 对结果进行排序，默认是升序，ORDER BY DESC 降序，ORDER BY 多列（这个多列不是太懂） INSERT INTO 插入数据 UPDATE 更新数据 DELETE 删除数据  进阶  SELECT TOP, LIMIT, ROWNUM 用于规定返回记录的条目数 LIKE like查询 通配符  % 替代0个或者多个字符 &#39;-&#39; 替代一个字符 [charlist] 字符列中的任何单一字符 [^charlist] 或 [!charlist] 不在字符列中的任何单一字符   in 查询，有点类型 数组中的那个 indexof ,可传入同一个字段的多个值 BETWEEN 用于取两个值之间的范围值 两个值用 and 连接 NOT BETWEEN 不在范围内 别名 AS 比如说 name as n ,就是将name设置为 n, JOIN 将两个或者多个表结合起来，基于共同字段。 INNER JOIN 查询条件满足的行 LEFT JOIN 从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。 RIGHT JOIN 关键字从右表（table2）返回所有的行，即使左表（table1）中没有匹配。如果左表中没有匹配，则结果为 NULL。 FULL OUTER JOIN 关键字只要左表（table1）和右表（table2）其中一个表中存在匹配，则返回行.</description>
    </item>
    
    <item>
      <title>androidSqlite查询思路整理</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/sqlite%E6%9F%A5%E8%AF%A2%E7%8C%9C%E6%83%B3/</link>
      <pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/sqlite%E6%9F%A5%E8%AF%A2%E7%8C%9C%E6%83%B3/</guid>
      <description>前言 今天有一个大佬的公众号推了一篇，sql查询慢的原因。 为什么大家都说SELECT * 效率低 上面是原文。 由于收集癖的原因，同时怕以后找不到了，就复制下觉得重要的部分到自己的笔记里面。
复制内容 一、效率低的原因 先看一下最新《阿里java开发手册（泰山版）》中 MySQL 部分描述：
4 - 1. 【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。 说明：
增加查询分析器解析成本。
增减字段容易与 resultMap 配置不一致。
无用字段增加网络 消耗，尤其是 text 类型的字段。 开发手册中比较概括的提到了几点原因，让我们深入一些看看：
1. 不需要的列会增加数据传输时间和网络开销 用“SELECT * ”数据库需要解析更多的对象、字段、权限、属性等相关内容，在 SQL 语句复杂，硬解析较多的情况下，会对数据库造成沉重的负担。
增大网络开销；* 有时会误带上如log、IconMD5之类的无用且大文本字段，数据传输size会几何增涨。如果DB和应用程序不在同一台机器，这种开销非常明显
即使 mysql 服务器和客户端是在同一台机器上，使用的协议还是 tcp，通信也是需要额外的时间。
2. 对于无用的大字段，如 varchar、blob、text，会增加 io 操作 准确来说，长度超过 728 字节的时候，会先把超出的数据序列化到另外一个地方，因此读取这条记录会增加一次 io 操作。（MySQL InnoDB）
3. 失去MySQL优化器“覆盖索引”策略优化的可能性 SELECT * 杜绝了覆盖索引的可能性，而基于MySQL优化器的“覆盖索引”策略又是速度极快，效率极高，业界极为推荐的查询优化方式。
例如，有一个表为t(a,b,c,d,e,f)，其中，a为主键，b列有索引。
那么，在磁盘上有两棵 B+ 树，即聚集索引和辅助索引（包括单列索引、联合索引），分别保存(a,b,c,d,e,f)和(a,b)，如果查询条件中where条件可以通过b列的索引过滤掉一部分记录，查询就会先走辅助索引，如果用户只需要a列和b列的数据，直接通过辅助索引就可以知道用户查询的数据。
如果用户使用select *，获取了不需要的数据，则首先通过辅助索引过滤数据，然后再通过聚集索引获取所有的列，这就多了一次b+树查询，速度必然会慢很多。
由于辅助索引的数据比聚集索引少很多，很多情况下，通过辅助索引进行覆盖索引（通过索引就能获取用户需要的所有列），都不需要读磁盘，直接从内存取，而聚集索引很可能数据在磁盘（外存）中（取决于buffer pool的大小和命中率），这种情况下，一个是内存读，一个是磁盘读，速度差异就很显著了，几乎是数量级的差异。
二、索引知识延申 上面提到了辅助索引，在MySQL中辅助索引包括单列索引、联合索引（多列联合），单列索引就不再赘述了，这里提一下联合索引的作用
联合索引 (a,b,c)
联合索引 (a,b,c) 实际建立了 (a)、(a,b)、(a,b,c) 三个索引</description>
    </item>
    
    <item>
      <title>Android sqlite多余字段插入导致插入失败</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1sqlite%E6%8F%92%E5%85%A5%E5%A4%9A%E4%BA%8E%E5%AD%97%E6%AE%B5%E5%AF%BC%E8%87%B4%E7%9A%84%E6%8F%92%E5%85%A5%E5%A4%B1%E8%B4%A5/</link>
      <pubDate>Tue, 22 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1sqlite%E6%8F%92%E5%85%A5%E5%A4%9A%E4%BA%8E%E5%AD%97%E6%AE%B5%E5%AF%BC%E8%87%B4%E7%9A%84%E6%8F%92%E5%85%A5%E5%A4%B1%E8%B4%A5/</guid>
      <description>前言 顺着之前的sqlite写的统一插入语句。然后现在是需要多插入一个信息到一个表，由于来源挺多的，所以直接写到bean 中 顺便推一下博客主页
正文 直接上错误。 SQLiteDatabase: Error inserting table expenses has no column named showMessage (Sqlite code 1 SQLITE_ERROR): , while compiling: INSERT INTO expenses(money_china,pay_income_type,expenses_source_v,money,expenses_source,showMessage,name,remark,title,ledger_id,add_time,pay_income_type_v) VALUES (?,?,?,?,?,?,?,?,?,?,?,?), (OS error - 11:Try again) 直接说解决方案。
 直接修改插入的数据，将表中没有的字段移出。 插入的时候直接判断 表字段和插入数据的字段，表中没有的字段就不插入。  通过这个bug.可以很明确感觉到，数据库操作工具，比如说greendao 之类的，通过注解标记是否是表字段就很有用。
结束 谢谢光临，若觉得还行麻烦点一下赞，若觉得写得垃圾，欢迎批评指正。笔者知道自己文笔和表达能力很弱，如果您可以提供点宝贵的意见不胜感激。谢谢。
今天也可以是元气满满的一天哦。 更新需要审核。更新通常优先更新到gitee上面。
博客主页</description>
    </item>
    
    <item>
      <title>Android sqlite前言</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96sqlite%E7%9B%AE%E5%BD%95/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96sqlite%E7%9B%AE%E5%BD%95/</guid>
      <description>前言 话说现在已经2020年了，在Android 应用端上混混沌沌的搬砖已经3年多快4年了。之前也迷迷糊糊的写了些什么，但是却没有一个好一点的系列文章。大多数同行的评论都是&amp;quot;什么都懂一点，但是什么都不精&amp;quot;，还是蛮想改变这个现状的。所以打算认真写一个系列出来，因为最近在复习sqlite,想从各个大佬的项目中找到自己的不足。所以打算写一个sqlite的理解系列吧。
sqlite 通用（Android）   Android 系统内嵌了sqlite，所以使用sqlite的时候并不需要导入jar或者aar 文件或者连接池等。
  Android 中通过 SQLiteDatabase及其子类对表的创建，删除，改名，对内容的增删改查操作。同时可以获取版本号等其他操作。
  Android 上使用sqlite是可以更改 sqlite 存在的位置的，但是默认是/data/data/PACKAGE NAME/DB NAME目录*（就像您在设备的内部存储空间中保存文件一样，Android 会将您的数据库存储在您应用的私有文件夹中。您的数据安全无虞，因为在默认情况下，其他应用或用户无法访问此区域。）*。
  sqlite的更新和创建是在获取SQLiteDatabase的时候执行的（这个可以通过打印log知道）官方文档中提到*（SQLiteOpenHelper 类包含一组用于管理数据库的实用 API。当您使用此类获取对数据库的引用时，系统仅在需要时才执行可能需要长时间运行的数据库创建和更新操作，而不是在应用启动期间执行。您仅需调用 getWritableDatabase() 或 getReadableDatabase() 即可。）*
  sqlite 的表不支持直接重命名表名。如果想要更改表的名字，需要将原表名设置一个临时表名，然后通过新表名创建表，然后删除零时表。
  sqlite 只支持对表增加字段。如果需要删除字段，修改字段名，修改字段对应的类型，都需要通过创建新表，然后复制对应的数据到新表，再删除原表达到效果，这么一想，向表中增加字段也可以通过上面操作进行。
  sqlite 更新是通过检测版本号进行的。
  sqlite有一个sqlite_master 表，通过这个表可以查找所以表的表名，创建sql语句等。
  sqlite 可以查看表的信息和字段 通过 PRAGMA table_info(student) 语句。
  Cursir 使用完之后建议 执行cursor.close(); 关闭游标，但是SQLiteDatabase 不建议在SQLiteOpenHelper 中执行close() 方法，关闭了再同对象中使用可能会抛异常。同时再官方文档中提到（由于在数据库关闭时，调用 getWritableDatabase() 和 getReadableDatabase() 的成本比较高，因此只要您有可能需要访问数据库，就应保持数据库连接处于打开状态。通常情况下，最好在发出调用的 Activity 的 onDestroy() 中关闭数据库）。</description>
    </item>
    
    <item>
      <title>Android sqlite增删改查</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96sqlite%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96sqlite%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</guid>
      <description>前言 日常搬砖sqlite目录 再目录中提到了一些东西，有兴趣可以点过去看一下，觉得还行麻烦点下赞。
正文 第一步创建数据库 再目录文档中，引用了官方文档的一段话 SQLiteOpenHelper 类包含一组用于管理数据库的实用 API。当您使用此类获取对数据库的引用时，系统仅在需要时才执行可能需要长时间运行的数据库创建和更新操作，而不是在应用启动期间执行。您仅需调用 getWritableDatabase() 或 getReadableDatabase() 即可。
  第一步应该是创建数据库文件。通过上面的引用可以知道 我们创建 数据库文件只需要 继承 SQLiteOpenHelper即可。而SQLiteOpenHelper的构造函数需要传入context，name，factory,version.通常情况下，我们创建数据库的时候只需要context，name，version，name 确定数据库文件的名字，version用于判断创建或更新数据库。
  系统仅在需要时才执行可能需要长时间运行的数据库创建和更新操作，所以我们的创建表的sql语句是可以装到一个list 中的，当然也可以存放到一个map 中，通过表名+创建表的sql。只要我们不获取SQLiteDatabase 数据库就不会创建更新。
  由于在数据库关闭时，调用 getWritableDatabase() 和 getReadableDatabase() 的成本比较高，因此只要您有可能需要访问数据库，就应保持数据库连接处于打开状态 * ，我们决定使用单例。
  在onCreate 中通过execSQL();创建表。
所以整个 SQLiteOpenHelper 可以长这个样子： ​
1public class SqliteDBHelper extends SQLiteOpenHelper { 2 public static final String DATABASE_NAME = &amp;#34;base.db&amp;#34;; 3 public static final int DATABASE_VERSION = 1;//版本号 4 private static volatile SqliteDBHelper helper = null; 5 List&amp;lt;String&amp;gt; allTabs = new ArrayList&amp;lt;&amp;gt;();//这个存放所有的最新的SQL表。不同版本用户创建时候直接创建所以表。 6 7 private SqliteDBHelper(Context context) { 8 super(context, DATABASE_NAME, null, DATABASE_VERSION); 9 initAllSql(); 10 /*UpDateDao dao = new UpDateDao(getReadableDatabase(), allTabs); 11 dao.</description>
    </item>
    
    <item>
      <title>Android sqlite增删改查另类写法</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96sqlite%E5%A2%9E%E6%94%B9%E6%9F%A5%E5%8F%A6%E7%B1%BB%E5%86%99%E6%B3%95/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96sqlite%E5%A2%9E%E6%94%B9%E6%9F%A5%E5%8F%A6%E7%B1%BB%E5%86%99%E6%B3%95/</guid>
      <description>前言 啊哈，今天又更新了。接上一篇日常搬砖sqlite可用类型与存储类型 。
顺便推一下日常搬砖sqlite目录
之前又一篇博客提到了json 对象不仅仅可以通过对象class 解析，也可以解析成map.巧合的是sqlite 添加和更新需要的ContentValues 也是一个类似于map的结构。既然object 与map互转，同理可以解决 object可以和ContentValues 互相转化，是吧。还有一个点 cursor.getType(cursor.getColumnIndex(key)) 可以获取到值的type,所以开整。先总结下可能需要的逻辑。
  ContentValues 也是一个类似于map的结构。 逻辑上object可以和ContentValues 互相转化 cursor.getType(cursor.getColumnIndex(key)) 可以获取到值的type。 通过反射可以获取到对应字段设定的type Cursor 获取到的type 包含 FIELD_TYPE_NULL，FIELD_TYPE_INTEGER，FIELD_TYPE_FLOAT，FIELD_TYPE_STRING，FIELD_TYPE_BLOB（ps:不要问我从哪里看到的，点开对应的class 都有） ContentValues 支持存放主要类型：String，Byte，Short，Integer，Long，Float，Double，Boolean，byte[]等。（ps:不要问我从哪里看到的，点开对应的class 都有）   正文 通过反射拿到所以的Field 1/** 2 * 获取所有的内容，解决父类中参数获取不到的bug 3 * @param object 4 * @return 5 */ 6private static Field[] getAllFieldsByObject(Object object){ 7 Class clazz = object.getClass(); 8 List&amp;lt;Field&amp;gt; fieldList = new ArrayList&amp;lt;&amp;gt;(); 9 while (clazz != null){ 10 fieldList.</description>
    </item>
    
    <item>
      <title>Android sqlite更新</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96sqlite%E6%9B%B4%E6%96%B0/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96sqlite%E6%9B%B4%E6%96%B0/</guid>
      <description>前言 顺便推一下日常搬砖sqlite目录
这个目录里面有sqlite 初始化 增删改查等一些东西，我们就接着这个系列讲数据库更新，之前我们数据库更新判断是通过版本号进行的。而且有一个问题哈，如果我有1，2，3，4，5，共5个版本，通过为了分别应对每个版本，onUpgrade这个方法里面要写很长的东西，简单粗暴的方式当然就是用户强制升级到最新版本，那么我们就只需要处理最新版本的事情了，问题是每一次升级不都是当前最新版本吗？开发阶段中，通过数据库版本号升级要写一大堆逻辑，卸载的化数据又没有了。于是比较懒的我就开始思考一个问题，我每次用之前检测一次是否一致不就好了？那么就需要准备需要的理论知识了、
 系统仅在需要时才执行可能需要长时间运行的数据库创建和更新操作，而不是在应用启动期间执行。您仅需调用 getWritableDatabase() 或 getReadableDatabase() 即可。（这个获取运行时） sqlite 的表不支持直接重命名表名。如果想要更改表的名字，需要将原表名设置一个临时表名，然后通过新表名创建表，然后删除零时表。 sqlite 只支持对表增加字段。如果需要删除字段，修改字段名，修改字段对应的类型，都需要通过创建新表，然后复制对应的数据到新表，再删除原表达到效果，这么一想，向表中增加字段也可以通过上面操作进行。 sqlite有一个sqlite_master 表，通过这个表可以查找所以表的表名，创建sql语句等。 sqlite 可以查看表的信息和字段 通过 PRAGMA table_info(student) 语句。 cursor.getColumnNames()。  正文 通过上面的理论依据，我觉得下面的理论是可行的。
  在获取SQLiteDatabase 之后立即运行一次更新检测逻辑。
  将创建表的sql语句通过list 或者map 存储起来。
  通过sqlite_master获得表名和创建语句
  通过创建sql与sqlite_master获得的创建sql语句对比，同时优先判断是否有创建的表名。
  如果没有则创建表，如果有比对创建sql是否一致。如果创建sql不一致，将原表名重命名为临时表，然后通过创建表，将原表中的数据通过ContentValues取出，赋值到创建表中，然后删除临时表。
  这么写有一个逻辑问题，如果表中的一个字段修改类型之后，可能导致插入失败。建议参考 日常搬砖sqlite可用类型与存储类型，所以不建议对字段修改类型，汉语博大精深换一个名字我觉得是可以的。
  如果忽略6这一点，那么我们的sqlite 启动检查更新的逻辑还是行得通的，毕竟只是对表名和表创建sql进行比对，这个还是很快的。当然性能肯定没有版本号更新好，但是胜在简单粗暴。ps(这只是一种思路，我孤陋寡闻的，反正我的没有见过别人这么写过，毕竟性价比太低了，还是应该老老实实的更新版本号的)那么就可以开整。
通过sqlite_master 获取表名和创建sql 1public Map&amp;lt;String,String&amp;gt; getAllTabs() { 2 Map&amp;lt;String,String&amp;gt; map=new HashMap&amp;lt;&amp;gt;(); 3 String sql = &amp;#34; SELECT * FROM sqlite_master WHERE type = &amp;#39;table&amp;#39;&amp;#34;;//PRAGMA table_info(student) 这个也可以查询表信息。但是只能针对某一个知道表名的表。 4 Cursor cursor = db.</description>
    </item>
    
    <item>
      <title>Android sqlite约束</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96sqlite%E7%BA%A6%E6%9D%9F/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96sqlite%E7%BA%A6%E6%9D%9F/</guid>
      <description>前言 顺便推一下日常搬砖sqlite目录 。
接着上面的写，之前有写到使用sqlite 实现增删改查等简单使用。sqlite是一个关系型数据库，既然是数据库那么它就一定不会这么简单了，是吧，要不然就没有专门做数据库设计的岗位了。当然了在Android上的应用通常可能没有这么复杂。那么简单的约束还是可以了解下的。毕竟我们可能不会做出超出我们逻辑认知的操作。如果想要实现某个功能，那么知道当前工具是否可以是很有必要的吧。
正文 那么我们就直接上菜，Android 上无论是room 还是greendao，都是基于sqlite提供服务的，他们实现的sqlite 就必定有，是吧。我们知道一个表的设计包括 表名，字段名，字段名对应的类型（必须），字段名对应的其他约束。
类型 之前有一篇文章关于sqlite可用类型与存储类型. 在这里就不再次描述了。
约束 runoob sqlite  本文中大多数都是基于该教程，这个还是可以看一下的。SQLite 约束
  primary key: 唯一标识数据库表中的各行/记录
  autoincrement :自增 通常用于 int类型的字段。
  NOT NULL:确保某列不能有 NULL 值
  DEFAULT :当某列没有指定值时，为该列提供默认值
  UNIQUE 约束：确保某列中的所有值是不同的.
  CHECK 约束：CHECK 约束确保某列中的所有值满足一定条件。
算了，感觉自己写的没有别人提供的约束教程好，这个就当做笔记算了，直接查看 上面的教程吧。心态有点难受。
  结束 谢谢光临，若觉得还行麻烦点一下赞，若觉得写得垃圾，欢迎批评指正。笔者知道自己文笔和表达能力很弱，如果您可以提供点宝贵的意见不胜感激。谢谢。
今天也可以是元气满满的一天哦。</description>
    </item>
    
    <item>
      <title>Android基础数据类型与sqlite存储类型</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96sqlite%E5%8F%AF%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96sqlite%E5%8F%AF%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B/</guid>
      <description>前言 之前又一篇文章上讲到 cursor.getType(cursor.getColumnIndex(key)) 可以获取到对应值的类型，通过cursor 类可以知道，cursor 就提供了4种类型。而ContentValues 定义了不止4总类型，sqlite的插入与更新都可以通过ContentValues 对象进行操作的。目录地址
 cursor 定义了4种类型 ContentValues 定义了不止4总类型 sqlite 插入更新都可以通过 ContentValues 对象进行 问题1：sqlite 在创建表的时候是否支持所以的ContentValues 定义类型。 问题2:sqlite 支持的类型 对应了cursor中的哪些类型。 有一个教程博客写的很清晰runoob SQLite 数据类型  安利一个软件sqlitestudio。/data/data/PACKAGE NAME/ 是sqlite 默认存储路径。
正文 创建sqlite表 ContentValues 支持存放主要类型：String，Byte，Short，Integer，Long，Float，Double，Boolean，byte[]等。那么创建sql，我们知道 string 是通过varchar 存储。不知道直接写string 是否可以创建表。
1 create table if not exists all_content_values ( _id Integer primary key autoincrement , string_key String, byte_key Byte,short_key Short ,long_key Long, float_key Float,double_key Double,Boolean_key Boolean,byte_array byte[] ) if not exists 这个是用于防止表重复创建。</description>
    </item>
    
    <item>
      <title>Android开启Debug</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android%E5%BC%80%E5%90%AFdebug%E4%B9%8B%E8%B7%AF/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android%E5%BC%80%E5%90%AFdebug%E4%B9%8B%E8%B7%AF/</guid>
      <description>前言 电脑不是太好。现在用的也仅仅是mac air 1.8 GHz 双核Intel Core i5 8 GB 1600 MHz DDR3。电脑情况不是太好，需要经常清理缓存啊，运行代码量稍微大一点的项目就感觉慢。打算明年换一个好一点的。所以我本人是比较倾向于插件化和aar的使用的，fragment 使用比重也很高，毕竟只要写好了模板，debug功能还是比activity 简单些。
说回正题。Android debug 模式也不多，常用的一般分为：
 打印log 打断点 测试代码 让测试复现bug 等  顺便推一下博客目录
正文 打印log ​	这种情况，一般是检查参数或者接口的时候，如果电脑不怎么行，打log 电脑也不怎么卡，打断点可能就卡了。
但是呢，string 虽说够长，但是log 的打印是有长度限制的。万一log体长度超出了怎么办？只能代码截取分log 打印了。像这种网络上还是蛮多的。
打断点 本篇我们也就主要是介绍下打断点。可能出现的问题。
先介绍下图标1是run（运行，如果手机上没有安装当前app 这个应该是三角形）.2是debug,3是attach debugger to android process。
  debug 版本运行不到手机上。重新编译项目或者删除主项目下 build文件（不要删除错了），还有重新导入编译项目，一般就可以运行到手机上了。
  idea 左边栏有一个 Build variants 工具（可能在其他位置）可以切马甲包配置或者release，debug等。同一个APP 下版本应该是一致的。切成同一个版本就好了。
  release 版本是无法运行debug的。 如果使用release 版本debug 会提示:
 Error running &#39;sqliteroom&#39; Cannot debug application from module sqliteroom on device huawei-lld_al00-MKJDU17C08001071.</description>
    </item>
    
  </channel>
</rss>
