<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>个人主页</title>
    <link>http://lalalaxiaowifi.gitee.io/pictures/</link>
    <description>Recent content on 个人主页</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2020-2099</copyright>
    <lastBuildDate>Fri, 08 Jan 2021 00:00:00 +0000</lastBuildDate><atom:link href="http://lalalaxiaowifi.gitee.io/pictures/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>java9新特性</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/java9%E6%96%B0%E7%89%B9%E6%80%A7/</link>
      <pubDate>Fri, 08 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/java9%E6%96%B0%E7%89%B9%E6%80%A7/</guid>
      <description>Java 9 新特性  模块系统：模块是一个包的容器，Java 9 最大的变化之一是引入了模块系统（Jigsaw 项目）。 REPL (JShell)：交互式编程环境。 HTTP 2 客户端：HTTP/2标准是HTTP协议的最新版本，新的 HTTPClient API 支持 WebSocket 和 HTTP2 流以及服务器推送特性。 改进的 Javadoc：Javadoc 现在支持在 API 文档中的进行搜索。另外，Javadoc 的输出现在符合兼容 HTML5 标准。 多版本兼容 JAR 包：多版本兼容 JAR 功能能让你创建仅在特定版本的 Java 环境中运行库程序时选择使用的 class 版本。 集合工厂方法：List，Set 和 Map 接口中，新的静态工厂方法可以创建这些集合的不可变实例。 私有接口方法：在接口中使用private私有方法。我们可以使用 private 访问修饰符在接口中编写私有方法。 进程 API: 改进的 API 来控制和管理操作系统进程。引进 java.lang.ProcessHandle 及其嵌套接口 Info 来让开发者逃离时常因为要获取一个本地进程的 PID 而不得不使用本地代码的窘境。 改进的 Stream API：改进的 Stream API 添加了一些便利的方法，使流处理更容易，并使用收集器编写复杂的查询。 改进 try-with-resources：如果你已经有一个资源是 final 或等效于 final 变量,您可以在 try-with-resources 语句中使用该变量，而无需在 try-with-resources 语句中声明一个新变量。 改进的弃用注解 @Deprecated：注解 @Deprecated 可以标记 Java API 状态，可以表示被标记的 API 将会被移除，或者已经破坏。 改进钻石操作符(Diamond Operator) ：匿名类可以使用钻石操作符(Diamond Operator)。 改进 Optional 类：java.</description>
    </item>
    
    <item>
      <title>idea相关配置及其缓存清理</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/idea%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%B6%E7%BC%93%E5%AD%98%E6%B8%85%E7%90%86/</link>
      <pubDate>Wed, 06 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/idea%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%85%B6%E7%BC%93%E5%AD%98%E6%B8%85%E7%90%86/</guid>
      <description>主要针对mac idea.vmoptions 进行设置
 配置 通过idea 会根据电脑 自动设置一个 缓存之类下设置。
默认（灰色标识） JetBrains 提供的默认设置：
1-Xms128m 2-Xmx750m 3-XX:MaxPermSize=350m 4-XX:ReservedCodeCacheSize=240m 5-XX:+UseCompressedOops Big（大）（红色标识） 给 Xmx 配 4096MB， ReservedCodeCacheSize 设置 1024MB，这已经是相当多的内存了：
1-Xms1024m 2-Xmx4096m 3-XX:ReservedCodeCacheSize=1024m 4-XX:+UseCompressedOops Balanced(平衡的)（蓝色标识） Xmx 和 Xms 都分配 2GB ，这是相当平衡的内存消耗：
1-Xms2g 2-Xmx2g 3-XX:ReservedCodeCacheSize=1024m 4-XX:+UseCompressedOops Sophisticated（复杂的）（橘色标识） 和上面一样， Xmx 和 Xms 都分配2GB，但是给 GC 和内存管理指定不同的垃圾回收器和许多不同的标志：
1-server 2-Xms2g-Xmx2g 3-XX:NewRatio=3-Xss16m 4-XX:+UseConcMarkSweepGC 5-XX:+CMSParallelRemarkEnabled 6-XX:ConcGCThreads=4 7-XX:ReservedCodeCacheSize=240m 8-XX:+AlwaysPreTouch 9-XX:+TieredCompilation 10-XX:+UseCompressedOops 11-XX:SoftRefLRUPolicyMSPerMB=50 12-Dsun.io.useCanonCaches=false 13-Djava.net.preferIPv4Stack=true 14-Djsse.enableSNIExtension=false 15-ea idea.vmoptions 比如Android的idea.vmoptions这个文件，一般都会在根目录。如果根目录没有。
 状态栏-&amp;gt;help-&amp;gt;edit custom vm option.</description>
    </item>
    
    <item>
      <title>java8 新特性</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/java8-%E6%96%B0%E7%89%B9%E6%80%A7/</link>
      <pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/java8-%E6%96%B0%E7%89%B9%E6%80%A7/</guid>
      <description>Lambda 表达式 lambda表达式 允许我们将行为传到函数中，之前只能选择匿名内部类，现在可以直接使用lambda表达式。
1 2// 1. 不需要参数,返回值为 5 3() -&amp;gt; 5 4 5// 2. 接收一个参数(数字类型),返回其2倍的值 6x -&amp;gt; 2 * x 7 8// 3. 接受2个参数(数字),并返回他们的差值 9(x, y) -&amp;gt; x – y 10 11// 4. 接收2个int型整数,返回他们的和 12(int x, int y) -&amp;gt; x + y 13 14// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void) 15(String s) -&amp;gt; System.out.print(s) 16// 6 接收一个值，返回一个值 17( x) -&amp;gt; { 18 System.out.print(&amp;#34;QQQQQ&amp;#34;); 19 return x + x*0.05; 20 } 21 22// 对集合继续迭代 23 List&amp;lt;String&amp;gt; languages = Arrays.</description>
    </item>
    
    <item>
      <title>PropertyChangeListener关联属性的简单介绍</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/propertychangelistener%E5%85%B3%E8%81%94%E5%B1%9E%E6%80%A7%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/propertychangelistener%E5%85%B3%E8%81%94%E5%B1%9E%E6%80%A7%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</guid>
      <description>JavaBean的属性与一般Java程序中所指的属性，或者说与所有面向对象的程序设计语言中对象的属性是一个概念，在程序中的具体体现就是类中的变量。在JavaBean的设计中，按照属性的不同作用又细分为四类：单值属性；索引属性；*关联属性*；限制属性。
　本文主要介绍如何使用PropertyChangeSupport类来支持关联属性事件的触发。
1．关联属性 　关联属性，也称之为绑定属性。绑定属性会在属性值发生变化时，通知所有相关的监听器。为了实现一个绑定属性，必须实现两个机制。
　1）　无论何时，只要属性的值发生变化，该bean必须发送一个PropertyChange事件给所有已注册的监听器。该变化可能发生在调用set方法时，或者程序的用户做出某种动作时。
　2）　为了使感兴趣的监听器能够进行注册，bean必须实现以下两个方法：
  1void addPropertyChangeListener(PropertyChangeListener listener);   1void removePropertyChangeListener(PropertyChangeListener listener);   2．使用PropertyChangeSupport 管理 监听器 　可以通过java.bean包下的PropertyChangeSupport类来管理监听器。要使用这个类，bean必须有一个此类的数据域。
  1private PropertyChangeSupport changes = new PropertyChangeSupport(this);   　这样就可以将添加和移除监听器的任务交给这个对象。
  1public void addPropertyChangeListener(PropertyChangeListener listener) {   1　changes.addPropertyChangeListener(listener);   1}   1public void removePropertyChangeListener(PropertyChangeListener listener) {   1　changes.removePropertyChangeListener(listener);   1}    当bean的属性发生变化时，使用PropertyChangeSupport对象的firePropertyChange方法，它会将一个事件发送给所有已经注册的监听器。该方法有三个参数：属性的名字、旧的值以及新的值。属性的值必须是对象，如果是简单数据类型，则必须进行包装。</description>
    </item>
    
    <item>
      <title>Rxjava观察者</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E5%88%9B%E5%BB%BA%E8%A7%82%E5%AF%9F%E8%80%85/</link>
      <pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E5%88%9B%E5%BB%BA%E8%A7%82%E5%AF%9F%E8%80%85/</guid>
      <description>前言 本Demo 主要是针对 Rxjava Android 版本进行实践
Rxjava Android 版本 github 地址 Rxjava 地址 Rxjava 官方文档地址 观察者创建 observer  2.0 import io.reactivex.Observer; 观察者用于接收 被观察者提供的数据信息。暂时不清楚被观察者调用其他观察者的逻辑。
  new Observer&amp;lt;泛型&amp;gt;(){};需要需要实现方法。Android上网络请求通常使用这个就好了。  其他观察者 其他观察者 2.2.20 提供观察者 位于io.reactivex.functions 包下 
 Action BiConsumer BiFunction BiPredicate BooleanSupplier Cancellable Consumer Function Function3 Function4 Function5 Function6 Function7 Function8 Function9 IntFunction LongConsumer Predicate  action 一个类似于Runnable的功能接口，但允许抛出一个已检查的异常。
1 2 </description>
    </item>
    
    <item>
      <title>关于JAVA中使用测试</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/%E5%85%B3%E4%BA%8Ejava%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Mon, 04 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/%E5%85%B3%E4%BA%8Ejava%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81/</guid>
      <description>前言  最近认真工作(摸鱼)的时候，突然想起来之前立的诸多flag，其中就有
 1 testImplementation &amp;#39;junit:junit:4.12&amp;#39; 2 androidTestImplementation &amp;#39;com.android.support.test:runner:1.0.2&amp;#39; 3 androidTestImplementation &amp;#39;com.android.support.test.espresso:espresso-core:3.0.2&amp;#39; 这个调调还是蛮熟悉的，虽然没有怎么用过，每次创建应用的时候都会默认添加，虽然版本不一样。最近看熟悉Rxjava,然后JAVA版本的Demo就是 在test包下。 test包在src 下面。
正文 上面的那个是Android的，但是Rxjava的却不一样。
 JUnit 4 文档地址 junit 4github 地址 Java的面向程序员的测试框架。 mockito github 地址 最受欢迎的用Java编写的用于单元测试的Mocking框架 testng  TestNG是一个受JUnit和NUnit启发的测试框架，但引入了一些使其更强大且更易于使用的新功能 guava   </description>
    </item>
    
    <item>
      <title>Rxjava使用CompositeDisposable进行统一注销监听</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E4%B8%ADcompositedisposable%E8%BF%9B%E8%A1%8C%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86%E6%B3%A8%E9%94%80/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E4%B8%ADcompositedisposable%E8%BF%9B%E8%A1%8C%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86%E6%B3%A8%E9%94%80/</guid>
      <description>前言 本Demo 主要是针对 Rxjava Android 版本进行实践
Rxjava Android 版本 github 地址 Rxjava 地址 Rxjava 官方文档地址 正文  在观察者的回调方法中，有一个onSubscribe(Disposable d) 开始连接方法，Disposable 可以控制是否关闭后面的回调。JAVA 对象是有生命周期的。 这个时候，对于某些监听回调，就可以统一安排处理了。
 1 private final CompositeDisposable mDisposable = new CompositeDisposable(); 2// subscribe 需要使用返回 一个Disposable的那个方法。 3 Disposable md = Observable.create(new ObservableOnSubscribe&amp;lt;Integer&amp;gt;() { 4 @Override 5 public void subscribe(ObservableEmitter&amp;lt;Integer&amp;gt; e) throws Exception { 6 7 } 8 }).subscribe(integer -&amp;gt; Log.e(TAG, &amp;#34;demo2: &amp;#34; + integer)); 9 disposable.add(md); 10 11@Override 12 protected void onStop() { 13 super.</description>
    </item>
    
    <item>
      <title>Rxjava其他运算</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E5%85%B6%E4%BB%96%E8%BF%90%E7%AE%97/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E5%85%B6%E4%BB%96%E8%BF%90%E7%AE%97/</guid>
      <description>前言 本Demo 主要是针对 Rxjava Android 版本进行实践
Rxjava Android 版本 github 地址 Rxjava 地址 Rxjava 官方文档地址 正文 链式调用 Observable  背压运算符 Backpressure Operators 背压运算符-处理可观察对象的策略，可观察对象的产生速度比观察者消耗它们的速度快 可连接的可观察算子 具有更精确控制的订阅动态的专业可观察物  Connect -指示可连接的Observable开始向其订阅者发送项目 Publish —将普通的Observable转换为可连接的Observable RefCount -使Connectable Observable表现得像普通的Observable Replay —确保所有观察者看到相同的发射项目序列，即使他们在Observable开始发射项目之后进行订阅  运营商转换可观察物  To —将O​​bservable转换为另一个对象或数据结构 Rxjava所有方法 可观察算子的字母顺序列表
Rxjava所有方法 可观察算子的字母顺序列表</description>
    </item>
    
    <item>
      <title>Rxjava创建被观察者Observable</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E5%88%9B%E5%BB%BA%E8%A2%AB%E8%A7%82%E5%AF%9F%E8%80%85/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E5%88%9B%E5%BB%BA%E8%A2%AB%E8%A7%82%E5%AF%9F%E8%80%85/</guid>
      <description>前言 本Demo 主要是针对 Rxjava Android 版本进行实践
Rxjava Android 版本 github 地址 Rxjava 地址 Rxjava 官方文档地址 正文 Observable 主要是创建一个新的被观察者Observable
Create —通过编程调用观察者方法从头开始创建Observable Defer —在观察者订阅之前不要创建Observable，并为每个观察者创建一个新的Observable Empty/ Never/Throw -创建具有非常精确和限制行为观测量 From —将其他一些对象或数据结构转换为可观察的 Interval —创建一个Observable，它发出以特定时间间隔隔开的整数序列 Just —将一个对象或一组对象转换为发出该对象或那些对象的Observable Range —创建一个Observable，它发出一系列连续整数 Repeat —创建一个Observable，它反复发出特定的项目或项目序列 Start —创建一个Observable，它发出函数的返回值 Timer —创建一个Observable，它在给定的延迟后发出单个项目 Rxjava所有方法 可观察算子的字母顺序列表</description>
    </item>
    
    <item>
      <title>Rxjava数学运算符和聚合运算符Observable</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%81%9A%E5%90%88%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%81%9A%E5%90%88%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>前言 本Demo 主要是针对 Rxjava Android 版本进行实践
Rxjava Android 版本 github 地址 Rxjava 地址 Rxjava 官方文档地址 正文 Observable 对Observable发出的整个项目序列进行操作的运算符
Average —计算Observable发出的数字的平均值，并发出该平均值 Concat —从两个或多个可观测对象发射的发射，而不会相互干扰 Count —计算源Observable发出的项目数，仅发出此值 Max —确定并发出Observable发出的最大价值的物品 Min —确定并发出Observable发出的最小值项 Reduce —将函数依次应用于Observable发出的每个项目，并发出最终值 Sum —计算一个Observable发出的数字的总和，并发出该总和 Rxjava所有方法 可观察算子的字母顺序列表</description>
    </item>
    
    <item>
      <title>Rxjava最简单的使用</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava-%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>前言 本Demo 主要是针对 Rxjava Android 版本进行实践
Rxjava Android 版本 github 地址 Rxjava 地址 Rxjava 官方文档地址 正文 链式调用 Observable 1 Observable.create(new ObservableOnSubscribe&amp;lt;Integer&amp;gt;() { 2 @Override 3 public void subscribe(ObservableEmitter&amp;lt;Integer&amp;gt; e) throws Exception { 4 e.onNext(5); 5 e.onComplete(); 6 } 7 }).observeOn(Schedulers.newThread()).subscribeOn(AndroidSchedulers.mainThread()) 8 .subscribe(new Observer&amp;lt;Integer&amp;gt;() { 9 @Override 10 public void onSubscribe(Disposable d) { 11 12 } 13 14 @Override 15 public void onNext(Integer value) { 16 17 } 18 19 @Override 20 public void onError(Throwable e) { 21 22 } 23 24 @Override 25 public void onComplete() { 26 27 } 28 }); Lambda 表达式版本 1 Observable.</description>
    </item>
    
    <item>
      <title>Rxjava条件运算符和布尔运算符Observable</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>前言 本Demo 主要是针对 Rxjava Android 版本进行实践
Rxjava Android 版本 github 地址 Rxjava 地址 Rxjava 官方文档地址 正文 Observable 条件运算符和布尔运算符 评估一个或多个可观察对象或可观察对象发出的项目的运算符
All —确定可观察对象发出的所有项目是否都满足某些条件  这个判断所有项目都是否满足某些条件，所以这个有两个注意点，一个是所以项目，一个是否。
 1 Observable.create(new ObservableOnSubscribe&amp;lt;Integer&amp;gt;() { 2 @Override 3 public void subscribe(@NonNull ObservableEmitter&amp;lt;Integer&amp;gt; emitter) throws Throwable { 4 emitter.onNext(1); 5 emitter.onNext(2); 6 emitter.onNext(3); 7 emitter.onNext(4); 8 emitter.onNext(5); 9 emitter.onNext(6); 10 emitter.onComplete(); 11 } 12 }).all(new Predicate&amp;lt;Integer&amp;gt;() { 13 @Override 14 public boolean test(Integer integer) throws Throwable { 15 Log.</description>
    </item>
    
    <item>
      <title>Rxjava组合结合被观察者Observable</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E7%BB%93%E5%90%88%E7%BB%84%E5%90%88%E8%A2%AB%E8%A7%82%E5%AF%9F%E8%80%85/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E7%BB%93%E5%90%88%E7%BB%84%E5%90%88%E8%A2%AB%E8%A7%82%E5%AF%9F%E8%80%85/</guid>
      <description>前言 本Demo 主要是针对 Rxjava Android 版本进行实践
Rxjava Android 版本 github 地址 Rxjava 地址 Rxjava 官方文档地址 正文 Observable And/ Then/When -联合组由两个或更多发射观测量项借助于Pattern与Plan中介 CombineLatest —当两个Observable之一发射一个项目时，通过指定的函数合并每个Observable发射的最新项目，并根据此函数的结果发射项目 Join —在根据另一个可观察对象发出的项目定义的时间窗口中，只要发射了一个可观察对象的项目，则合并两个可观察对象发出的项目 Merge -通过合并排放量将多个可观测值合并为一个 StartWith —在开始从源中发出项目之前，发出指定的项目序列 Switch —将发出Observable的Observable转换为发出可观察到的最新事物的单个Observable Zip —通过指定的函数将多个可观测对象的发射合并在一起，并根据此函数的结果为每个组合发射单个项目 Rxjava所有方法 可观察算子的字母顺序列表</description>
    </item>
    
    <item>
      <title>Rxjava转换被观察者Observable</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E8%BD%AC%E6%8D%A2%E8%A2%AB%E8%A7%82%E5%AF%9F%E8%80%85/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E8%BD%AC%E6%8D%A2%E8%A2%AB%E8%A7%82%E5%AF%9F%E8%80%85/</guid>
      <description>前言 本Demo 主要是针对 Rxjava Android 版本进行实践
Rxjava Android 版本 github 地址 Rxjava 地址 Rxjava 官方文档地址 正文 Observable 主要是转换被观察者Observable
Buffer —定期将来自一个Observable的项目收集成束，然后发出这些束，而不是一次发出一个 FlatMap —将可观察对象发出的项目转换为可观察项目，然后将这些项目的排放平展为单个可观察项目 GroupBy —将一个Observable划分为一组Observable，它们分别与原始Observable发射一组不同的项，并按key进行组织 Map —通过对每个项目应用函数来转换Observable发出的项目 Scan —将函数依次应用于Observable发出的每个项目，并发出每个连续的值 Window —定期将项目从“可观察”窗口细分为“可观察”窗口，然后发出这些窗口，而不是一次发出一个窗口 Rxjava所有方法 可观察算子的字母顺序列表</description>
    </item>
    
    <item>
      <title>Rxjava过滤被观察者Observable</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E8%BF%87%E6%BB%A4%E8%A2%AB%E8%A7%82%E5%AF%9F%E8%80%85/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E8%BF%87%E6%BB%A4%E8%A2%AB%E8%A7%82%E5%AF%9F%E8%80%85/</guid>
      <description>前言 本Demo 主要是针对 Rxjava Android 版本进行实践
Rxjava Android 版本 github 地址 Rxjava 地址 Rxjava 官方文档地址 正文 Observable 主要是过滤被观察者Observable
Debounce —仅在经过特定时间跨度时才从Observable发出一项，而不发出另一项 Distinct -抑制可观察对象发出的重复项 ElementAt—仅发射可观察对象发射的项目n Filter —仅从可观察对象中发出通过谓词测试的项 First —仅从Observable发射第一项或满足条件的第一项 IgnoreElements —不要从Observable发出任何项目，而是镜像其终止通知 Last —只发射可观察对象发射的最后一个项目 Sample —定期发射Observable发射的最新项目 Skip—抑制Observable发出的前n个项目 SkipLast—抑制Observable发出的最后n个项目 Take—仅发射可观察对象发射的前n个项目 TakeLast—只发射可观察对象发射的最后n个项目 Rxjava所有方法 可观察算子的字母顺序列表</description>
    </item>
    
    <item>
      <title>Rxjava错误处理被观察者Observable</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E8%A2%AB%E8%A7%82%E5%AF%9F%E8%80%85/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E8%A2%AB%E8%A7%82%E5%AF%9F%E8%80%85/</guid>
      <description>前言 本Demo 主要是针对 Rxjava Android 版本进行实践
Rxjava Android 版本 github 地址 Rxjava 地址 Rxjava 官方文档地址 正文 Observable 有助于从Observable的错误通知中恢复的运算符
Catch-onError通过继续执行顺序而没有错误地从通知中恢复 Retry—如果源Observable发送了onError通知，请重新订阅该通知，以希望它可以完成而不会出错 Rxjava所有方法 可观察算子的字母顺序列表</description>
    </item>
    
    <item>
      <title>Rxjava错误处理被观察者Observable</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/%E5%8F%AF%E8%A7%82%E5%AF%9F%E7%9A%84%E5%85%AC%E7%94%A8%E4%BA%8B%E4%B8%9A%E8%BF%90%E8%90%A5%E5%95%86/</link>
      <pubDate>Thu, 31 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/%E5%8F%AF%E8%A7%82%E5%AF%9F%E7%9A%84%E5%85%AC%E7%94%A8%E4%BA%8B%E4%B8%9A%E8%BF%90%E8%90%A5%E5%95%86/</guid>
      <description>前言 本Demo 主要是针对 Rxjava Android 版本进行实践
Rxjava Android 版本 github 地址 Rxjava 地址 Rxjava 官方文档地址 正文 Observable 一个有用的运算符的工具箱，用于处理Observables
Delay —将排放量从可观察的时间向前移特定量 Do -注册一项行动以应对各种可观察到的生命周期事件 Materialize/Dematerialize —表示发出的项目和作为发出的项目发送的通知，或者逆转此过程 ObserveOn -指定观察者将在其上观察此Observable的调度程序 Serialize -强制Observable进行序列化调用并保持良好行为 Subscribe -根据观测对象的排放和通知进行操作 SubscribeOn —指定Observable订阅时应使用的调度程序 TimeInterval —将发射项目的Observable转换为发射项目，以指示两次发射之间经过的时间 Timeout —镜像源Observable，但如果经过特定时间但没有任何发射项，则发出错误通知 Timestamp —将时间戳记附加到Observable发出的每个项目 Using -创建与可观察对象具有相同使用寿命的可使用资源 Rxjava所有方法 可观察算子的字母顺序列表</description>
    </item>
    
    <item>
      <title>Android中关于Rxjava Flowable相关笔记整理</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E5%85%B3%E4%BA%8Eflowable/</link>
      <pubDate>Wed, 30 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E5%85%B3%E4%BA%8Eflowable/</guid>
      <description>前言 本Demo 主要是针对 Rxjava Android 版本进行实践
Rxjava Android 版本 github 地址 Rxjava 地址 Rxjava 官方文档地址 Rxjava javaDoc地址
正文  如果上游发射的很快而下游处理的很慢，会怎样呢？ 将会产生很多下游没来得及处理的数据，这些数据既不会丢失，也不会被垃圾回收机制回收，而是存放在一个异步缓存池中，如果缓存池中的数据一直得不到处理，越积越多，最后就会造成内存溢出，这便是Rxjava中的背压问题。 Flowable类实现了反应式流模式，并提供了工厂方法，中间运算符以及使用反应式数据流的能力.
 1Flowable.create(new FlowableOnSubscribe&amp;lt;Integer&amp;gt;() { 2 @Override 3 public void subscribe(FlowableEmitter&amp;lt;Integer&amp;gt; emitter) throws Exception { 4 emitter.onNext(1); 5 emitter.onNext(2); 6 emitter.onNext(3); 7 emitter.onNext(4); 8 emitter.onComplete(); 9 } 10 }, BackpressureStrategy.BUFFER).subscribe(new Subscriber&amp;lt;Integer&amp;gt;() { 11 @Override 12 public void onSubscribe(Subscription s) { 13 s.request(Long.MAX_VALUE); 14 System.out.print(&amp;#34;onSubscribe&amp;#34; + s); 15 } 16 17 @Override 18 public void onNext(Integer integer) { 19 System.</description>
    </item>
    
    <item>
      <title>Android中关于Rxjava Flowable相关笔记整理(转载)</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E4%B8%ADflowable%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0%E8%BD%AC%E8%BD%BD/</link>
      <pubDate>Wed, 30 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E4%B8%ADflowable%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0%E8%BD%AC%E8%BD%BD/</guid>
      <description>前言 本Demo 主要是针对 Rxjava Android 版本进行实践
Rxjava Android 版本 github 地址 Rxjava 地址 Rxjava 官方文档地址 Rxjava javaDoc地址
正文 数据流发射，处理，响应可能在各自的线程中独立进行，上游在发射数据的时候，不知道下游是否处理完，也不会等下游处理完之后再发射。
这样，如果上游发射的很快而下游处理的很慢，会怎样呢？
将会产生很多下游没来得及处理的数据，这些数据既不会丢失，也不会被垃圾回收机制回收，而是存放在一个异步缓存池中，如果缓存池中的数据一直得不到处理，越积越多，最后就会造成内存溢出，这便是Rxjava中的背压问题。
例如，运行以下代码：
demo1.jpg
创建一个可观察对象Obervable在Schedulers.newThread()()的线程中不断发送数据，而观察者Observer在Schedulers.newThread()的另一个线程中每隔5秒接收一条数据，运行后，查看内存使用如下：
backpressure.gif
由于上下游分别在各自的线程中独立处理数据（如果上下游在同一线程中，下游对数据的处理会堵塞上游数据的发送，上游发送一条数据后会等下游处理完之后再发送下一条），而上游发送数据速度远大于下游接收数据的速度，造成上下游流速不均，导致数据累计，最后引起内存溢出。
Flowable
Flowable是为了解决背压（backpressure）问题，而在Observable的基础上优化后的产物，与Observable不是同一组观察者模式下的成员，Flowable是Publisher与Subscriber这一组观察者模式中Publisher的典型实现，Observable是ObservableSource/Observer这一组观察者模式中ObservableSource的典型实现；
所以在使用Flowable的时候，可观察对象不再是Observable,而是Flowable;观察者不再是Observer，而是Subscriber。Flowable与Subscriber之间依然通过subscribe()进行关联。
有些朋友可能会想，既然Flowable是在Observable的基础上优化后的产物，Observable能解决的问题Flowable都能进行解决，何不抛弃Observable而只用Flowable呢。其实，这是万万不可的，他们各有自己的优势和不足。
由于基于Flowable发射的数据流，以及对数据加工处理的各操作符都添加了背压支持，附加了额外的逻辑，其运行效率要比Observable低得多。
因为只有上下游运行在各自的线程中，且上游发射数据速度大于下游接收处理数据的速度时，才会产生背压问题。
所以，如果能够确定上下游在同一个线程中工作，或者上下游工作在不同的线程中，而下游处理数据的速度高于上游发射数据的速度，则不会产生背压问题，就没有必要使用Flowable，以免影响性能。
通过Flowable发射处理数据流的基础代码如下：
demo2.jpg
执行结果如下：
System.out: 发射----&amp;gt; 1System.out: 发射----&amp;gt; 2System.out: 发射----&amp;gt; 3System.out: 发射----&amp;gt; 完成System.out: 接收----&amp;gt; 1System.out: 接收----&amp;gt; 2System.out: 接收----&amp;gt; 3System.out: 接收----&amp;gt; 完成
我们发现运行结果与Observerable没有区别，但是的代码中，除了为上下游指定各自的运行线程外，还有三点不同
一、create方法中多了一个BackpressureStrategy类型的参数。
二、onSubscribe回调的参数不是Disposable而是Subscription，多了行代码：
s.request(Long.MAX_VALUE);
三、Flowable发射数据时，使用的发射器是FlowableEmitter而不是ObservableEmitter
BackpressureStrategy背压策略
在Flowable的基础创建方法create中多了一个BackpressureStrategy类型的参数，
BackpressureStrategy是个枚举，源码如下：
publicenumBackpressureStrategy { ERROR,BUFFER,DROP,LATEST,MISSING}
其作用是什么呢？
Flowable的异步缓存池不同于Observable，Observable的异步缓存池没有大小限制，可以无限制向里添加数据，直至OOM,而Flowable的异步缓存池有个固定容量，其大小为128。
BackpressureStrategy的作用便是用来设置Flowable通过异步缓存池存储数据的策略。
ERROR
在此策略下，如果放入Flowable的异步缓存池中的数据超限了，则会抛出MissingBackpressureException异常。
运行如下代码：</description>
    </item>
    
    <item>
      <title>Android中关于Rxjava相关笔记整理</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/android%E4%B8%ADrxjava%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/</link>
      <pubDate>Wed, 30 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/android%E4%B8%ADrxjava%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/</guid>
      <description>前言 本Demo 主要是针对 Rxjava Android 版本进行实践
Rxjava Android 版本 github 地址 Rxjava 地址 Rxjava 官方文档地址 Rxjava javaDoc地址
正文 被观察者 创建可观察物 产生新的Observable的运算符。
 Create —通过编程调用观察者方法从头开始创建Observable Defer -在观察者订阅之前不要创建Observable，并为每个观察者创建一个新的Observable Empty/ Never/Throw -创建具有非常精确和限制行为观测量 From —将其他一些对象或数据结构转换为可观察的 Interval —创建一个Observable，它发出以特定时间间隔隔开的整数序列 Just —将一个对象或一组对象转换为发出该对象或那些对象的Observable Range —创建一个Observable，它发出一系列连续整数 Repeat —创建一个Observable，它反复发出特定的项目或项目序列 Start —创建一个Observable，它发出函数的返回值 Timer —创建一个Observable，它在给定的延迟后发出单个项目  转换可观察物 转换由Observable发出的项目的运算符。
 Buffer —定期将来自一个Observable的项目收集成束，然后发出这些束，而不是一次发出一个 FlatMap —将可观察对象发出的项目转换为可观察项目，然后将这些项目的排放平展为单个可观察项目 GroupBy —将一个Observable划分为一组Observable，它们分别与原始Observable发射一组不同的项，并按key进行组织 Map —通过对每个项目应用函数来转换Observable发出的项目 Scan —将一个函数依次应用于Observable发出的每个项目，并发出每个连续的值 Window —定期将项目从“可观察”窗口细分为“可观察”窗口，然后发出这些窗口，而不是一次发出一个窗口  过滤可观察物 有选择地从Observable源发出项目的运算符。
 Debounce —仅在经过特定时间跨度时才从Observable中发出一项，而不发出另一项 Distinct -抑制可观察对象发出的重复项 ElementAt —仅发射可观察对象发射的项目n Filter —仅从可观察对象中发出通过谓词测试的项 First —仅从Observable发出第一项或满足条件的第一项 IgnoreElements —不要从Observable发出任何项目，而是镜像其终止通知 Last —只发射可观察对象发射的最后一个项目 Sample —定期发射Observable发射的最新项目 Skip —抑制Observable发出的前n个项目 SkipLast —抑制Observable发出的最后n个项目 Take —仅发射可观察对象发射的前n个项目 TakeLast —只发射可观察对象发射的最后n个项目  结合可观察物 与多个源Observables一起创建单个Observable的运算符</description>
    </item>
    
    <item>
      <title>sql分组查询</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/sql%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Tue, 29 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/sql%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2/</guid>
      <description>当前笔记复制来源于：https://www.cnblogs.com/friday69/p/9389720.html
 1.SQL分组查询GroupBy+Group_concat group by 是分组，是分组，是分组，分组并不是去重，而是分组
将查询结果按一个或多个进行分组，字段值相同的为一组
GroupBy+Group_concat ： 表示分组之后，根据分组结果，使用 group_contact() 来放置每一组的每字段的值的集合
1select deparmant, GROUP_CONCAT(`name`) from employee GROUP BY deparmant 根据 department 分组，通过 group_concat（&#39;name&#39;）,查看每组里面的姓名都有哪些
1SELECT gender,GROUP_CONCAT(`name`) from employee GROUP BY gender 根据gender 分类，看 不同的 性别都有哪些 人
分组注意事项： 在分组时，select后面跟的的字段一般都会出现在 group by 后
1SELECT name,gender from employee GROUP BY gender,name 2-- 先按gender分组，再按姓名分组...  2.SQL分组+聚合函数 1select deparmant, GROUP_CONCAT(salary), SUM(salary),AVG(salary) 平均工资,MAX(salary) 最高工资 from employee GROUP BY deparmant; 2-- 根据department 分组，计算各部门下工资总数，平均工资，最高工资![1532919789347](D:\Python\python_learning\Python_Blog\02\SQL\4.png) 1-- 查询每个部门的部门名称以及每个部门的人数 2SELECT deparmant, GROUP_CONCAT(`name`), COUNT(*) from employee GROUP BY deparmant 1-- 查询每个部门的部门名称以及每个部门工资大于1500的人数 2SELECT deparmant,GROUP_CONCAT(salary), COUNT(*) from employee WHERE salary &amp;gt; 1500 GROUP BY deparmant 3.</description>
    </item>
    
    <item>
      <title>fragment生命周期导致数据初始化问题</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/fragment%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
      <pubDate>Mon, 28 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/fragment%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
      <description>前言 话说，activity 和fragment 都是有生命周期的，而且加载也并不是new完对象就加载出来了的，new 一个activity并不多见，但是基于activity new 一个fragment还是很常见的，但是很少有需要在activity中调用fragment方法的时候，但是存在可能性。 因为fragment加载的特性，所以像loading层保证唯一，这样子的就不能直接判断fragmentmanger 中是否包含了，需要一个其他值去判断。而且传参方面，也是这个样子。 比如说我的createPresenter() 方法是当fragment 走oncreate() 的时候创建调用的，但是我上一行代码创建完fragment就直接调用presenter 就会抛空指针异常。
解决思路 思路1 绑定生命周期 我们知道 fragment.getLifecycle().addObserver(observer) 这个可以添加生命周期监听，那么我们对fragment 添加了监听，等走到对应的生命周期的方法才执行对应的代码就好。这样也就避免了，activity 不知道fragment什么时候加载完成导致调用问题了。 但是这种情况下，如果我fragment中再嵌套一个fragment呢？内部的fragment 生命周期万一也关联到外部的activity调用呢？用多个observer去调出来，就是有点怪怪的。那么只能从代码设计上更改了。
思路2 更改设计模式 修改绑定生命周期部分 这个思路肯定是不行的，绑定生命周期就是为了优化内存使用的，而且绑定生命周期也对view的加载显示控制提供了生命范围，防止错误的时间，错误的地点导致操作崩溃。
那就修改功能对应的界面的设计  先说功能吧，对某个数据表进行 折线图，饼图，柱状图等图表的显示，这些图表支持 日周月年的时间切换。先进入某个功能点，确定数据来源，然后选择图表类型，进入下一个界面，最后是选择时间切换。默认加载天的数据。 我就一想，既然每个图表需求显示的view是固定的，那么activity只需要加载一个fragment，由fragment 内部加载不同的图表fragment，图表fragment 只需要显示fragment传入的数据就行。fragment进行数据获取和数据转换，activity进行时间更改转化，然后传入进去。 那么问题就来了，因为activity控制时间，所以第一次的时间需要由activity传入到fragment中，然而，activity并不知道fragment是否加载完成，所以activity需要知道fragment的生命周期，fragment拿到数据知道，也不知道图表fragment是否加载完成，所以也需要拿到生命周期，如果不做延时处理，那么activity就需要拿到两层fragment的生命周期，再传入值。 但是做线程延时，判断生命周期调用，也需要先将 我传入的值存储到两个fragment里面，等到需要的生命周期再显示，这个和我直接通过对象方法传参没有任何区别吧。所以还是生命周期传参导致的问题。 那么就优化设计逻辑，activity 只持有一层图表fragment，图表fragment进行数据拉取和处理显示就好，只是图表层的presenter 需要将所有的功能点的数据全部拉取一遍罢了。当然进行时间切换的时候，也需要判断当前fragment是否加载出来。
 总结 感觉，mvp和mvvm 其实也是一种代码规范，感觉通过activity 向fragment对象方法传参就有点违背了这种规范的初衷吧。所以像eventbus 这种传参，就很实用,完全不需要考虑生命周期，当然Android 提供的广播也是可以的。 EventBus GitHub
activity中注册后，在fragment中就不用再注册监听了，提供方法就直接会调用。因为fragment属于延时加载，所以尽量使用postSticky 。接收：
1 @Subscribe(threadMode = ThreadMode.MAIN, sticky = true) 2 public void onChangeData(ChartDetailsMessage message){ 3 getPresenter().getDatas(message); 4 } </description>
    </item>
    
    <item>
      <title>SQL知识点汇总</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/sql%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</link>
      <pubDate>Mon, 28 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/sql%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</guid>
      <description>前言  最近写Demo的时候，经常发现自己对于sql好多都忘记了。
 简单使用  SELECT 查询 后面接查询字段 SELECT DISTINCT 查询 去重 WHERE 多条件查询，用and 连接 and or 多条件查询拼接 order by 对结果进行排序，默认是升序，ORDER BY DESC 降序，ORDER BY 多列（这个多列不是太懂） INSERT INTO 插入数据 UPDATE 更新数据 DELETE 删除数据  进阶  SELECT TOP, LIMIT, ROWNUM 用于规定返回记录的条目数 LIKE like查询 通配符  % 替代0个或者多个字符 &#39;-&#39; 替代一个字符 [charlist] 字符列中的任何单一字符 [^charlist] 或 [!charlist] 不在字符列中的任何单一字符   in 查询，有点类型 数组中的那个 indexof ,可传入同一个字段的多个值 BETWEEN 用于取两个值之间的范围值 两个值用 and 连接 NOT BETWEEN 不在范围内 别名 AS 比如说 name as n ,就是将name设置为 n, JOIN 将两个或者多个表结合起来，基于共同字段。 INNER JOIN 查询条件满足的行 LEFT JOIN 从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。 RIGHT JOIN 关键字从右表（table2）返回所有的行，即使左表（table1）中没有匹配。如果左表中没有匹配，则结果为 NULL。 FULL OUTER JOIN 关键字只要左表（table1）和右表（table2）其中一个表中存在匹配，则返回行.</description>
    </item>
    
    <item>
      <title>java通用doc文档(类参考手册)生成</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/java%E9%80%9A%E7%94%A8doc%E6%96%87%E6%A1%A3%E7%94%9F%E6%88%90%E5%99%A8/</link>
      <pubDate>Thu, 24 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/java%E9%80%9A%E7%94%A8doc%E6%96%87%E6%A1%A3%E7%94%9F%E6%88%90%E5%99%A8/</guid>
      <description>最近有点懵逼，考试整完了，然后又没有事情做，之前的学习计划拉下了一大片，不知道从何下手，然后医生要我减肥先减20斤，又开始锻炼了。 最近写的账本和之前写的代码，封装太严重了，隔一段时间去看，即使是注释写得还行，但是还是需要再简单整理下才行，于是动了java 代码生成 doc 或者chm 的想法。 其实感觉还是自己注释没有写好，但是呢，搞一个文档什么的，方便自己看，也方便提供给 他人，还是蛮好的。
 chm 这个主要是之前学习的时候，老师会给一个这个文件，然后自己看api也是蛮好的，之前都一直觉得，只要我看代码注释就行，之前都是独立开发或者打下手，独立开发自己懂就行，然后打下手的时候，封装和工具类一般都不是我写，我只需要看git更新，然后去看代码就大概知道加了什么新的东西，而且我有习惯，相关的会写到一个文件里面。 近来，上一个Android走了，来了一个新的大佬，虽然我依旧是打下手的，可能交付和注释没有太清晰。 昨天就开始有这个文档生成的想法了，去掘金沸点也问过，github,baidu 问java doc 大多数都是接口相关的。今天突然想起 我需要的可能是 &amp;quot; 类参考手册&amp;quot;,而不是通俗的java doc ，也不是大佬说的 swagger。 所以，给我提供帮助的是后台大佬，这是小老弟的荣幸。 虽然知道自己需要的可能是chm,但是找不到下手点，网络上的教程还是不是太多，大多数都是java doc的。于是打算从编辑器本身上找，讲道理，我看过太多类参考手册，几乎一模一样，我就不信他不是自动生成的，都2020年了，抓注释这个我理解起来都不难。 由于我用的是idea和Android studio,所以就直接找idea里面的了，
第一个导出为html的位置 个人感觉，这个不适合我。file-&amp;gt;export 通过上面的选项选择，就可以将代码到处为html 文件了，选项很好理解就不介绍了。下面是我导出的文件。 在本地目录:
打开index:
打开JAVA文件:
这个感觉和网络上有些静态资源很像。明显不是我想要的。
第2 种导出方法 tools-&amp;gt;generate java doc 本地目录
index 展示效果 看效果就是我想要的类参考手册的样子，完美，我很喜欢。
注释导致的问题 比如说我这方法。 生成的文档方法详情
可以明显的看出来，注释什么的都还是导出来了的，传入字段的介绍也有，因为我返回值 没有进行介绍，所以就没有返回值介绍。所以如果需要导出的内容完整，方法介绍还是应该写完整的。
运行 这个调调就简单了，我们知道gitee page 支持静态网页,而且这个调调本身就是静态网页，本地运行还是放平台就看自己的想法了
结尾 当然了，你说鸡肋吧，还是没有啥用，但是有的时候还是有点用的，起码只看方法名，传参，返回值，不需要受太长的业务逻辑影响。虽说可能就我不知道这个，但是还是记一下吧。 不说了，我去把注释整完整。
注释头 防止有人想要这个注释头。所以直接提供一个。 1/** 2*························.::::. 3*······················.::::::::. 4*·····················::::::::::: 5*··················..:::::::::::&amp;#39; 6*···············&amp;#39;::::::::::::&amp;#39; 7*·················.:::::::::: 8*············&amp;#39;::::::::::::::.. 9*·················..::::::::::::. 10*···············``:::::::::::::::: 11*················::::``:::::::::&amp;#39;········.:::. 12*···············::::&amp;#39;···&amp;#39;:::::&amp;#39;·······.</description>
    </item>
    
    <item>
      <title>androidSqlite查询思路整理</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/sqlite%E6%9F%A5%E8%AF%A2%E7%8C%9C%E6%83%B3/</link>
      <pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/sqlite%E6%9F%A5%E8%AF%A2%E7%8C%9C%E6%83%B3/</guid>
      <description>前言 今天有一个大佬的公众号推了一篇，sql查询慢的原因。 为什么大家都说SELECT * 效率低 上面是原文。 由于收集癖的原因，同时怕以后找不到了，就复制下觉得重要的部分到自己的笔记里面。
复制内容 一、效率低的原因 先看一下最新《阿里java开发手册（泰山版）》中 MySQL 部分描述：
4 - 1. 【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。 说明：
增加查询分析器解析成本。
增减字段容易与 resultMap 配置不一致。
无用字段增加网络 消耗，尤其是 text 类型的字段。 开发手册中比较概括的提到了几点原因，让我们深入一些看看：
1. 不需要的列会增加数据传输时间和网络开销 用“SELECT * ”数据库需要解析更多的对象、字段、权限、属性等相关内容，在 SQL 语句复杂，硬解析较多的情况下，会对数据库造成沉重的负担。
增大网络开销；* 有时会误带上如log、IconMD5之类的无用且大文本字段，数据传输size会几何增涨。如果DB和应用程序不在同一台机器，这种开销非常明显
即使 mysql 服务器和客户端是在同一台机器上，使用的协议还是 tcp，通信也是需要额外的时间。
2. 对于无用的大字段，如 varchar、blob、text，会增加 io 操作 准确来说，长度超过 728 字节的时候，会先把超出的数据序列化到另外一个地方，因此读取这条记录会增加一次 io 操作。（MySQL InnoDB）
3. 失去MySQL优化器“覆盖索引”策略优化的可能性 SELECT * 杜绝了覆盖索引的可能性，而基于MySQL优化器的“覆盖索引”策略又是速度极快，效率极高，业界极为推荐的查询优化方式。
例如，有一个表为t(a,b,c,d,e,f)，其中，a为主键，b列有索引。
那么，在磁盘上有两棵 B+ 树，即聚集索引和辅助索引（包括单列索引、联合索引），分别保存(a,b,c,d,e,f)和(a,b)，如果查询条件中where条件可以通过b列的索引过滤掉一部分记录，查询就会先走辅助索引，如果用户只需要a列和b列的数据，直接通过辅助索引就可以知道用户查询的数据。
如果用户使用select *，获取了不需要的数据，则首先通过辅助索引过滤数据，然后再通过聚集索引获取所有的列，这就多了一次b+树查询，速度必然会慢很多。
由于辅助索引的数据比聚集索引少很多，很多情况下，通过辅助索引进行覆盖索引（通过索引就能获取用户需要的所有列），都不需要读磁盘，直接从内存取，而聚集索引很可能数据在磁盘（外存）中（取决于buffer pool的大小和命中率），这种情况下，一个是内存读，一个是磁盘读，速度差异就很显著了，几乎是数量级的差异。
二、索引知识延申 上面提到了辅助索引，在MySQL中辅助索引包括单列索引、联合索引（多列联合），单列索引就不再赘述了，这里提一下联合索引的作用
联合索引 (a,b,c)
联合索引 (a,b,c) 实际建立了 (a)、(a,b)、(a,b,c) 三个索引</description>
    </item>
    
    <item>
      <title>Git 忽略提交 .gitignore</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/git%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6/</link>
      <pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/git%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6/</guid>
      <description>在使用Git的过程中，我们喜欢有的文件比如日志，临时文件，编译的中间文件等不要提交到代码仓库，这时就要设置相应的忽略规则，来忽略这些文件的提交。
规则 作用 /mtk 过滤整个文件夹 *.zip 过滤所有.zip文件 /mtk/do.c 过滤某个具体文件 !/mtk/one.txt 追踪（不过滤）某个具体文件 注意：如果你创建.gitignore文件之前就push了某一文件，那么即使你在.gitignore文件中写入过滤该文件的规则，该规则也不会起作用，git仍然会对该文件进行版本管理。
配置语法  以斜杠“/”开头表示目录； 以星号“*”通配多个字符； 以问号“?”通配单个字符 以方括号“[]”包含单个字符的匹配列表； 以叹号“!”表示不忽略(跟踪)匹配到的文件或目录。 注意： git 对于 .gitignore配置文件是按行从上到下进行规则匹配的  Git 忽略文件提交的方法 有三种方法可以实现忽略Git中不想提交的文件。
在Git项目中定义 .gitignore 文件 这种方式通过在项目的某个文件夹下定义 .gitignore 文件，在该文件中定义相应的忽略规则，来管理当前文件夹下的文件的Git提交行为。
.gitignore 文件是可以提交到共有仓库中，这就为该项目下的所有开发者都共享一套定义好的忽略规则。
在 .gitingore 文件中，遵循相应的语法，在每一行指定一个忽略规则。如：
*.log *.temp /vendor
在Git项目的设置中指定排除文件 这种方式只是临时指定该项目的行为，需要编辑当前项目下的 .git/info/exclude 文件，然后将需要忽略提交的文件写入其中。
需要注意的是，这种方式指定的忽略文件的根目录是项目根目录。
定义Git全局的 .gitignore 文件 除了可以在项目中定义 .gitignore 文件外，还可以设置全局的 git .gitignore 文件来管理所有Git项目的行为。这种方式在不同的项目开发者之间是不共享的，是属于项目之上Git应用级别的行为。
这种方式也需要创建相应的 .gitignore 文件，可以放在任意位置。然后在使用以下命令配置Git：
git config --global core.excludesfile ~/.gitignore
Git 忽略规则 详细的忽略规则可以参考官方英文文档 https://git-scm.com/docs/gitignore
Git 忽略规则优先级 在 .</description>
    </item>
    
    <item>
      <title>Android sqlite多余字段插入导致插入失败</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1sqlite%E6%8F%92%E5%85%A5%E5%A4%9A%E4%BA%8E%E5%AD%97%E6%AE%B5%E5%AF%BC%E8%87%B4%E7%9A%84%E6%8F%92%E5%85%A5%E5%A4%B1%E8%B4%A5/</link>
      <pubDate>Tue, 22 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1sqlite%E6%8F%92%E5%85%A5%E5%A4%9A%E4%BA%8E%E5%AD%97%E6%AE%B5%E5%AF%BC%E8%87%B4%E7%9A%84%E6%8F%92%E5%85%A5%E5%A4%B1%E8%B4%A5/</guid>
      <description>前言 顺着之前的sqlite写的统一插入语句。然后现在是需要多插入一个信息到一个表，由于来源挺多的，所以直接写到bean 中 顺便推一下博客主页
正文 直接上错误。 SQLiteDatabase: Error inserting table expenses has no column named showMessage (Sqlite code 1 SQLITE_ERROR): , while compiling: INSERT INTO expenses(money_china,pay_income_type,expenses_source_v,money,expenses_source,showMessage,name,remark,title,ledger_id,add_time,pay_income_type_v) VALUES (?,?,?,?,?,?,?,?,?,?,?,?), (OS error - 11:Try again) 直接说解决方案。
 直接修改插入的数据，将表中没有的字段移出。 插入的时候直接判断 表字段和插入数据的字段，表中没有的字段就不插入。  通过这个bug.可以很明确感觉到，数据库操作工具，比如说greendao 之类的，通过注解标记是否是表字段就很有用。
结束 谢谢光临，若觉得还行麻烦点一下赞，若觉得写得垃圾，欢迎批评指正。笔者知道自己文笔和表达能力很弱，如果您可以提供点宝贵的意见不胜感激。谢谢。
今天也可以是元气满满的一天哦。 更新需要审核。更新通常优先更新到gitee上面。
博客主页</description>
    </item>
    
    <item>
      <title>摸鱼Android Fragmentmanger</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android-fragmentmanger/</link>
      <pubDate>Tue, 20 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android-fragmentmanger/</guid>
      <description>前言 话说，搬砖多年，我们的好朋友fragment已经需要适配到AndroidX了，毕竟我之前老是喜欢用V4包下的fragment。但是这个笔记却不是关于更新到Android X的,毕竟如果要整Android X，要改的地方应该有点多，还不知道 Android X和support 包可以共存吗？感觉没法共存，毕竟从activity 到view好像都变了，毕竟第3方包如果没有适配Android X就没法改。自己整是不可能自己整的，毕竟老板没有要求，那我们就永远不适配AndroidX的代码。感觉有点和Android 最新时代已经脱轨了。
好了，回归正文，我们主要是整fragmentmanager。
顺便推一下博客主页
正文 显示fragment吧，这个老朋友了，不需要介绍，app 下的fragment和v4下的fragment调用对应的fragmentmanager就好了。而显示fragment 一般有几种:
 通过ViewPager 加载 通过FrameLayout 通过dialogFragment 显示  这个地方主要整:基于FrameLayout 显示fragment。
显示fragment 代码大概是需要显示成这个样子。
1public Fragment showFragment(String className, FragmentManager fragmentManager, int id) { 2 Fragment fragment = null; 3 try { 4 5 FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); 6 //隐藏所有的那个啥。 7 for (Fragment fra : fragmentManager.getFragments()) { 8 fragmentTransaction.hide(fra); 9 } 10 Fragment fragmentByTag = fragmentManager.findFragmentByTag(className); 11 if (fragmentByTag !</description>
    </item>
    
    <item>
      <title>摸鱼DialogFragment</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/%E6%91%B8%E9%B1%BCdialogfragment/</link>
      <pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/%E6%91%B8%E9%B1%BCdialogfragment/</guid>
      <description>前言 话说dialogfragment。这个调调，我用的还是蛮多的。像popwindow,loading，或者一些dialog如果能够用dialogfragment 实现，我一般会选择用这个调调。毕竟有生命周期，感觉和写fragment没有区别。这就导致我基于dialog 实现自定义dialog的能力比较差，主要还是主题设置，设置好了还是感觉差不多的。当然了popwindow的优点还是dialog 或者dialogfragment 无法比拟的。还有一个原因，我比较喜欢将一些值存储到activity的intent中(这么写，还是要提供完整的注释的，要不然不习惯这种写法的会看得很难受)，感觉dialog 中获取activity 没有fragment中那么方便。但是我看好多UI库都是自己写了一个dialog(比如说QMUI) ?搞得我有点懵逼。但是我看别人的代码，很少用dialogfragment 为啥我看到的代码里面，大家都用dialog 而不是dialogfragment ?这个以后探讨吧。
顺便推一下博客主页
正文 话说这个调调DialogFragment和其他控件差不多，也是从28以后移出出去了。看来把代码适配更新到Android X是需要提上日程了。关于基础用法这个网络上很多大佬写过博客的，我觉得没有重复的必要的，和fragment 差不多，还是重要的一点，配置style会影响dialogfragment的显示效果的，状态栏也可以按照需求配置的。
主题 我所使用的主题。通常是全屏的。这个需要通过自己的需求配置
1&amp;lt;style name=&amp;#34;Dialog.FullScreen&amp;#34; parent=&amp;#34;AppTheme&amp;#34;&amp;gt; 2 &amp;lt;item name=&amp;#34;android:windowNoTitle&amp;#34;&amp;gt;true&amp;lt;/item&amp;gt; 3 &amp;lt;item name=&amp;#34;android:windowBackground&amp;#34;&amp;gt;@color/transparent&amp;lt;/item&amp;gt; 4 &amp;lt;item name=&amp;#34;android:windowIsFloating&amp;#34;&amp;gt;false&amp;lt;/item&amp;gt; 5 &amp;lt;item name=&amp;#34;android:textColor&amp;#34;&amp;gt;@color/color_333333&amp;lt;/item&amp;gt; 6 &amp;lt;item name=&amp;#34;android:textSize&amp;#34;&amp;gt;14sp&amp;lt;/item&amp;gt; 7 &amp;lt;item name=&amp;#34;android:backgroundDimEnabled&amp;#34;&amp;gt;true&amp;lt;/item&amp;gt; 8&amp;lt;/style&amp;gt; 9 10&amp;lt;style name=&amp;#34;DialogNoDim&amp;#34; parent=&amp;#34;Dialog.FullScreen&amp;#34;&amp;gt; 11 &amp;lt;item name=&amp;#34;android:backgroundDimEnabled&amp;#34;&amp;gt;false&amp;lt;/item&amp;gt; 12 &amp;lt;/style&amp;gt; 使用:
1@Override 2public void onCreate(@Nullable Bundle savedInstanceState) { 3 super.onCreate(savedInstanceState); 4 setStyle(STYLE_NORMAL, R.style.Dialog_FullScreen); 5} 其他设置：
1@Nullable 2@Override 3public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) { 4 getDialog().</description>
    </item>
    
    <item>
      <title>Android sqlite前言</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96sqlite%E7%9B%AE%E5%BD%95/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96sqlite%E7%9B%AE%E5%BD%95/</guid>
      <description>前言 话说现在已经2020年了，在Android 应用端上混混沌沌的搬砖已经3年多快4年了。之前也迷迷糊糊的写了些什么，但是却没有一个好一点的系列文章。大多数同行的评论都是&amp;quot;什么都懂一点，但是什么都不精&amp;quot;，还是蛮想改变这个现状的。所以打算认真写一个系列出来，因为最近在复习sqlite,想从各个大佬的项目中找到自己的不足。所以打算写一个sqlite的理解系列吧。
sqlite 通用（Android）   Android 系统内嵌了sqlite，所以使用sqlite的时候并不需要导入jar或者aar 文件或者连接池等。
  Android 中通过 SQLiteDatabase及其子类对表的创建，删除，改名，对内容的增删改查操作。同时可以获取版本号等其他操作。
  Android 上使用sqlite是可以更改 sqlite 存在的位置的，但是默认是/data/data/PACKAGE NAME/DB NAME目录*（就像您在设备的内部存储空间中保存文件一样，Android 会将您的数据库存储在您应用的私有文件夹中。您的数据安全无虞，因为在默认情况下，其他应用或用户无法访问此区域。）*。
  sqlite的更新和创建是在获取SQLiteDatabase的时候执行的（这个可以通过打印log知道）官方文档中提到*（SQLiteOpenHelper 类包含一组用于管理数据库的实用 API。当您使用此类获取对数据库的引用时，系统仅在需要时才执行可能需要长时间运行的数据库创建和更新操作，而不是在应用启动期间执行。您仅需调用 getWritableDatabase() 或 getReadableDatabase() 即可。）*
  sqlite 的表不支持直接重命名表名。如果想要更改表的名字，需要将原表名设置一个临时表名，然后通过新表名创建表，然后删除零时表。
  sqlite 只支持对表增加字段。如果需要删除字段，修改字段名，修改字段对应的类型，都需要通过创建新表，然后复制对应的数据到新表，再删除原表达到效果，这么一想，向表中增加字段也可以通过上面操作进行。
  sqlite 更新是通过检测版本号进行的。
  sqlite有一个sqlite_master 表，通过这个表可以查找所以表的表名，创建sql语句等。
  sqlite 可以查看表的信息和字段 通过 PRAGMA table_info(student) 语句。
  Cursir 使用完之后建议 执行cursor.close(); 关闭游标，但是SQLiteDatabase 不建议在SQLiteOpenHelper 中执行close() 方法，关闭了再同对象中使用可能会抛异常。同时再官方文档中提到（由于在数据库关闭时，调用 getWritableDatabase() 和 getReadableDatabase() 的成本比较高，因此只要您有可能需要访问数据库，就应保持数据库连接处于打开状态。通常情况下，最好在发出调用的 Activity 的 onDestroy() 中关闭数据库）。</description>
    </item>
    
    <item>
      <title>Android sqlite增删改查</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96sqlite%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96sqlite%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</guid>
      <description>前言 日常搬砖sqlite目录 再目录中提到了一些东西，有兴趣可以点过去看一下，觉得还行麻烦点下赞。
正文 第一步创建数据库 再目录文档中，引用了官方文档的一段话 SQLiteOpenHelper 类包含一组用于管理数据库的实用 API。当您使用此类获取对数据库的引用时，系统仅在需要时才执行可能需要长时间运行的数据库创建和更新操作，而不是在应用启动期间执行。您仅需调用 getWritableDatabase() 或 getReadableDatabase() 即可。
  第一步应该是创建数据库文件。通过上面的引用可以知道 我们创建 数据库文件只需要 继承 SQLiteOpenHelper即可。而SQLiteOpenHelper的构造函数需要传入context，name，factory,version.通常情况下，我们创建数据库的时候只需要context，name，version，name 确定数据库文件的名字，version用于判断创建或更新数据库。
  系统仅在需要时才执行可能需要长时间运行的数据库创建和更新操作，所以我们的创建表的sql语句是可以装到一个list 中的，当然也可以存放到一个map 中，通过表名+创建表的sql。只要我们不获取SQLiteDatabase 数据库就不会创建更新。
  由于在数据库关闭时，调用 getWritableDatabase() 和 getReadableDatabase() 的成本比较高，因此只要您有可能需要访问数据库，就应保持数据库连接处于打开状态 * ，我们决定使用单例。
  在onCreate 中通过execSQL();创建表。
所以整个 SQLiteOpenHelper 可以长这个样子： ​
1public class SqliteDBHelper extends SQLiteOpenHelper { 2 public static final String DATABASE_NAME = &amp;#34;base.db&amp;#34;; 3 public static final int DATABASE_VERSION = 1;//版本号 4 private static volatile SqliteDBHelper helper = null; 5 List&amp;lt;String&amp;gt; allTabs = new ArrayList&amp;lt;&amp;gt;();//这个存放所有的最新的SQL表。不同版本用户创建时候直接创建所以表。 6 7 private SqliteDBHelper(Context context) { 8 super(context, DATABASE_NAME, null, DATABASE_VERSION); 9 initAllSql(); 10 /*UpDateDao dao = new UpDateDao(getReadableDatabase(), allTabs); 11 dao.</description>
    </item>
    
    <item>
      <title>Android sqlite增删改查另类写法</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96sqlite%E5%A2%9E%E6%94%B9%E6%9F%A5%E5%8F%A6%E7%B1%BB%E5%86%99%E6%B3%95/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96sqlite%E5%A2%9E%E6%94%B9%E6%9F%A5%E5%8F%A6%E7%B1%BB%E5%86%99%E6%B3%95/</guid>
      <description>前言 啊哈，今天又更新了。接上一篇日常搬砖sqlite可用类型与存储类型 。
顺便推一下日常搬砖sqlite目录
之前又一篇博客提到了json 对象不仅仅可以通过对象class 解析，也可以解析成map.巧合的是sqlite 添加和更新需要的ContentValues 也是一个类似于map的结构。既然object 与map互转，同理可以解决 object可以和ContentValues 互相转化，是吧。还有一个点 cursor.getType(cursor.getColumnIndex(key)) 可以获取到值的type,所以开整。先总结下可能需要的逻辑。
  ContentValues 也是一个类似于map的结构。 逻辑上object可以和ContentValues 互相转化 cursor.getType(cursor.getColumnIndex(key)) 可以获取到值的type。 通过反射可以获取到对应字段设定的type Cursor 获取到的type 包含 FIELD_TYPE_NULL，FIELD_TYPE_INTEGER，FIELD_TYPE_FLOAT，FIELD_TYPE_STRING，FIELD_TYPE_BLOB（ps:不要问我从哪里看到的，点开对应的class 都有） ContentValues 支持存放主要类型：String，Byte，Short，Integer，Long，Float，Double，Boolean，byte[]等。（ps:不要问我从哪里看到的，点开对应的class 都有）   正文 通过反射拿到所以的Field 1/** 2 * 获取所有的内容，解决父类中参数获取不到的bug 3 * @param object 4 * @return 5 */ 6private static Field[] getAllFieldsByObject(Object object){ 7 Class clazz = object.getClass(); 8 List&amp;lt;Field&amp;gt; fieldList = new ArrayList&amp;lt;&amp;gt;(); 9 while (clazz != null){ 10 fieldList.</description>
    </item>
    
    <item>
      <title>Android sqlite更新</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96sqlite%E6%9B%B4%E6%96%B0/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96sqlite%E6%9B%B4%E6%96%B0/</guid>
      <description>前言 顺便推一下日常搬砖sqlite目录
这个目录里面有sqlite 初始化 增删改查等一些东西，我们就接着这个系列讲数据库更新，之前我们数据库更新判断是通过版本号进行的。而且有一个问题哈，如果我有1，2，3，4，5，共5个版本，通过为了分别应对每个版本，onUpgrade这个方法里面要写很长的东西，简单粗暴的方式当然就是用户强制升级到最新版本，那么我们就只需要处理最新版本的事情了，问题是每一次升级不都是当前最新版本吗？开发阶段中，通过数据库版本号升级要写一大堆逻辑，卸载的化数据又没有了。于是比较懒的我就开始思考一个问题，我每次用之前检测一次是否一致不就好了？那么就需要准备需要的理论知识了、
 系统仅在需要时才执行可能需要长时间运行的数据库创建和更新操作，而不是在应用启动期间执行。您仅需调用 getWritableDatabase() 或 getReadableDatabase() 即可。（这个获取运行时） sqlite 的表不支持直接重命名表名。如果想要更改表的名字，需要将原表名设置一个临时表名，然后通过新表名创建表，然后删除零时表。 sqlite 只支持对表增加字段。如果需要删除字段，修改字段名，修改字段对应的类型，都需要通过创建新表，然后复制对应的数据到新表，再删除原表达到效果，这么一想，向表中增加字段也可以通过上面操作进行。 sqlite有一个sqlite_master 表，通过这个表可以查找所以表的表名，创建sql语句等。 sqlite 可以查看表的信息和字段 通过 PRAGMA table_info(student) 语句。 cursor.getColumnNames()。  正文 通过上面的理论依据，我觉得下面的理论是可行的。
  在获取SQLiteDatabase 之后立即运行一次更新检测逻辑。
  将创建表的sql语句通过list 或者map 存储起来。
  通过sqlite_master获得表名和创建语句
  通过创建sql与sqlite_master获得的创建sql语句对比，同时优先判断是否有创建的表名。
  如果没有则创建表，如果有比对创建sql是否一致。如果创建sql不一致，将原表名重命名为临时表，然后通过创建表，将原表中的数据通过ContentValues取出，赋值到创建表中，然后删除临时表。
  这么写有一个逻辑问题，如果表中的一个字段修改类型之后，可能导致插入失败。建议参考 日常搬砖sqlite可用类型与存储类型，所以不建议对字段修改类型，汉语博大精深换一个名字我觉得是可以的。
  如果忽略6这一点，那么我们的sqlite 启动检查更新的逻辑还是行得通的，毕竟只是对表名和表创建sql进行比对，这个还是很快的。当然性能肯定没有版本号更新好，但是胜在简单粗暴。ps(这只是一种思路，我孤陋寡闻的，反正我的没有见过别人这么写过，毕竟性价比太低了，还是应该老老实实的更新版本号的)那么就可以开整。
通过sqlite_master 获取表名和创建sql 1public Map&amp;lt;String,String&amp;gt; getAllTabs() { 2 Map&amp;lt;String,String&amp;gt; map=new HashMap&amp;lt;&amp;gt;(); 3 String sql = &amp;#34; SELECT * FROM sqlite_master WHERE type = &amp;#39;table&amp;#39;&amp;#34;;//PRAGMA table_info(student) 这个也可以查询表信息。但是只能针对某一个知道表名的表。 4 Cursor cursor = db.</description>
    </item>
    
    <item>
      <title>Android sqlite约束</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96sqlite%E7%BA%A6%E6%9D%9F/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96sqlite%E7%BA%A6%E6%9D%9F/</guid>
      <description>前言 顺便推一下日常搬砖sqlite目录 。
接着上面的写，之前有写到使用sqlite 实现增删改查等简单使用。sqlite是一个关系型数据库，既然是数据库那么它就一定不会这么简单了，是吧，要不然就没有专门做数据库设计的岗位了。当然了在Android上的应用通常可能没有这么复杂。那么简单的约束还是可以了解下的。毕竟我们可能不会做出超出我们逻辑认知的操作。如果想要实现某个功能，那么知道当前工具是否可以是很有必要的吧。
正文 那么我们就直接上菜，Android 上无论是room 还是greendao，都是基于sqlite提供服务的，他们实现的sqlite 就必定有，是吧。我们知道一个表的设计包括 表名，字段名，字段名对应的类型（必须），字段名对应的其他约束。
类型 之前有一篇文章关于sqlite可用类型与存储类型. 在这里就不再次描述了。
约束 runoob sqlite  本文中大多数都是基于该教程，这个还是可以看一下的。SQLite 约束
  primary key: 唯一标识数据库表中的各行/记录
  autoincrement :自增 通常用于 int类型的字段。
  NOT NULL:确保某列不能有 NULL 值
  DEFAULT :当某列没有指定值时，为该列提供默认值
  UNIQUE 约束：确保某列中的所有值是不同的.
  CHECK 约束：CHECK 约束确保某列中的所有值满足一定条件。
算了，感觉自己写的没有别人提供的约束教程好，这个就当做笔记算了，直接查看 上面的教程吧。心态有点难受。
  结束 谢谢光临，若觉得还行麻烦点一下赞，若觉得写得垃圾，欢迎批评指正。笔者知道自己文笔和表达能力很弱，如果您可以提供点宝贵的意见不胜感激。谢谢。
今天也可以是元气满满的一天哦。</description>
    </item>
    
    <item>
      <title>Android基础数据类型与sqlite存储类型</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96sqlite%E5%8F%AF%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96sqlite%E5%8F%AF%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B/</guid>
      <description>前言 之前又一篇文章上讲到 cursor.getType(cursor.getColumnIndex(key)) 可以获取到对应值的类型，通过cursor 类可以知道，cursor 就提供了4种类型。而ContentValues 定义了不止4总类型，sqlite的插入与更新都可以通过ContentValues 对象进行操作的。目录地址
 cursor 定义了4种类型 ContentValues 定义了不止4总类型 sqlite 插入更新都可以通过 ContentValues 对象进行 问题1：sqlite 在创建表的时候是否支持所以的ContentValues 定义类型。 问题2:sqlite 支持的类型 对应了cursor中的哪些类型。 有一个教程博客写的很清晰runoob SQLite 数据类型  安利一个软件sqlitestudio。/data/data/PACKAGE NAME/ 是sqlite 默认存储路径。
正文 创建sqlite表 ContentValues 支持存放主要类型：String，Byte，Short，Integer，Long，Float，Double，Boolean，byte[]等。那么创建sql，我们知道 string 是通过varchar 存储。不知道直接写string 是否可以创建表。
1 create table if not exists all_content_values ( _id Integer primary key autoincrement , string_key String, byte_key Byte,short_key Short ,long_key Long, float_key Float,double_key Double,Boolean_key Boolean,byte_array byte[] ) if not exists 这个是用于防止表重复创建。</description>
    </item>
    
    <item>
      <title>Android开启Debug</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android%E5%BC%80%E5%90%AFdebug%E4%B9%8B%E8%B7%AF/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android%E5%BC%80%E5%90%AFdebug%E4%B9%8B%E8%B7%AF/</guid>
      <description>前言 电脑不是太好。现在用的也仅仅是mac air 1.8 GHz 双核Intel Core i5 8 GB 1600 MHz DDR3。电脑情况不是太好，需要经常清理缓存啊，运行代码量稍微大一点的项目就感觉慢。打算明年换一个好一点的。所以我本人是比较倾向于插件化和aar的使用的，fragment 使用比重也很高，毕竟只要写好了模板，debug功能还是比activity 简单些。
说回正题。Android debug 模式也不多，常用的一般分为：
 打印log 打断点 测试代码 让测试复现bug 等  顺便推一下博客目录
正文 打印log ​	这种情况，一般是检查参数或者接口的时候，如果电脑不怎么行，打log 电脑也不怎么卡，打断点可能就卡了。
但是呢，string 虽说够长，但是log 的打印是有长度限制的。万一log体长度超出了怎么办？只能代码截取分log 打印了。像这种网络上还是蛮多的。
打断点 本篇我们也就主要是介绍下打断点。可能出现的问题。
先介绍下图标1是run（运行，如果手机上没有安装当前app 这个应该是三角形）.2是debug,3是attach debugger to android process。
  debug 版本运行不到手机上。重新编译项目或者删除主项目下 build文件（不要删除错了），还有重新导入编译项目，一般就可以运行到手机上了。
  idea 左边栏有一个 Build variants 工具（可能在其他位置）可以切马甲包配置或者release，debug等。同一个APP 下版本应该是一致的。切成同一个版本就好了。
  release 版本是无法运行debug的。 如果使用release 版本debug 会提示:
 Error running &#39;sqliteroom&#39; Cannot debug application from module sqliteroom on device huawei-lld_al00-MKJDU17C08001071.</description>
    </item>
    
    <item>
      <title>Android时间相关view</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3view/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3view/</guid>
      <description>》 顺便推一下博客主页
前言  话说，Android 上整时间相关的情况也是蛮多的，比如时间选择器，日期选择器，显示一个时钟，显示一个详细时间，验证码倒计时（计时器）等等。 选择器相关的就不多描述了，一般都是通过wheelVew 做滚动联动或者就是列表做联动，或者就是第3方的控件拖进来，当前属于笔记就不整这些了。 搬砖多年，突然看到基本Android基础书籍，才发现自己好多都忘记了。
 正文 模拟时钟 AnalogClock
详细时间 DigitalClock
计时器 这个就比较骚了，很少有想到有基础控件的，我看过很多都是handle 去实现，或者梦想点就是Rxjava,区别在于有些大佬杀界面重新进去会复活之前已经刷新过的倒计时，有些大佬不会。
Chronometer
结束 </description>
    </item>
    
    <item>
      <title>hexo&#43;Gitee pages 搭建个人主页</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/%E5%9F%BA%E4%BA%8Egitee-pages&#43;hexo%E6%8B%A5%E6%9C%89%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%BB%E9%A1%B5/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/%E5%9F%BA%E4%BA%8Egitee-pages&#43;hexo%E6%8B%A5%E6%9C%89%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%BB%E9%A1%B5/</guid>
      <description>前言 顺便推一下博客目录
之前整过一个Jekyll和静态网页的主页笔记，最近换季，导致感冒拉肚子，又为国庆生等等耽搁了快一个月了，原本打算这个系列在一周内整出来的，结果到现在还有2个TODO未实现。那么本篇主要级hexo.先上文档官网：
gitee pages 官方文档
Hexo 使用文档：https://hexo.io/docs/
这个是用Node.js .
既然我们用的IDEA,那么node,js也是需要安装的。必须安装。
正文 如果你的Node.js 已经安装成功了。那么按照hexo 提供的教程走就好了。
安装Hexo 先安装hexo：https://hexo.io/zh-cn/docs/
安装2选1就好。
创建执行HEXO 项目 创建 创建代码还是很简单，找一个空目录在终端中执行：
1hexo init myblog Myblog 是自目录名称，根据个人爱好写。然后是:
​	cd myblog//切到myblog 目录：
最后执行：
1npm install 然后通过idea 打开该项目就可以进行编辑了。
配置运行 因为这个项目是基于Node,js 运行的，那么我们直接对整个项目的运行环境进行设置？
对于一个闲鱼而言，从代码中找到运行项是很简单的。比如说**hexo server ** 我觉得这个就是运行Demo 的关键。
如果idea 打开这个文件没有运行按钮，就需要对整个项目目录配置为node 的项目比如：
![image-20201009112924696](/Users/yangfan/Library/Application Support/typora-user-images/image-20201009112924696.png)
但是通常还是有运行按钮的。运行成功后打开：http://localhost:4000/ 就可以看到初始创建的博客样子了。如果404 明显就是 hexo server 没有运行成功嘛。
添加一篇文章 我们在运行成功后，发现里面有一篇默认文章。修改网页的一些默认值 https://hexo.io/zh-cn/docs/configuration。这里就不重复了。我们可以在项目的目录下找到：
这个和运行出来的hello world 内容是差不多的。里面除了正文 还有：
1--- 2title: 测试Demo1 3--- 这个怎么和Jekyll 的文章配置这么像啊，兄弟。而且没有要求用时间+名字，很舒服。那么我不写这个配置会出现什么情况？
和Jekyll 一样的嘛，标题都是抓的title。但是时间是抓的生成时间。而且Jekyll标题没有按照格式来的话，是不会显示到目录中的，这个好像可以设置。</description>
    </item>
    
    <item>
      <title>Hexo&#43;Gitee pages 搭建个人主页进阶</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/hexo&#43;gitee-pages%E8%BF%9B%E9%98%B6/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/hexo&#43;gitee-pages%E8%BF%9B%E9%98%B6/</guid>
      <description>前言 之前整了一些笔记。
[gitee+picgo 图床上传图片404](https://gitee.com/lalalaxiaowifi/pictures/blob/master/博客/其他/gitee 图床上传图片404.md)
[基于html拥有自己的主页](https://gitee.com/lalalaxiaowifi/pictures/blob/master/博客/其他/如何基于gitee pages 搭建一个属于自己的主页.md)
[基于Jekyll拥有自己的主页](https://gitee.com/lalalaxiaowifi/pictures/blob/master/博客/其他/2020-09-29-基于Gitee pages+Jekyll拥有一个属于自己的主页.md)
[Gitee Pages Jekyll如何才能放到子目录和非同名项目中](https://gitee.com/lalalaxiaowifi/pictures/blob/master/博客/其他/Gitee Pages Jekyll如何才能放到子目录和非同名项目中.md)
[基于Hexo拥有自己的主页](https://gitee.com/lalalaxiaowifi/pictures/blob/master/博客/其他/基于Gitee pages+Hexo拥有一个属于自己的主页.md)
[基于Hugo拥有自己的主页](https://gitee.com/lalalaxiaowifi/pictures/blob/master/博客/其他/基于Gitee pages+Hugo拥有一个属于自己的主页.md)
都是基于Gitee 的。反正最近很闲，没有多少动力学习Android，其实没有完成的todo 还是蛮多的。但是就想摸鱼。毕竟越是难的东西，花费的精力就越多，像网上哪些多少天就学会什么成为高阶开发什么的，对我完全不适用，除非就真的很简单，但是会简单的也成不了高阶吧。话说回来，Gitee pages 主页就比较简单了，至于为啥药写这么多简单的笔记，主要锻炼自己总结能力和逻辑能力吧。
顺便推一下博客目录
正文 话说，之前有一个[基于Hexo拥有自己的主页](https://gitee.com/lalalaxiaowifi/pictures/blob/master/博客/其他/基于Gitee pages+Hexo拥有一个属于自己的主页.md) 。这个是推的编译后的文件到同名项目的根目录。而一个人只有一个同名项目，同时在gitee pages上只能开启一个主页。对于我这种脑洞满天飞，且不断作死的baby.我觉得，既然人家文档都提供了，不利用起来那就开整，还是先贴文档。https://gitee.com/help/articles/4136#article-header0
  编译 Hexo 依据：仓库编译目录下存在package.json，_config.yml文件和scaffolds目录的，会使用hexo generate生成静态文件，由于每次部署编译需要重新克隆编译并进行npm install，所以使用 Hexo 的时间相对 Hugo 和 Jekyll 会长一些。   哦哦，理解一波，这个可以直接提交项目源代码。
 Hexo 配置文件_config.yml的url和root修改如下：
1url: https://ipvb.gitee.io/blog 2root: /blog  这个理解一波，就是可以提交到非同名项目下。基于之前Jekyll 使用github 主题导致问题。那么，我们这个hexo就不用别人的主题，直接使用系统提供的。这里解释下，Github 对Github pages 对应的项目名有明确的要求，不像Gitee pages 玩的这么花，如果是放在同名根目录下是没有问题的，如果是放到非同名项目中。那么可能因为主题作者没有适配一些东西，导致资源文件找不到，还是建议放到同名根目录，毕竟个人主页嘛，一个就好。也没有一些莫名其妙的问题。
源码提交 之前那篇笔记是通过一键部署到同名项目的根目录下的。既然是提交项目源代码，那么就不能用一键部署了咯。那就开整。之前本地安装过环境。就直接创建项目了。
1hexo init myblog 2npm install 稍微修改写congfig 中的内容。</description>
    </item>
    
    <item>
      <title>Hugo&#43;Gitee pages 搭建个人主页</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/%E5%9F%BA%E4%BA%8Egitee-pages&#43;hugo%E6%8B%A5%E6%9C%89%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%BB%E9%A1%B5/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/%E5%9F%BA%E4%BA%8Egitee-pages&#43;hugo%E6%8B%A5%E6%9C%89%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%BB%E9%A1%B5/</guid>
      <description>前言 之前整过一个静态网页，一个Jekyll，一个hexo.话说，如果我知道的不完整，我怎么才能知道什么才是适合自己的呢？那么，就开整。
顺便推一下博客目录
正文 老规矩，还是先贴官方教程:
Gitee pages 适用文档: https://gitee.com/help/articles/4136#article-header0
Hugo 使用文档：https://gohugo.io/documentation/
 Hugo is the world’s fastest static website engine. It’s written in Go (aka Golang) and developed by bep, spf13 and friends.
 不说别的，光说上面的这一句话包含的意思，一个Go，一个最快。我就应该先了解这个，了解这个之后，前面几个笔记也不会这么苦逼的写了，直接放弃就好。
环境 既然是基于Go,那么IDEA 开发环境还是需要的。老规矩，还是先整插件:https://plugins.jetbrains.com/
https://plugins.jetbrains.com/plugin/9568-go 下载和IDEA版本号相同的插件。
因为网络问题，GO SDK 在IDEA 中下载缓慢，甚至版本号都拉不到，所以需要自己手动下载安装。
https://golang.google.cn/dl/
安装运行 不同的系统环境，安装的方式不同。详情看教程：https://gohugo.io/getting-started/installing 。就因为我没有看这个教程，我的电脑更新Homebrew 已经更新10分钟了。因为安装的方式太多了，所以就不截图介绍了。
 hugo version 通过这个验证版本号，同时验证安装是否成功。有版本号就成功了，没有应该就是没有成功。
 但是一项脑洞到处跑的我，突然想到了 hugo 可能出现在IDEA的插件中我果然在IDEA 插件库中找到了一个。但是本地还是需要一个安装Hugo.但是也不是没有用，起码可以直接运行项目。
通过Homebrew安装过程中或许会出现:
 The following directories are not writable by your user:
/usr/local/sbin</description>
    </item>
    
    <item>
      <title>Hugo&#43;Gitee pages 搭建个人主页</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/%E5%9F%BA%E4%BA%8Ehogo%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%BB%E9%A1%B5/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/%E5%9F%BA%E4%BA%8Ehogo%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%BB%E9%A1%B5/</guid>
      <description>前言 在对比了Jekyll，hexo和hugo 之后，我决定使用Hugo搭建属于自己的主页。自己写静态网页这个调调就基本上放弃了。因为打算认真的写笔记什么的了。 选择hogo 原因还是蛮简单的，主要是他主题提供了Demo。虽然Jekyll主题可以下载别人项目的源码，但是还是需要去读和修改的。 顺便推一下博客目录
结束 http://localhost:1313/images/avatar.jpg 谢谢光临，若觉得还行麻烦点一下赞，若觉得写得垃圾，欢迎批评指正。笔者知道自己文笔和表达能力很弱，如果您可以提供点宝贵的意见不胜感激。谢谢。
今天也可以是元气满满的一天哦。 更新需要审核。更新通常优先更新到gitee上面。
博客目录</description>
    </item>
    
    <item>
      <title>Hugo&#43;Gitee pages 搭建个人主页进阶</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/hogo&#43;gitee-pages%E8%BF%9B%E9%98%B6/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/hogo&#43;gitee-pages%E8%BF%9B%E9%98%B6/</guid>
      <description>前言 之前整了一个Gitee page 的笔记。
[gitee+picgo 图床上传图片404](https://gitee.com/lalalaxiaowifi/pictures/blob/master/博客/其他/gitee 图床上传图片404.md)
[基于html拥有自己的主页](https://gitee.com/lalalaxiaowifi/pictures/blob/master/博客/其他/如何基于gitee pages 搭建一个属于自己的主页.md)
[基于Jekyll拥有自己的主页](https://gitee.com/lalalaxiaowifi/pictures/blob/master/博客/其他/2020-09-29-基于Gitee pages+Jekyll拥有一个属于自己的主页.md)
[Gitee Pages Jekyll如何才能放到子目录和非同名项目中](https://gitee.com/lalalaxiaowifi/pictures/blob/master/博客/其他/Gitee Pages Jekyll如何才能放到子目录和非同名项目中.md)
[基于Hexo拥有自己的主页](https://gitee.com/lalalaxiaowifi/pictures/blob/master/博客/其他/基于Gitee pages+Hexo拥有一个属于自己的主页.md)
[Hexo+Gitee pages进阶](https://gitee.com/lalalaxiaowifi/pictures/blob/master/博客/其他/Hexo+Gitee pages进阶.md)
[基于Hugo拥有自己的主页](https://gitee.com/lalalaxiaowifi/pictures/blob/master/博客/其他/基于Gitee pages+Hugo拥有一个属于自己的主页.md)
因为Jekyll 和Hexo的经验让我写这个笔记的时候索然无味。话说hugo 也是提交的静态网页到同名项目到根目录，然后还配置了baseurl才可以的。
顺便推一下博客目录
正文 作为一个杠精，我觉得，既然Jekyll，hexo 都可以上传源码和静态网页到同名项目和非同名项目。那么我Hugo必定可行，只是我没有找到解决方式罢了。通过Jekyll和Hexo的经验，都是编译后提交才显示成功的，而且根目录可以子目录就一定可以，子目录可以根目录也可以。同名项目和非同名项目在Gitee page 上的部署的区别主要在于设置。主题可能影响部署中资源文件使用情况。那么就开整。
还是直接上教程：https://gitee.com/help/articles/4136#article-header0
  编译 Hugo 依据：仓库编译目录下存在config.toml|json|yaml文件和content目录的时候，会使用hugo生成静态文件。   这个说明可以部署源码。
 Hugo 配置文件config.toml的baseURL修改如下
1baseURL = &amp;#34;https://ipvb.gitee.io/blog&amp;#34;   hugo new site quickstart
切到项目目录下主题。
1git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke   修改config 中的theme = &amp;quot;ananke&amp;quot;
 本地开启server
 hugo server -D</description>
    </item>
    
    <item>
      <title>java部分修饰符</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/java-%E4%BF%AE%E9%A5%B0/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/java-%E4%BF%AE%E9%A5%B0/</guid>
      <description>前言 明明刚刚在写另外一篇博客的，然后准备资料的时候发现了一些懵逼的东西。这个明显触及到了我的知识点盲区。主要是有一种很乱的感觉，没错是我菜，见识短浅啊。
直接上教程runoob Java 教程。本篇主要介绍两个修饰符 final，volatile。当然了runoob java 修饰符 这个教程把修饰符都讲完了。为啥写，主要是缺点笔记。
还有是为了认真工作嘛。
如果领导路过不打招呼又在摸鱼影响不好，反正都是在认真工作的样子。。
那么我们就开始罗列知识点:（具体使用请参考 上面教程）   final 变量：
final 表示&amp;quot;最后的、最终的&amp;quot;含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。
final 修饰符通常和 static 修饰符一起使用来创建类常量。
  final 方法
父类中的 final 方法可以被子类继承，但是不能被子类重写。
声明 final 方法的主要目的是防止该方法的内容被修改。
  final 类
final 类不能被继承，没有类能够继承 final 类的任何特性。
  volatile 修饰符
volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。
  顺便推一下博客目录 。
正文 我去，上面总结完了，现在正文写啥？
先说final 吧，修饰常量，Android 可以定义在xml 中 通过Context的getResources() 获取string或者int 值。常量是存储在内存中的，那么和Android 从xml 中获取到底谁的性能更加优秀？
然后是在单例中使用，Android 中使用单例的机会也不是太多，大多数和生命周期绑定使用，只有哪些初始化成本比较高，使用较为频繁的功能才可能考虑单例。比如数据库的db对象和SharedPreferences.都是创建成本高，而且对象方法加锁执行，可能导致线程阻塞，如果是异步处理volatile 从逻辑上讲更好啊，
final 修饰方法，这个主要是用于功能设计的底层逻辑编写。
final 修饰类，类不能被继承，核心功能类设计吧，通常和包限制共同使用。</description>
    </item>
    
    <item>
      <title>Jekyll&#43;Gitee pages 搭建个人主页</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/2020-09-29-%E5%9F%BA%E4%BA%8Egitee-pages&#43;jekyll%E6%8B%A5%E6%9C%89%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%BB%E9%A1%B5/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/2020-09-29-%E5%9F%BA%E4%BA%8Egitee-pages&#43;jekyll%E6%8B%A5%E6%9C%89%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%BB%E9%A1%B5/</guid>
      <description>前言 顺便推一下博客目录 。之前写过一个基于静态html的笔记。
正文 Jekyll 既然自己写静态网页对于我这种小白而言太复杂了，那么用博客主页生成工具就可以了，毕竟鲁迅曾经说过&amp;quot;成年人最大的优点就是及时止损&amp;quot;。
Jekyll 使用文档：https://www.jekyll.com.cn/docs/home/。
这个要安装Ruby 环境？ 这丫的感觉一个脚本语言，我觉得我还是用html 比较好，毕竟我这个是会的。
基于IDEA 安装环境 先整一个ruby教程runoob Ruby 教程 。这个感觉和Python很像嘛。那就开整。这个调调的使用感觉和Node.js 很像啊，不会要Node.js 环境吧。怕是需要看一下Ruby 使用安装环境 。
我的是mac 环境。
这个是要Xcode ? 我一个Android 搬砖工，也没有安装这个调调啊，我觉得我的IDEA可以完成这个调调。那么直接IDEA 插件官网。IDEA Ruby 插件  根据自己的IDEA 版本号下载对应的版本就好，版本对不上就安装不了。然后自己将下载下来的插件安装到自己的idea 里面就好。然后就是用IDEA自身功能下载sdk就好。然后创建一个Ruby的空项目，创建一个Ruby文件。配置ruby的运行项中的sdk ：
如果可以正常运行，那么环境就配置好了。当然也可能是运行项没有配置好，主要是配置sdk.这个必须要配置。
下载运行Jekyll Demo 现在就是按照官网jekyll 操作指南 下载 Jekyll 和创建环境就好。
下面来说说遇到的问题，
 1和2 需要 在前面加sudo 要不然可能没有目录权限，需要输入密码。 2 是在当前目录下创建一个myblog 目录用于生成文件。 3是进入目录，这个很重要，目录错了会导致运行不了。 jekyll --version 可以查看版本号。如果有说明这个安装成功了的。 bundler: failed to load command: jekyll (/usr/local/bin/jekyll) 这个问题，我从网络上找到的说需要 执行bundle install。 上面的问题是运行bundle exec jekyll serve 导致的，如果没有这个问题，直接打开 http://localhost:4000 会出现这个界面：  通过目录结构:</description>
    </item>
    
    <item>
      <title>Jekyll&#43;Gitee pages 搭建个人主页进阶</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/gitee-pages-jekyll%E5%A6%82%E4%BD%95%E6%89%8D%E8%83%BD%E6%94%BE%E5%88%B0%E5%AD%90%E7%9B%AE%E5%BD%95%E5%92%8C%E9%9D%9E%E5%90%8C%E5%90%8D%E9%A1%B9%E7%9B%AE%E4%B8%AD/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/gitee-pages-jekyll%E5%A6%82%E4%BD%95%E6%89%8D%E8%83%BD%E6%94%BE%E5%88%B0%E5%AD%90%E7%9B%AE%E5%BD%95%E5%92%8C%E9%9D%9E%E5%90%8C%E5%90%8D%E9%A1%B9%E7%9B%AE%E4%B8%AD/</guid>
      <description>前言 之前写了点gitee pages 相关的笔记。
[基于html拥有自己的主页](https://gitee.com/lalalaxiaowifi/pictures/blob/master/博客/其他/如何基于gitee pages 搭建一个属于自己的主页.md)
[基于Jekyll拥有自己的主页](https://gitee.com/lalalaxiaowifi/pictures/blob/master/博客/其他/2020-09-29-基于Gitee pages+Jekyll拥有一个属于自己的主页.md)
[基于Hexo拥有自己的主页](https://gitee.com/lalalaxiaowifi/pictures/blob/master/博客/其他/基于Gitee pages+Hexo拥有一个属于自己的主页.md)
[基于Hugo拥有自己的主页](https://gitee.com/lalalaxiaowifi/pictures/blob/master/博客/其他/基于Gitee pages+Hugo拥有一个属于自己的主页.md)
但是都是基于同名的项目实现的，而且都是推到根目录下的。Jekyll 还是推的源码上去，hexo和Hugo都是推的编译后的文件。因为Jekyll，Hexo，Hugo都是用的静态网页，所以静态网页也是可以直接用的。顺便推一下博客目录
正文 但是，我昨天认真工作(摸鱼的时候)突然想到了一个问题，既然都是生成的静态网页，为啥我直接写的静态网页可以放到非同名项目的子目录下运行，为啥Jekyll，hexo ,hugo 等就不行呢，按道理讲，都是编译生成静态网页啊。先放一个静态网页成功的例子：
运行效果就先不贴了。那么问题来了，是什么导致gitee pages 上面Jekyll，Hexo，Hugo 生成的静态网页用不起的呢？为啥一定要推到根目录，且一定要同名项目呢？还是关于这个配置，我的理解有问题。先贴一个gitee pages 提供的教程：https://gitee.com/help/articles/4136#article-header0
 Jekyll、Hugo、Hexo 编译判断依据  编译 Hugo 依据：仓库编译目录下存在config.toml|json|yaml文件和content目录的时候，会使用hugo生成静态文件。 编译 Hexo 依据：仓库编译目录下存在package.json，_config.yml文件和scaffolds目录的，会使用hexo generate生成静态文件，由于每次部署编译需要重新克隆编译并进行npm install，所以使用 Hexo 的时间相对 Hugo 和 Jekyll 会长一些。 当不符合上述1和2条件的时候，就默认使用Jekyll编译。   通过教程上面的这个内容，个人理解，Jekyll ，hugo，hexo 按道理讲都应该支持上传项目源码的啊。为啥我的只有jekyll 上传源码到同名根目录才可以有效果？其他的都不行呢？这个坑留着，后面慢慢解。另外还有一个问题。
第2点中的:生成的资源 url 应该为 https://ipvb.gitee.io/blog/style.css 才对 ,我觉得他证明了非同名项目，且在字目录中是可以实现个人主页的。上传上去的效果不正确，那就是资源文件的url 不正确。于是我采集了静态网页显示正常的图片的url和jekyll 显示不正常的url.
静态网页显示正常的url:http://lalalaxiaowifi.gitee.io/pictures/images/g2.jpg
jekyll 配置不正常显示的url:http://lalalaxiaowifi.gitee.io/images/avatar.jpg 这个不正常的url 在同名项目的根目录下是运行正常的，我把整个Jekyll项目放到了pictures/tree/master/Blog/jekyllBlog 下面，等于说我的项目名叫pictures，使用分支是master，根目录下的Blog/jekyllBlog，他就显示不正常了，但是通过对比两个url，发现放到其他目录下，生成的链接地址都是错误的(原因参考 上面图片的第2点)。因为这个也证明了我之前的一个猜测，个人用户应该只有一个主页。开启一个后，其他的必定会被关闭，个人理解Gitee pages 对应的localhost 就是个人根目录，比如说我的根目录应该就是：http://lalalaxiaowifi.gitee.io，再比如说我的pictures地址就应该http://lalalaxiaowifi.gitee.io/pictures。也确实如此。那么既然如此，那就按照Gitee Pages 提供的再配置一次。</description>
    </item>
    
    <item>
      <title>object与map项目转换</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96objec%E5%92%8Cmap%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96objec%E5%92%8Cmap%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/</guid>
      <description>前言 搬砖生活中，有一种转换叫做序列化和反序列化。但是本文和这个没有多少关系，我们知道JAVA 的对象的存储是分键和值的，emmmm？map 好像也是哦，我们可能会遇到一个判断一个对象中是否包含多个值或者一个json 中只需要某个值的情况，那么是否可以针对简单对象提供一个json 转map的能力呢？emmmm？gson 实现了，比如这个样子：
1new Gson().fromJson(&amp;#34;&amp;#34;,new TypeToken&amp;lt;Map&amp;lt;String,Object&amp;gt;&amp;gt;(){}.getType()) 但是，这个和本文还是没有关系。我只是顺便引导一下。需要对象转map 的情况通常在与服务器互动过程中。我们定义了一个专门用于传递参数的对象，如果服务器不要求传递json,那么就需要转map了，或者手动赋值。手动？那是不可能的。JAVA 中一个骚操作，叫反射，但是它有一个问题，那就是无法反射到父类的参数。比如有一个每个接口都需要传递的参数，要么每次添加，要么创建对象时候生成。但是这都不是问题。
获取所以内容 1//这个方法可以解决获取不到父类的情况 2private static Field[] getAllFieldsByObject(Object object){ 3 Class clazz = object.getClass(); 4 List&amp;lt;Field&amp;gt; fieldList = new ArrayList&amp;lt;&amp;gt;(); 5 while (clazz != null){ 6 fieldList.addAll(new ArrayList&amp;lt;&amp;gt;(Arrays.asList(clazz.getDeclaredFields()))); 7 clazz = clazz.getSuperclass(); 8 } 9 Field[] fields = new Field[fieldList.size()]; 10 fieldList.toArray(fields); 11 return fields; 12} 13 14	/** 15 * 获取对象中所有可用字段。 16 * @param clazz 17 * @return 18 */ 19 private static Field[] getAllFieldsByClass(Class clazz){ 20 List&amp;lt;Field&amp;gt; fieldList = new ArrayList&amp;lt;&amp;gt;(); 21 while (clazz !</description>
    </item>
    
    <item>
      <title>picgo&#43;gitee配置图床404</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/gitee-%E5%9B%BE%E5%BA%8A%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87404/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/gitee-%E5%9B%BE%E5%BA%8A%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87404/</guid>
      <description>前言 之前逛掘金沸点的时候。得到了某些大佬的指点，然后知道了一个叫图床的神器，反正都是写笔记，搞一个图床也没有啥问题，表示非常喜欢md 的笔记风格。
顺便推一下博客目录
正文 我是通过 picgo+ gitee 图床的。这个教程很多，都写的蛮好的，就不贴了。今天准备认真工作的时候，发现图床上传不了图片，抛了一个404。具体log 稍后再贴。原因也很简单。gitee 的图床插件有两个。我最开始用的是第一个，也就是第一天使用的时候是没有问题的。
但是昨天404，我换成了另外一个就好了，今天又变成了第一个了？于是我把第一个禁用了，换成了第2个。
图片上传404 解决方案 如果安装的插件是第一个出现上传图片404，我遇到的解决方式就是先把第一个禁用了，然后安装第2个。
我也搜索了不少博客，404 通常是配置的时候没有配置对，像这种插件导致的懵逼问题好像没有，但愿你也没有遇到。拿我的图床举例。我的名字和链接地址上是不一样的，我项目的名字是luoye.yangfan/日常搬砖文档，而链接地址是/lalalaxiaowifi/pictures。在picgo的图床配置中 需要使用的是链接地址中的值。还有token 一定要填正确，一定要有master 分支等等。我还是建议用这个插件。如果还是404那就换一个或者配置有问题。图床项目好像是要求公开的（我没有试私有）。
404 log  {&amp;quot;name&amp;quot;:&amp;quot;StatusCodeError&amp;quot;,&amp;quot;statusCode&amp;quot;:404,&amp;quot;message&amp;quot;:&amp;quot;404 - &amp;quot;\n\n\n\n &amp;lt;meta http-equiv=\&amp;quot;Content-Type\&amp;quot; content=\&amp;quot;text/html; charset=UTF-8\&amp;quot; /&amp;gt;\n 你所访问的页面不存在 (404)}
 因为那个404 有点长就不贴完了。这就是页面没有找到，如果配置没有问题，那就是插件的问题了。
picgo 如何查看log 查看log 就很简单了，因为mac 通知无法复制，所以我找404log 都找了一会，终于在打开就好了。不知道Windows 版本是长什么样，应该也差不多吧。
重点 如果不设置为默认图床，那么会上传到一个其他图床https://i.loli.net上面去，我的就上传到这个上面去了，设置为默认的就会直接上传到自己的图床(如果配置没有问题的话);
结束 谢谢光临，若觉得还行麻烦点一下赞，若觉得写得垃圾，欢迎批评指正。笔者知道自己文笔和表达能力很弱，如果您可以提供点宝贵的意见不胜感激。谢谢。
今天也可以是元气满满的一天哦。</description>
    </item>
    
    <item>
      <title>Python入门搞事</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/python/python%E5%85%A5%E9%97%A8%E6%90%9E%E4%BA%8B/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/python/python%E5%85%A5%E9%97%A8%E6%90%9E%E4%BA%8B/</guid>
      <description>前言 之前无聊逛github的时候，发现了一个Python爬虫的教程库，于是顺手点了一个赞。这里贴一下:https://github.com/wistbean/learn_python3_spider 。今年打算努力下，所以TODO 写了一大堆，然后专升本也要在线学习，晚上去学校上课，还要备考英语，Android 技术方向上又整了一个在线课程，虽然最近没有啥事情，但是总感觉事情整不完，特别是在线学习的这个调调，认真听吧，不好说，挂课吧，不会js,然后之前的也用不起了，手动点吧，一分钟一点，这一天天的就啥事情不用干了。本着能多学一点是一点的态度，我决定通过selenium，看看自己能不能整一个挂课脚本出来。
话说这个调调 selenium 是web的自动化测试工具。emmm ?好像支持JAVA，ok python 先放下了，我大JAVA 要起来了。
顺便推一下博客主页
结束 谢谢光临，若觉得还行麻烦点一下赞，若觉得写得垃圾，欢迎批评指正。笔者知道自己文笔和表达能力很弱，如果您可以提供点宝贵的意见不胜感激。谢谢。
今天也可以是元气满满的一天哦。 更新需要审核。更新通常优先更新到gitee上面。
博客主页</description>
    </item>
    
    <item>
      <title>噢，先立点FLAG</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/todo/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/todo/</guid>
      <description>TODO  噢，先立flag再说。
 android  Android intent 保存参数与fragment 子fragment 互用。 fragment 无限套娃，是否可以在activity层判断fragment是否包含显示？ Android 加锁 通过手写array 备份activity 批量移除activity与通过intent 设置tag移除activity的区别。 探讨通过加锁机制，统一loading层延时关闭view。 摸鱼 dialogFragment dissmiss 之后通过fragmentmanger 还能获取到吗？ 通过加锁机制对轮转控件进行加强。   2021-07-10
  基于计时器Chronometer 实现倒计时 基于spinner 实现下拉dialog 画廊视图Gallery activity 属性 intent broadcastReceiver 键盘事件 手势 toast与界面绑定与toast单例效果。 notification alarmManager 图像，paint,canvas,bitmap,bitmapFactory. 绘制2D图像 动画 openGL 3D 图形 soundPool 播放音轨。 文件流 content Provider 线程与消息处理 service wifi              java  java 各种设计模式 JAVA 新特性  SQL  android room Android room+Rxjava  杂学 python python 爬虫教学地址</description>
    </item>
    
    <item>
      <title>静态网页&#43;Gitee pages 搭建个人主页</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8Egitee-pages-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%BB%E9%A1%B5/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8Egitee-pages-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%BB%E9%A1%B5/</guid>
      <description>前言 话说，今天逛沸点的时候，看到一个大佬在推他的个人主页，感觉很有意思。
这么好的东西，其实我也想要。那么就开整。需要先找到官方文档 ，毕竟官方提供的才是原汁原味的嘛(但是有些人提供的就没有那个味道了)。
但是呢，东西是一个好东西，可惜我不会。gitee 推荐了3中静态网页方案，Jekyll、Hugo、Hexo ，这个，巧了，我又不会。突然想起大学的老师，老师们好像有教静态网页的吧，巧了，我好像没有去上课。
但是，作为一个成年人，敌方这么努力的守水晶，我都要想办法推掉它的人，岂是这种小问题能够阻挡的。
 Jekyll、Hugo、Hexo 究竟是什么？
Jekyll、Hugo、Hexo 是简单的博客形态的静态站点生产机器。它有一个模版目录，其中包含原始文本格式的文档，通过 Markdown 以及 Liquid 转化成一个完整的可发布的静态网站，你可以发布在任何你喜爱的服务器上。Jekyll、Hugo、Hexo 也可以运行在 码云（Gitee.com） Pages 上，也就是说，你可以使用码云的服务来搭建你的仓库页面、博客或者网站，而且是完全免费的。
Jekyll 使用文档：https://www.jekyll.com.cn/docs/home/ Hugo 使用文档：https://gohugo.io/documentation/ Hexo 使用文档：https://hexo.io/docs/
 通过gieee提供的教程，我看了下这个这几个教程，
我觉得作为一个成年人，应该学会及时止损。摸鱼应该比学习这个有意思多了，是吧。但是，静态网页我好像会？
顺便推一下博客目录
正文 反正都是摸鱼，只要不学习JAVA，sql,Android,c，ndk 之类的都应该算摸鱼吧，这么一想，瞬间就有动力了。这个摸鱼的概率大一点，还是建议看官方文档 。先按照步骤来。
 注册一个gitee 账号https://gitee.com/ (有账号的跳过这一步) 通过自己的账号创建一个公开的项目(个人主页搞私有的，别人访问不到);确定有master 分支 在项目的服务中找到gitee pages 点击，按照步骤一步一步的开始gitee pages 。这个时候你就得到了自己的个人主页的域名了。 在对应的文件夹下面创建一个index.html 文件（这样通过域名访问就不会404了） 最后通过 静态网页或Jekyll、Hugo、Hexo等博客主页生成工具实现自己的主页。 把做好的网页更新上去，然后在项目的服务中找到gitee pages 更新自己的主页。  静态网页 通过gitee pages 的文档我们可以知道，要想基于它创建主页需要下面几点：
 静态网页 必须包含index.html  据说，只要不进行网络请求的网页都可以叫静态网页？那可操作性就很大了啊。比如说，可以通过网络上下载静态网页模板，自己魔改。比如说这个是我从模板王上下载的一个个人主页：
本地是可以打开的。我没有修改的情况下，直接更新到gitee上面，通过gitee给我生成的域名打开。
Emmmm? 好像可以，如果打开的网页没有更新到，需要清理下浏览器缓存就好了。
我们来看一下这个网页的结构：
支持多html结构，css,js 等都可以放到外面。emmmm？vue 那是不是也行？ vue 提供的单页应用是不是也可以？这个就需要自己验证了，毕竟我不会这个。我看了下这个界面的代码，这div 太多了吧。我感觉我不行，我还是试试用博客主页生成工具吧。</description>
    </item>
    
    <item>
      <title></title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android-context/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android-context/</guid>
      <description>前言 我去，上午酝酿了半天，吃饭没有保存，白写了这么多字。有点难受。
说正事吧，Context 这个对象几乎贯穿Android 所有事物。而 像Application，Activity 都是其间接子类。而这么屌的还有很多，这里就不一一列举了，直接上google Android Context 。Context 子类这么多，最常用的也就是 Application 和Activity了，而这两个子类都是有生命周期的。那么这两个子类获取到的Context有什么不同呢？
  Application 和Activity都有自己的生命周期，那么获取到的Context 的也是有生命周期的。
  JAVA 继承实现的关系，Application和Activity 无法直接强制转换。
  顺便推一下博客目录
正文 Application Application 通常都需要自己继承一个，然后在AndroidManifest 的Application节点中 对android:name 进行赋值。在Application 中获取 Context 也非常简单，就是它本身了。Application 也提供了2个获取 Context 的方法。
Application 继承于ContextWrapper，getBaseContext()，getApplicationContext()这两个方法都是ContextWrapper 实现的。
getBaseContext()     待完成，这个调调有点复杂，容我捋一捋、
  getApplicationContext()  待完成。这个调调有点复杂，容我捋一捋、  Activity 中获取Application Activity 继承于ContextThemeWrapper，而ContextThemeWrapper 继承于ContextWrapper。这其中的逻辑就很复杂，但是获取方式很简单：
1getApplication(); fragment 中获取Application Fragment 中可以直接获取到Activity，那么获取Application就需要先获取 Activity.
1getActivity().getApplication(); 直接获取Application 1private static Application getApplicationByReflect() { 2 try { 3 @SuppressLint(&amp;#34;PrivateApi&amp;#34;) 4 Class&amp;lt;?</description>
    </item>
    
    <item>
      <title></title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android-%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%BF%85%E9%97%AE%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android-%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%BF%85%E9%97%AE%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
      <description>Android 面试之必问性能优化 对于Android开发者来说，懂得基本的应用开发技能往往是不够，因为不管是工作还是面试，都需要开发者懂得大量的性能优化，这对提升应用的体验是非常重要的。对于Android开发来说，性能优化主要围绕如下方面展开：启动优化、渲染优化、内存优化、网络优化、卡顿检测与优化、耗电优化、安装包体积优化、安全问题等。
1，启动优化 一个应用的启动快慢是能够直接影响用户的使用体验的，如果启动较慢可能会导致用户卸载放弃该应用程序。
1.1 冷启动、热启动和温启动的优化 1.1.1 概念 对于Android应用程序来说，根据启动方式可以分为冷启动，热启动和温启动三种。
 冷启动：系统不存在App进程（如APP首次启动或APP被完全杀死）时启动App称为冷启动。 热启动：按了Home键或其它情况app被切换到后台，再次启动App的过程。 温启动：温启动包含了冷启动的一些操作，不过App进程依然存在，这代表着它比热启动有更多的开销。  可以看到，热启动是启动最快的，温启动则是介于冷启动和热启动之间的一种启动方式。下而冷启动则是最慢的，因为它会涉及很多进程的创建，下面是冷启动相关的任务流程： 1.1.2 视觉优化 在冷启动模式下，系统会启动三个任务：
 加载并启动应用程序。 启动后立即显示应用程序空白的启动窗口。 创建应用程序进程。  一旦系统创建应用程序进程，应用程序进程就会进入下一阶段，并完成如下的一些事情。
 创建app对象 启动主线程(main thread) 创建应用入口的Activity对象 填充加载布局View 在屏幕上执行View的绘制过程.measure -&amp;gt; layout -&amp;gt; draw  应用程序进程完成第一次绘制后，系统进程会交换当前显示的背景窗口，将其替换为主活动。此时，用户可以开始使用该应用程序了。因为App应用进程的创建过程是由手机的软硬件决定的，所以我们只能在这个创建过程中进行一些视觉优化。
1.1.3 启动主题优化 在冷启动的时候，当应用程序进程被创建后，就需要设置启动窗口的主题。目前，大部分的 应用在启动会都会先进入一个闪屏页(LaunchActivity) 来展示应用信息，如果在 Application 初始化了其它第三方的服务，就会出现启动的白屏问题。
为了更顺滑无缝衔接我们的闪屏页，可以在启动 Activity 的 Theme中设置闪屏页图片，这样启动窗口的图片就会是闪屏页图片，而不是白屏。
1 &amp;lt;style name=&amp;#34;AppTheme&amp;#34; parent=&amp;#34;Theme.AppCompat.Light.NoActionBar&amp;#34;&amp;gt; 2 &amp;lt;item name=&amp;#34;android:windowBackground&amp;#34;&amp;gt;@drawable/lunch&amp;lt;/item&amp;gt; //闪屏页图片 3 &amp;lt;item name=&amp;#34;android:windowFullscreen&amp;#34;&amp;gt;true&amp;lt;/item&amp;gt; 4 &amp;lt;item name=&amp;#34;android:windowDrawsSystemBarBackgrounds&amp;#34;&amp;gt;false&amp;lt;/item&amp;gt; 5 &amp;lt;/style&amp;gt; 6复制代码 1.2 代码方面的优化 设置主题的方式只能应用在要求不是很高的场景，并且这种优化治标不治本，关键还在于代码的优化。为了进行优化，我们需要掌握一些基本的数据。
1.2.1 冷启动耗时统计 ADB命令方式 在Android Studio的Terminal中输入以下命令可以查看页面的启动的时间，命令如下：</description>
    </item>
    
    <item>
      <title></title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android%E4%B8%AD%E5%85%B3%E4%BA%8E%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android%E4%B8%AD%E5%85%B3%E4%BA%8E%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>前言 顺便推一下博客目录
结束 谢谢光临，若觉得还行麻烦点一下赞，若觉得写得垃圾，欢迎批评指正。笔者知道自己文笔和表达能力很弱，如果您可以提供点宝贵的意见不胜感激。谢谢。
今天也可以是元气满满的一天哦。 更新需要审核。更新通常优先更新到gitee上面。
博客目录</description>
    </item>
    
    <item>
      <title></title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/room/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96room%E6%9F%A5%E7%9C%8B%E8%A1%A8%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/room/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96room%E6%9F%A5%E7%9C%8B%E8%A1%A8%E7%BB%93%E6%9E%84/</guid>
      <description>前言 顺便推一下日常搬砖sqlite目录 。
接上面内容。因为room会生根据 Database成一个 impl.java 文件，通过这个class可以看到创建表的sql。通过查看sqlite studio 需要把几个文件都复制到同一个文件夹中才可以查看完整的表，我通过room 创建的数据库有.db，.db-shm,.db-wal这3个后缀名文件，然后通过Stetho 发现我的id 竟然有两个，但是在Demo 上加上 Stetho 发现 Stetho获取的有一个rowid。emmmm？感觉情况完全不一样，所以我决定看看。
sqlite 查看工具 之前找到了一篇博客对sqlite 表查看写得很详细的。Android Studio查看SQLite数据库方法大全 .如果是通过Stetho 查看数据库，可能出现一个问题，404或者空白页。这个时候就需要使用一些梯子(科学上网)了，等加载出来之后就不需要了。浏览器直接输入chrome://inspect 找到设备就好。
正文 BasicRxJavaSample 这个Demo的地址 。这个Demo是room+rxjava.众所皆知，数据库的增删改查不应该存在于主线程中。好了我们直接看这个Demo所提供的实体类。
实体类 1@Entity(tableName = &amp;#34;users&amp;#34;) 2public class User { 3 4 @NonNull 5 @PrimaryKey 6 @ColumnInfo(name = &amp;#34;userid&amp;#34;) 7 private String mId; 8 9 @ColumnInfo(name = &amp;#34;username&amp;#34;) 10 private String mUserName; 11 12 @Ignore 13 public User(String userName) { 14 mId = UUID.randomUUID().toString(); 15 mUserName = userName; 16 } 17 18 public User(@NonNull String id, String userName) { 19 this.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/room/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96sqlite%E4%B9%8Broom/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/sqlite/room/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96sqlite%E4%B9%8Broom/</guid>
      <description>前言 欢迎光临。
顺便推一下日常搬砖sqlite目录 。
现在还是主要总结一些简单一点的，太复杂了的还是往后排一下，反正我是记得我留了不少的坑等着填，现在先写这个吧，免得分心又拖更了。
之前有简单的描述了下sqlite的增删改查，google 还是推荐使用room android 的。国内也有很多大佬写的很详细，比如说Android Room 官方指南 这个感觉就很全面详细，我看完我就觉得，这个room 相关的博客我都不用写了，直接复制就好。通过这个大佬的博客呢，我找到了我们的组织 Android 的github 地址。就好比流浪多年的我找到了家的感觉。当然也不是之前不知道，就好比之前不知道家里面有宝贝，突然有一天一个同乡说&amp;quot;我们要拆迁啦，你要回去看看吗？&amp;quot;，我回头一想，&amp;quot;嗯？宝贝？我当初出来打工到处找第3方框架的时候咋没有发现？拆迁了？那我要回去看看&amp;quot;，结果一回去，只见靠近种花家那面墙上已经用红油漆喷了一个不怎么圆的圆。咦，果然是有好宝贝。
说回正题。architecture-components-samples 这个里面就有google 提供的Demo。看到这么多的Demo？我觉得我好像真的没有写room 相关的必要了，要不我给你们说脱口秀？
正文 为啥要使用room 其实，作为用sqlite 一向都是sql 的我再没有写博客之前，我还真的没有仔细想过这个问题。现在比较好友的sqlite的工具还是蛮多的，有点久了，不是这么容易记起来，以后慢慢列举吧。下面还是来说说个人认为的优点吧。
 google 爸爸出品，而且现在已经到Android X了，是Jetpack 重要的一环，也便于升级到Android X，同时jetpack 使用量已经升上去了，出现问题的概率很小，有问题多半是使用有问题。jetpack多半是必会技能，哪怕是面试装杯。 google Demo 在as中导入贼快。可能我这山区才通网，用梯子导别人的Demo都很慢。 通过注解对象关系映射（应该是这个词）不必写创建表的sql，便于表字段约束，同时理解简单很多。同类型的也有好几个。 可以更加简单实现一表一数据库文件。对于哪些不常用的功能表可以整合到单独的数据库文件中，当然直通过SQLiteOpenHelper也可以达到这个效果。更新还是需要每个自己更新，个人感觉分数据库写处理更新逻辑要清晰很多。 通过 dao 注解 便于功能区分，耦合要低很多。通过自己写interface也可以实现。 不要杠，人家提供规则是为了使用方便，而不是为了找到其他相同效果的不同写法。个人感觉最主要的是jetpack，用这个如果想，可以把jetpack 所有组件都用上了。 sqlite 的查询可以直接写到主线程中，而room的相关操作抖需要写到子线程中，所以还可以学一盘rxjava ? 按照道理讲，数据库的读写都应该写到子线程中的。room 中 RoomDatabase 提供了很多约束方法。  好了，代码量和逻辑分化的增加在可以装杯的海量优势面前不值一提。那么我们就可以开整。这篇主要是简单的使用讲解，Demo是基于contentprovidersample
导入room 1def room_version = &amp;#34;1.1.1&amp;#34; 2implementation &amp;#34;android.arch.persistence.room:runtime:$room_version&amp;#34; 3annotationProcessor &amp;#34;android.arch.persistence.room:compiler:$room_version&amp;#34; // use kapt for Kotlin 4// optional - RxJava support for Room 5implementation &amp;#34;android.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/gitee%E5%85%B3%E4%BA%8Ejavadoc%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/gitee%E5%85%B3%E4%BA%8Ejavadoc%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Alibaba旗下android中RecycleView的manger笔记</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/vlayout/alibaba%E6%97%97%E4%B8%8Bandroid%E4%B8%ADrecycleview%E7%9A%84manger%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/vlayout/alibaba%E6%97%97%E4%B8%8Bandroid%E4%B8%ADrecycleview%E7%9A%84manger%E7%AC%94%E8%AE%B0/</guid>
      <description>》 顺便推一下博客主页
前言  话说，android 中recycleView 是一个好东西。阿里巴巴的vlayout 其实了解了很久了，只是没有时间上手写笔记。像首页的聚合界面呀。tab相关的呀都可以用这个实现，当然了他只是提供LayoutManager。 但是也不影响。反正都是搬砖嘛。
阿里巴巴 android vlayout GitHub地址
 正文 结束 </description>
    </item>
    
    <item>
      <title>android上的设计模式</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android%E4%B8%8A%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android%E4%B8%8A%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>》 顺便推一下博客主页
前言  今天写demo的时候，顺便发现了自己对设计模式感觉搞迷糊了。然后就整理一波设计模式。现在android常用的是mvc，mvp,mvvm。其他设计模式先放过了，先不整，主要是用得少。话说面试的时候，一般都会问自己写代码的设计模式，才出来的时候说mvc,基于大佬的代码复制一套mvp,然后基于jetpack说是mvvm.似乎从来没有仔细理解过这几种设计模式的优缺点，为啥要用这些设计模式等等。 为啥用，因为大家都在用，我不用就落伍了，这可能是我这类搬砖工这么用的原因。我记得有大佬在自己博客上说过类似的话.&amp;quot;设计模式，他是一种思维逻辑，而不是一种简单的代码规范，要体验到诸多设计模式的优点，只有自己用得多了，而不是看的多，用得多了才有自己的感悟，否则一直都是代码规范是没法理解到他的优点的“。 内容资料大多数源于百度百科
 正文  android搬砖工，所以基本上从android应用上去理解，如果有理解错误的地方，欢迎指正。
 mvc  经典MVC模式中，M是指业务模型，V是指用户界面，C则是控制器，使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。其中，View的定义比较清晰，就是用户界面。 百度百科MVC
 理解一波  这个调调，感觉更适合当初的jsp和H5开发。要说android上使用，前期开发的时候，一般用别人的框架工具之类的，通常是activity 处理业务模型M，作为Vew用户界面，作为控制器处理事件和网络请求数据缓存之类的。 有将数据处理和事件单独拿到一个类中处理的，我就没有遇到过，拿到一个类处理的，人家都说是高贵的MVP开发了。所以那个时候，m在activity里面，v是activity，c是activity，fragment也是这个样子。view层的压力太大了。 这么久导致一个问题，那就是界面层代码太多了，如果网络请求和数据处理没有进行封装，那也太长了，如果不写注释，接盘的大佬也太惨了。 当然了，在这个基础上也不乏有一些大佬是将数据处理单独到一个class里面的，毕竟后台大佬和自己对M的定义不一样，先写界面就需要数据转换了。 android 的databinding 出来之后，就觉得有必要将事件处理提到一个class里面了。这就有了简单搬代码位置的思路。databinding 的事件处理当然也可以在view里面整。
 MVP  mvp的全称为Model-View-Presenter，Model提供数据，View负责显示，Controller/Presenter负责逻辑的处理。MVP与MVC有着一个重大的区别：在MVP中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，而在MVC中View会直接从Model中读取数据而不是通过 Controller。 百度百科MVP
 理解一波  这个感觉和mvc的控制层抽离方式很像，毕竟网络请求和数据处理也算控制层中的内容。而p层主要的作用就是写数据控制和事件处理，emmmmmm? 起码我点击事件没有拿到P层和C层过。 个人觉得他的View不直接操作M,这个才是这个MVP的特点，毕竟如果是服务器一套模型，本地一套模型，中间转换层就只要写到P层就好了，写的位置统一了，以后也好改一点。 只要将数据处理好，然后通过接口或者eventBus,或者类似的工具收到就行，这么就导致View 层的逻辑很清晰。因为P层进行数据事件处理，和可能出现的两套数据模型，P就承担了和C层一样的功能了。
 MVVM(jetpack)  MVVM是Model-View-ViewModel的简写。它本质上就是MVC 的改进版。MVVM 就是将其中的View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开.
 理解一波  主要还是jetpack 这一套东西太好用了，不用处理生命周期。数据恢复，数据绑定更新。只要按照他的开发规则整，android 开发就简单很多了。不像之前生命周期数据刷新都要代码控制。当然也有大佬写过很严谨的代码，主要萌新可能会有疏漏。 之前的P或者C都是将事件处理和数据，现在改到ViewModel 中了，当然了，viewModel 可以只是处理事件，然后再搞一个子类，单独处理网络请求和数据缓存，然后回调到viewModel 中，因为ViewModel 是进行事件的，所以，数据M应该让View使用就好，由ViewModel持有更新。如果将M数据放到View中和MVC又有什么区别。
 结合实际  上面的主要是个人总结的理论东西，然后实际情况，可能有点出入。
 mvc  如果是view 持有Model，充当C,那就没有必要整了。小项目感觉通常就是这么整的，逻辑不复杂，也不需要太多的事件，不处理太多的数据处理。过于复杂的地方也可以将复杂的逻辑数据化，单独写一个类处理这些东西。单独写的这个类可能和View一起充当C层了。</description>
    </item>
    
    <item>
      <title>android中使用Rxjava实现事件重复控制笔记</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/android%E4%B8%AD%E5%9F%BA%E4%BA%8Erxjava%E5%AE%9E%E7%8E%B0%E4%BA%8B%E4%BB%B6%E9%87%8D%E5%A4%8D%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/android%E4%B8%AD%E5%9F%BA%E4%BA%8Erxjava%E5%AE%9E%E7%8E%B0%E4%BA%8B%E4%BB%B6%E9%87%8D%E5%A4%8D%E6%8E%A7%E5%88%B6/</guid>
      <description>》 顺便推一下博客主页
前言 资料 Rxjava Android 版本 github 地址 Rxjava 地址 Rxjava 官方文档地址 Rxjava javaDoc地址 RxBinding GitHub地址
QWQ  android搬砖久了，也慢慢习惯了。最近发现自己对重复点击，或者方法重复调用就没有整理过，使用方式也大概是需要处理的地方处理。通常是记一个时间，然后算两个时间。点击事件倒是封装了简单的。方法调用全靠逻辑控制。 IDEA你已经是成熟的编辑器了，该学会自己写代码了。最近搬砖的时候，发现项目中竟然有Rxjava和Rxbinding.emmmmmm?竟然有这个。那么事件重复不就解决了，别问，问就是才入坑。
 正文 点击事件重复 话说这个简单。基于rxjava 的操作符 debounce 就可以实现了。debounce主要是做拦截处理的。处理逻辑，只要当前对象在某个时间段内重复发送onNext,那么就不发送，最简单的逻辑就是，他其实可以看做一个延时发送onNext功能，发送了onNext，会排到一个队列中，当最后一个在时间段内没有被其他onNext顶替的时候才会回调到监听方法中，如同是最后一下onNext 延时回调了。具体的可以参考rxjava.rxJava会在后面整理。当然了实现重复过滤的操作还是蛮多的，你说我只要第一个，不要其他的，换操作符就行，本笔记主要是整理思路。
rxbinding 使用  因为这个时间可能是需要固定的，不想每个都改，然后写成static 需要注明生产消费线程，否则会拉去不到线程，无法操作UI.
 1public static void clicks(View view, Consumer onNext){ 2 RxView.clicks(view).debounce(300, TimeUnit.MILLISECONDS).subscribeOn(AndroidSchedulers.mainThread()).observeOn(AndroidSchedulers.mainThread()).subscribe(onNext); 3} 当然了，大佬提供了其他的，就需要自己去看了，详细的后面（后面就不知道会排到什么时候）会整理到笔记中。
方法调用重复(抛弃前面的使用最后面的)  看了rxbinding的使用，发现他就自定义 Observable，然后在里面调用 onNext,然后，瞬间觉得，这个调调，我还是可以的。然后开整。
 因为方法调用重复，一般就是将需要过滤的方法放到监听后执行。在方法调用的前置条件中去执行onNext.emmmmm?这不就是普通的Rxjava的使用吗？既然大佬都自己定义了一个Observable，那我也要自己整一个。这个地方可能就需要涉及到一个逻辑了，他发送者和消费者是对应的，那么你在一个方法中实现发送者和消费者的监听，然后不停的调用哪个方法，也达不到重复使用的目的呀，所以这个发送者消费者关联是不是就应该只执行一次，通过onNext多次调用达到效果。
还有一个问题，onNext执行前的代码可能相同，是不是也需要单独提到一个方法中然后再调用onNext呢。
前置执行方法 1@FunctionalInterface 2public interface DggFunction { 3 void apply(); 4} 自定义 Observable 1/** 2 * @author:yangfan 3 * @date: 2021/3/11 20:28 4 * @description: 这个主要是提供一个方法使用的 Observable。在调用 DggFunction中的apply时候，发送 onNext 5 * @update: [ 2021/3/11] [更改人] [更改内容] 6 **/ 7public class FunctionObservable extends Observable&amp;lt;DggFunction&amp;gt; { 8 DggFunction dggFunction; 9 Observer observer; 10 11 public FunctionObservable(DggFunction dggFunction) { 12 this.</description>
    </item>
    
    <item>
      <title>android滚动事件相关-1</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android%E6%BB%9A%E5%8A%A8%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E7%9B%B8%E5%85%B31/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android%E6%BB%9A%E5%8A%A8%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E7%9B%B8%E5%85%B31/</guid>
      <description>》 顺便推一下博客主页
前言  现在第3方的或者android自己的写的太好了。导致大多数情况下，滑动处理都不需要自己处理了，比如说吸顶效果。比如说两个滚动view联动。 参考资料
 正文  比如说吸顶效果的实现方式有多种，感觉最完美的CoordinatorLayout。
  CoordinatorLayout是android support design推出的新布局，主要用于作为视图根布局以及协调子控件的行为，而Behavior就是用于直接子控件来协调自身CoordinatorLayout以及和其他子控件的关系，使用Behavior的控件必须是直接从属于CoordinatorLayout。 在传统的事件分发流程中，在子控件处理事件过程中，父控件是可以进行拦截的，但一旦父控件进行拦截，那么这次事件只能由父控件处理，而不能再由子控件处理了。
  在android5.0之后新的嵌套滑动机制中，引入了：NestScrollChild和NestedScrollingParent两个接口，用于协调子父控件滑动状态，而CoordinatorLayout实现了NestedScrollingParent接口，在实现了NestScrollChild这个接口的子控件在滑动时会调用NestedScrollingParent接口的相关方法，将事件发给父控件，由父控件决定是否消费当前事件，在CoordinatorLayout实现的NestedScrollingParent相关方法中会调用Behavior内部的方法。 我们实现Behavior的方法，就可以嵌入整个CoordinatorLayout所构造的嵌套滑动机制中，可以获取到两个方面的内容：
  1、某个view监听另一个view的状态变化，例如大小、位置、显示状态等 需要重写layoutDependsOn和onDependentViewChanged方法
  2、某个view监听CoordinatorLayout内NestedScrollingChild的接口实现类的滑动状态 重写onStartNestedScroll和onNestedPreScroll方法。注意：是监听实现了NestedScrollingChild的接口实现类的滑动状态，这就可以解释为什么不能用ScrollView而用NestScrollView来滑动了。
 所以可以定义两种。
 NestScrollChild和NestedScrollingParent两个接口，用于协调子父控件滑动状态 在CoordinatorLayout中实现Behavior  结束 </description>
    </item>
    
    <item>
      <title>Android相关代码模板</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E9%A1%B6%E5%91%B1%E5%91%B1android%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E9%A1%B6%E5%91%B1%E5%91%B1android%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/</guid>
      <description>正文  基于DGG Android base 生成，activity,lazyFragment,fragment等等。 https://freemarker.apache.org/docs/index.html
 文件  MVVM(DGG)Activity activity模板 MVVM(DGG)Fragment fragment模板，提供lazyfragment模板和fragment模板  Activity生成内容  基于mvvm 的activity viewModel viewRequest layout(databinding 外部层)  fragment相关生成类型  可选lazyFragment和fragment viewModel viewRequest layout(databinding 外部层)  其他  生成的文件中，提供时间和作者注释。现在作者默认为“Android大佬” 命名采用驼峰命名法，资源文件自动转为下划线命名。  存放  mac /Applications/IntelliJ\ IDEA.app/Contents/plugins/android/lib/templates/activities 这个目录是存放activity模板 mac /Applications/IntelliJ\ IDEA.app/Contents/plugins/android/lib/templates/fragments 这个目录是存放fragment模板 Windows 类似。应用安装路径/plugins/android/lib/templates/activities windows 下Android studio 可能没有这个目录，但是IDEA 有这个目录。  打包  暂时不提供打包为插件内容，使用需要手动放置到对应目录。放置后需要重启编辑器。编辑器更新卸载重装后需要手动放置。 Android studio 4.1以上版本 不支持这种方式导入模板。 Android studio 4.1及其以上版本 需要采用 https://github.com/xiaowifi/dgg_android_code_template 这个项目的主模板创建。并且生成jar使用。
 联系 yangfan6@dgg.</description>
    </item>
    
    <item>
      <title>Coordinatorlayout简单单层吸顶效果</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/coordinatorlayout%E7%AE%80%E5%8D%95%E5%8D%95%E5%B1%82%E5%90%B8%E9%A1%B6%E6%95%88%E6%9E%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/coordinatorlayout%E7%AE%80%E5%8D%95%E5%8D%95%E5%B1%82%E5%90%B8%E9%A1%B6%E6%95%88%E6%9E%9C/</guid>
      <description>》 顺便推一下博客主页
前言 1 &amp;lt;androidx.coordinatorlayout.widget.CoordinatorLayout 2 android:id=&amp;#34;@+id/coordinator&amp;#34; 3 android:layout_width=&amp;#34;match_parent&amp;#34; 4 android:layout_height=&amp;#34;match_parent&amp;#34;&amp;gt; 5 6 &amp;lt;!--AppBarLayout继承自LinearLayout--&amp;gt; 7 &amp;lt;androidx.core.widget.NestedScrollView 8 app:layout_behavior=&amp;#34;com.google.android.material.appbar.AppBarLayout$ScrollingViewBehavior&amp;#34; 9 android:layout_width=&amp;#34;match_parent&amp;#34; 10 android:layout_height=&amp;#34;match_parent&amp;#34;&amp;gt; 11 &amp;lt;LinearLayout 12 android:orientation=&amp;#34;vertical&amp;#34; 13 android:layout_width=&amp;#34;match_parent&amp;#34; 14 android:layout_height=&amp;#34;match_parent&amp;#34;&amp;gt; 15 &amp;lt;TextView 16 android:background=&amp;#34;#03A9F4&amp;#34; 17 android:layout_marginTop=&amp;#34;10dp&amp;#34; 18 android:layout_width=&amp;#34;match_parent&amp;#34; 19 android:layout_height=&amp;#34;45dp&amp;#34;/&amp;gt;&amp;lt;TextView 20 android:background=&amp;#34;#03A9F4&amp;#34; 21 android:layout_marginTop=&amp;#34;10dp&amp;#34; 22 android:layout_width=&amp;#34;match_parent&amp;#34; 23 android:layout_height=&amp;#34;45dp&amp;#34;/&amp;gt;&amp;lt;TextView 24 android:background=&amp;#34;#03A9F4&amp;#34; 25 android:layout_marginTop=&amp;#34;10dp&amp;#34; 26 android:layout_width=&amp;#34;match_parent&amp;#34; 27 android:layout_height=&amp;#34;45dp&amp;#34;/&amp;gt;&amp;lt;TextView 28 android:background=&amp;#34;#03A9F4&amp;#34; 29 android:layout_marginTop=&amp;#34;10dp&amp;#34; 30 android:layout_width=&amp;#34;match_parent&amp;#34; 31 android:layout_height=&amp;#34;45dp&amp;#34;/&amp;gt;&amp;lt;TextView 32 android:background=&amp;#34;#03A9F4&amp;#34; 33 android:layout_marginTop=&amp;#34;10dp&amp;#34; 34 android:layout_width=&amp;#34;match_parent&amp;#34; 35 android:layout_height=&amp;#34;45dp&amp;#34;/&amp;gt;&amp;lt;TextView 36 android:background=&amp;#34;#03A9F4&amp;#34; 37 android:layout_marginTop=&amp;#34;10dp&amp;#34; 38 android:layout_width=&amp;#34;match_parent&amp;#34; 39 android:layout_height=&amp;#34;45dp&amp;#34;/&amp;gt;&amp;lt;TextView 40 android:background=&amp;#34;#03A9F4&amp;#34; 41 android:layout_marginTop=&amp;#34;10dp&amp;#34; 42 android:layout_width=&amp;#34;match_parent&amp;#34; 43 android:layout_height=&amp;#34;45dp&amp;#34;/&amp;gt;&amp;lt;TextView 44 android:background=&amp;#34;#03A9F4&amp;#34; 45 android:layout_marginTop=&amp;#34;10dp&amp;#34; 46 android:layout_width=&amp;#34;match_parent&amp;#34; 47 android:layout_height=&amp;#34;45dp&amp;#34;/&amp;gt;&amp;lt;TextView 48 android:background=&amp;#34;#03A9F4&amp;#34; 49 android:layout_marginTop=&amp;#34;10dp&amp;#34; 50 android:layout_width=&amp;#34;match_parent&amp;#34; 51 android:layout_height=&amp;#34;45dp&amp;#34;/&amp;gt;&amp;lt;TextView 52 android:background=&amp;#34;#03A9F4&amp;#34; 53 android:layout_marginTop=&amp;#34;10dp&amp;#34; 54 android:layout_width=&amp;#34;match_parent&amp;#34; 55 android:layout_height=&amp;#34;45dp&amp;#34;/&amp;gt;&amp;lt;TextView 56 android:background=&amp;#34;#03A9F4&amp;#34; 57 android:layout_marginTop=&amp;#34;10dp&amp;#34; 58 android:layout_width=&amp;#34;match_parent&amp;#34; 59 android:layout_height=&amp;#34;45dp&amp;#34;/&amp;gt;&amp;lt;TextView 60 android:background=&amp;#34;#03A9F4&amp;#34; 61 android:layout_marginTop=&amp;#34;10dp&amp;#34; 62 android:layout_width=&amp;#34;match_parent&amp;#34; 63 android:layout_height=&amp;#34;45dp&amp;#34;/&amp;gt;&amp;lt;TextView 64 android:background=&amp;#34;#03A9F4&amp;#34; 65 android:layout_marginTop=&amp;#34;10dp&amp;#34; 66 android:layout_width=&amp;#34;match_parent&amp;#34; 67 android:layout_height=&amp;#34;45dp&amp;#34;/&amp;gt;&amp;lt;TextView 68 android:background=&amp;#34;#03A9F4&amp;#34; 69 android:layout_marginTop=&amp;#34;10dp&amp;#34; 70 android:layout_width=&amp;#34;match_parent&amp;#34; 71 android:layout_height=&amp;#34;45dp&amp;#34;/&amp;gt;&amp;lt;TextView 72 android:background=&amp;#34;#03A9F4&amp;#34; 73 android:layout_marginTop=&amp;#34;10dp&amp;#34; 74 android:layout_width=&amp;#34;match_parent&amp;#34; 75 android:layout_height=&amp;#34;45dp&amp;#34;/&amp;gt;&amp;lt;TextView 76 android:background=&amp;#34;#03A9F4&amp;#34; 77 android:layout_marginTop=&amp;#34;10dp&amp;#34; 78 android:layout_width=&amp;#34;match_parent&amp;#34; 79 android:layout_height=&amp;#34;45dp&amp;#34;/&amp;gt;&amp;lt;TextView 80 android:background=&amp;#34;#03A9F4&amp;#34; 81 android:layout_marginTop=&amp;#34;10dp&amp;#34; 82 android:layout_width=&amp;#34;match_parent&amp;#34; 83 android:layout_height=&amp;#34;45dp&amp;#34;/&amp;gt;&amp;lt;TextView 84 android:background=&amp;#34;#03A9F4&amp;#34; 85 android:layout_marginTop=&amp;#34;10dp&amp;#34; 86 android:layout_width=&amp;#34;match_parent&amp;#34; 87 android:layout_height=&amp;#34;45dp&amp;#34;/&amp;gt; 88 &amp;lt;/LinearLayout&amp;gt; 89 &amp;lt;/androidx.</description>
    </item>
    
    <item>
      <title>Coordinatorlayout简单单层吸顶效果</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/coordinatorlayout%E7%AE%80%E5%8D%95%E5%A4%9A%E5%B1%82%E5%90%B8%E9%A1%B6%E6%95%88%E6%9E%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/coordinatorlayout%E7%AE%80%E5%8D%95%E5%A4%9A%E5%B1%82%E5%90%B8%E9%A1%B6%E6%95%88%E6%9E%9C/</guid>
      <description>》 顺便推一下博客主页
前言 1 &amp;lt;androidx.coordinatorlayout.widget.CoordinatorLayout 2 android:id=&amp;#34;@+id/coordinator&amp;#34; 3 android:layout_width=&amp;#34;match_parent&amp;#34; 4 android:layout_height=&amp;#34;match_parent&amp;#34;&amp;gt; 5 6 &amp;lt;!--AppBarLayout继承自LinearLayout--&amp;gt; 7 &amp;lt;androidx.coordinatorlayout.widget.CoordinatorLayout 8 app:layout_behavior=&amp;#34;com.google.android.material.appbar.AppBarLayout$ScrollingViewBehavior&amp;#34; 9 android:layout_width=&amp;#34;match_parent&amp;#34; 10 android:layout_height=&amp;#34;match_parent&amp;#34;&amp;gt; 11 12 &amp;lt;androidx.core.widget.NestedScrollView 13 app:layout_behavior=&amp;#34;com.google.android.material.appbar.AppBarLayout$ScrollingViewBehavior&amp;#34; 14 android:layout_width=&amp;#34;match_parent&amp;#34; 15 android:layout_height=&amp;#34;match_parent&amp;#34;&amp;gt; 16 &amp;lt;LinearLayout 17 android:orientation=&amp;#34;vertical&amp;#34; 18 android:layout_width=&amp;#34;match_parent&amp;#34; 19 android:layout_height=&amp;#34;match_parent&amp;#34;&amp;gt; 20 &amp;lt;TextView 21 android:layout_marginTop=&amp;#34;1dp&amp;#34; 22 android:background=&amp;#34;#673AB7&amp;#34; 23 android:gravity=&amp;#34;center&amp;#34; 24 android:text=&amp;#34;!!!!!!!!!!!!!&amp;#34; 25 android:layout_width=&amp;#34;match_parent&amp;#34; 26 android:layout_height=&amp;#34;45dp&amp;#34;/&amp;gt; &amp;lt;TextView 27 android:layout_marginTop=&amp;#34;1dp&amp;#34; 28 android:background=&amp;#34;#673AB7&amp;#34; 29 android:gravity=&amp;#34;center&amp;#34; 30 android:text=&amp;#34;!!!!!!!!!!!!!&amp;#34; 31 android:layout_width=&amp;#34;match_parent&amp;#34; 32 android:layout_height=&amp;#34;45dp&amp;#34;/&amp;gt; &amp;lt;TextView 33 android:layout_marginTop=&amp;#34;1dp&amp;#34; 34 android:background=&amp;#34;#673AB7&amp;#34; 35 android:gravity=&amp;#34;center&amp;#34; 36 android:text=&amp;#34;!</description>
    </item>
    
    <item>
      <title>Dagger2了解下</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/dagger2%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/dagger2%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B/</guid>
      <description> 顺便推一下博客主页
 正文 </description>
    </item>
    
    <item>
      <title>Dart基础语法</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/dart%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/dart%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</guid>
      <description> 顺便推一下博客主页
 正文 </description>
    </item>
    
    <item>
      <title>Databinding笔记整理呀</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/databinding%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%E5%91%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/databinding%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%E5%91%80/</guid>
      <description>顺便推一下博客主页
 前言  由于现在jetpack的流行，这个还是蛮香的，之前databinding才出来的时候，简单了解过。那个时候还没有写本地entity的习惯，数据都是依赖于服务器模型。现在好了，都是本地模型和服务器模型互转。就没有这个问题了， 这个调调还是可以省很多时间精力的。但是这个就得考验设计能力了，不像之前随便搬砖什么的。
 正文 开启databinding的使用能力  有一段时间迷糊了，以为需要手动导入包什么的。其实只需要配置一下，gradle就帮忙导入了，不需要在dependencies声明。比如像这个样子:
 1// 启用databinding 放到android 下面。 2 android { 3 dataBinding { 4 enabled = true 5 } 6} xml使用  这个调调主要是在xml 中配置数据绑定，事件处理什么的，所以都是操作xml.emmmmmm? 那我viewmodel 不就处理数据了。奈斯.png。还有一个问题，事件还是应该写到界面层吧，但是我决定viewmodel 也可以处理事件来着。 比如说，mvp 的事件就是在p层，但是p层我处理网络请求了，结果事件写到view层，然后事件真实处理就到了界面层。有点晕，M层是啥。 容我捋一捋。mvc中，m是业务逻辑，v是视图也就是界面层，c是中间层进行m和v的联动。mvp中m是业务逻辑数据，v还是视图和界面层，p是数据处理，emmmmm?和C莫得区别吧。百度上说”在MVP中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，而在MVC中View会直接从Model中读取数据而不是通过 Controller。“ 我肯定是没有睡醒，现在C和P傻傻分不清楚了。算了，待会开一个笔记整理一波。
 因为创建的时候，默认不是创建databinding类型的layout,所以需要手动改一下。 打开布局文件，选中根布局的 ViewGroup，按住 Alt + 回车键，点击 “Convert to data binding layout”，就可以生成 DataBinding 需要的布局规则
1&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; 2&amp;lt;layout xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34; 3 xmlns:app=&amp;#34;http://schemas.android.com/apk/res-auto&amp;#34; 4 xmlns:tools=&amp;#34;http://schemas.android.com/tools&amp;#34;&amp;gt; 5 &amp;lt;data&amp;gt; 6 &amp;lt;/data&amp;gt; 7&amp;lt;/layout&amp;gt; 能够在xml中定义什么，完全是看xml支持什么。databinding主要是基于xml 去生成一个class，而不是修改xml.</description>
    </item>
    
    <item>
      <title>fragment嵌套生命周期走查</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/fragment%E5%B5%8C%E5%A5%97%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%B5%B0%E6%9F%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/fragment%E5%B5%8C%E5%A5%97%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%B5%B0%E6%9F%A5/</guid>
      <description>》 顺便推一下博客主页
前言  话说，搬砖过程中fragment+viewpager相当常见。按照道理讲不应该出现这个bug的。主要是太久没有写代码了。emmmmm? 变菜了，能怪我？ 还有一个问题。感觉viewpager+fragment 导致的生命周期就很奇怪，最近有大佬提供的懒加载fragment，so。
 正文  话说，viewpager主要是通过adapter设置预加载数量。
  setOffscreenPageLimit()   然后是通过adapter设置相关的东西
  FragmentPagerAdapter   我们知道viewpager 默认加载3个，就是当前的和左右一边一个。其他的item都会默认销毁。所以我们的懒加载fragment的实现就尤为重要了。
 懒加载fragment  懒加载的实现模式大概就这么一个样子，都很成熟了。
  记录一个fragment中onCreateView 的创建状态。 在onViewCreated中对!isHidden() &amp;amp;&amp;amp; getUserVisibleHint() 进行事件分发。 实现setUserVisibleHint 相关逻辑。 实现onHiddenChanged 可见不可见逻辑。 实现 判断子类可见与否的逻辑。 onResume 实现第一次可见。   整个大概就这个样子:
 1public abstract class BaseLazyFragment extends Fragment { 2 3 /** 4 * mFragmentTag 5 */ 6 public String TAG = &amp;#34;&amp;#34;; 7 /** 8 * mLoadService 9 */ 10 String title; 11 public BaseLazyFragment setShow(String title){ 12 this.</description>
    </item>
    
    <item>
      <title>git使用方式合集</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/git%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E5%90%88%E9%9B%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/git%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E5%90%88%E9%9B%86/</guid>
      <description>顺便推一下博客主页
 git 基础配置 下载git软件: 运行git是在任意目录或桌面下,右键选择git base here 任意目录下打开git输入：
1//初始化个人信息 21.git config --global user.name &amp;#34;你的名字或昵称&amp;#34;	//初始化个人信息 32.git config --global user.email &amp;#34;你的邮箱&amp;#34;	&amp;lt;&amp;lt;第一次提交,把现有项目提交到git仓库： 在当前文件夹下:
11:git init //初始化git仓库 22:git remote add origin xxxxxx.git	//与远程仓库链接 33:git add .	//将本地文件提交到本地仓库 44:git commit -m &amp;#39;new&amp;#39;	//备注提交信息 55:git push origin master -f	//提交到远程仓库 6中间可能需要输入码云的账号和密码,输入即可。&amp;gt;&amp;gt; 如果是把现有git仓库中的项目克隆 在需要存放的盘中
11:git clone xxxxx.git &amp;lt;&amp;lt;上面的两种情况，以后的每次提交：
11:git add .	//将本地文件提交到本地仓库 22:git commit -m &amp;#39;new&amp;#39;	//备注提交信息 33:git push origin master	//提交到远程仓库 github.com已经建立了一个仓库，一个分支，master。现在在本地一个文件中打算初始化一个git项目，并创建两个分支，master对应远程的master，ycl对应远程的ycl。步骤如下：</description>
    </item>
    
    <item>
      <title>git子模块的使用</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/git%E5%AD%90%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/git%E5%AD%90%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>》 顺便推一下博客主页
前言  git子模块的使用
 正文  这个调调主要是为了解决模块来着不同地方，但是要合在一起使用，而且模块代码属于开发迭代的时候，如果每次打包使用
 结束 </description>
    </item>
    
    <item>
      <title>Java反射大杂烩</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96%E4%B9%8Bjava%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96%E4%B9%8Bjava%E5%8F%8D%E5%B0%84/</guid>
      <description>顺便推一下博客主页
 正文  话说，Java 反射还是蛮重要的，但是感觉这个调调破坏了单例模型。但是用着还是很香的，我记得有大佬写过博客说，不建议使用反射来着，找不到了。以后找到了贴出来。 先说用反射图啥，比如说，我只想知道一个类的变量啊。或者我只有类的名称想要变量啊，或者是我想直接调用方法啊，等等。
 利用反射创建fragment  话说，这个可能是Android最常见的反射使用了。使用方式: Class.forName(className).newInstance();
 1private void showBottomFragment() { 2 String className = ApprovalDetailsBottomFragment.class.getName(); 3 try { 4 5 FragmentManager fragmentManager = getSupportFragmentManager(); 6 FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); 7 //隐藏所有的那个啥。 8 for (Fragment fra : fragmentManager.getFragments()) { 9 fragmentTransaction.hide(fra); 10 } 11 Fragment fragmentByTag = fragmentManager.findFragmentByTag(className); 12 if (fragmentByTag != null) { 13 fragmentTransaction.show(fragmentByTag); 14 } else { 15 bottomFragment = (ApprovalDetailsBottomFragment) Class.</description>
    </item>
    
    <item>
      <title>kotlin在Android上的体验</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/kotlin%E5%9C%A8android%E5%BC%80%E5%8F%91%E4%B8%8A%E7%9A%84%E4%BD%93%E9%AA%8C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/kotlin%E5%9C%A8android%E5%BC%80%E5%8F%91%E4%B8%8A%E7%9A%84%E4%BD%93%E9%AA%8C/</guid>
      <description> 顺便推一下博客主页
 正文  之前就整过一个用Java写法写kotlin的项目。感觉嘛，就是没有用到kotlin的优势。虽然现在Java版本感觉挺优雅的(就是很舒服)。但是现在Android中jetpack demo竟然是kotlin写的，那就需要懂kotlin写法了，要不然学习难度会加大的啊。 那么直接开整。其实基础语法都差不多，就整不同点。直接上菜鸟教程。https://www.runoob.com/kotlin/kotlin-tutorial.html
 返回值类型 kotlin是写在方法后的。如果没有返回值就可以不写。
1fun sum(a: Int, b: Int): Int { // Int 参数，返回值 Int 2 return a + b 3} 可变长度传参 vararg 1fun vars(vararg v:Int){ 2 for(vt in v){ 3 print(vt) 4 } 5} 结合lambda 1fun main(args: Array&amp;lt;String&amp;gt;) { 2 val sumLambda: (Int, Int) -&amp;gt; Int = {x,y -&amp;gt; x+y} 3 println(sumLambda(1,2)) // 输出 3 4} </description>
    </item>
    
    <item>
      <title>Mpaas其他组件</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/mpaas/othercomponent/dgg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/mpaas/othercomponent/dgg/</guid>
      <description>##导入包
 mpaas 提供Android studio 插件，在插件中选择使用。
 1// ui 库 2 api &amp;#39;com.mpaas.android:antui&amp;#39; AUTabBarItem  需要通过外层布局包裹，这个只是一个文本加图标的组合体。每个view独立，基础使用无法达到Android中 tablayou 切换时候，底部条平滑滚动的效果。因为相对独立，所以可能出现同时选中两个的情况，需要代码逻辑控制。
 xml 1&amp;lt;com.alipay.mobile.antui.bar.AUTabBarItem 2 android:layout_width=&amp;#34;0dp&amp;#34; 3 android:layout_height=&amp;#34;wrap_content&amp;#34; 4 android:layout_weight=&amp;#34;1&amp;#34; 5 android:clickable=&amp;#34;true&amp;#34; 6 android:text=&amp;#34;标签1&amp;#34; 7 app:topIconSid=&amp;#34;@drawable/tab_icon&amp;#34; /&amp;gt; 自定义属性    属性名 说明 类型     topIconSid 图标 reference   topIconSize 图标大小 dimension   textColor 文字颜色 color，reference    颜色 1&amp;lt;selector xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34;&amp;gt; 2 &amp;lt;item android:state_selected=&amp;#34;true&amp;#34; android:color=&amp;#34;@color/AU_COLOR1&amp;#34; /&amp;gt; 3 &amp;lt;item android:state_focused=&amp;#34;true&amp;#34; android:color=&amp;#34;@color/AU_COLOR1&amp;#34; /&amp;gt; 4 &amp;lt;item android:state_pressed=&amp;#34;true&amp;#34; android:color=&amp;#34;@color/AU_COLOR1&amp;#34; /&amp;gt; 5 &amp;lt;item android:color=&amp;#34;@color/AU_COLOR6&amp;#34;/&amp;gt; 6&amp;lt;/selector&amp;gt; 图标 1&amp;lt;selector xmlns:android=&amp;#34;http://schemas.</description>
    </item>
    
    <item>
      <title>Mpaas其他组件-AUCheckIcon </title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/mpaas/othercomponent/dgg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/mpaas/othercomponent/dgg/</guid>
      <description>##导入包
 mpaas 提供Android studio 插件，在插件中选择使用。
 1// ui 库 2 api &amp;#39;com.mpaas.android:antui&amp;#39; 正文  https://help.aliyun.com/document_detail/71740.html?spm=a2c4g.11186623.6.1505.535331de0J0Ddm 基于android.widget.CheckBox。
 AUCheckIcon  AUCheckIcon 组件用于实现选择框的 IconView。的意思是图标需要通过 IconView类似的设置吗，但是IconView 的设置图标是setIconByName.
 xml 1 &amp;lt;com.alipay.mobile.antui.common.AUCheckIcon 2 android:id=&amp;#34;@+id/au_check_icon&amp;#34; 3 android:layout_width=&amp;#34;45dp&amp;#34; 4 android:layout_height=&amp;#34;45dp&amp;#34;/&amp;gt; 设置 1/**选中状态*/ 2public static final int STATE_CHECKED = 0x01; 3/**未选中状态*/ 4public static final int STATE_UNCHECKED = 0x02; 5/**不可取消勾选状态*/ 6public static final int STATE_CANNOT_UNCHECKED = 0x03; 7/**不可勾选状态*/ 8public static final int STATE_CANNOT_CHECKED = 0x04; 9/** 10* 设置 checkIcon 的状态 11* @param state 12*/ 13public void setIconState(int state); 14/** 15* 获取checkIcon的状态 16* @return 17*/ 18public int getIconState() ; 样式  采用checkbox button style 在xml中设置 checked 会有状态切换效果，通过Java 代码设置未发现更改样式。 可能还是和颜色配置有关，通过配置正确的style 可能达到修改的样式效果。</description>
    </item>
    
    <item>
      <title>Mpaas其他组件-切换栏组件</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/mpaas/othercomponent/dgg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/mpaas/othercomponent/dgg/</guid>
      <description>##导入包
 mpaas 提供Android studio 插件，在插件中选择使用。
 1// ui 库 2 api &amp;#39;com.mpaas.android:antui&amp;#39; 切换栏组件  com.alipay.mobile.antui.segement.AUSegment
 自定义属性 10.0.20 及以后版本添加了 scroll 属性。
   属性名 用途 类型     tabCount Tab 数量(如果说这个值定义为2，但是tab数量有3个，只会显示前两个tab)，不设置这个可能不会均分父布局 integer   tab1Text Tab1 文案 string，reference   tab2Text Tab1 文案 string，reference   tab3Text Tab3 文案 string，reference   tab4Text Tab4 文案 string，reference   tabTextArray Tab 文本数组 string，reference   uniformlySpaced 是否自适应 boolean   tabTextColor 文字颜色 reference，color   tabTextSize 文字大小 dimension   buttomLineColor 底部线条颜色 color，reference   scroll 是否支持滚动 boolean   add 显示一个（+）的tab ,默认位于右边，默认值为false，可以自定义图标，只有基础事件，通过getAddIcon() 设置事件等，比如说点击，长按等等。 boolean    style 1&amp;lt;declare-styleable name=&amp;#34;Segment&amp;#34;&amp;gt; 2 &amp;lt;attr name=&amp;#34;tabCount&amp;#34; format=&amp;#34;integer&amp;#34; /&amp;gt; 3 &amp;lt;attr name=&amp;#34;tab1Text&amp;#34; format=&amp;#34;string|reference&amp;#34; /&amp;gt; 4 &amp;lt;attr name=&amp;#34;tab2Text&amp;#34; format=&amp;#34;string|reference&amp;#34; /&amp;gt; 5 &amp;lt;attr name=&amp;#34;tab3Text&amp;#34; format=&amp;#34;string|reference&amp;#34; /&amp;gt; 6 &amp;lt;attr name=&amp;#34;tab4Text&amp;#34; format=&amp;#34;string|reference&amp;#34; /&amp;gt; 7 &amp;lt;attr name=&amp;#34;tabTextArray&amp;#34; format=&amp;#34;string|reference&amp;#34; /&amp;gt; 8 &amp;lt;attr name=&amp;#34;uniformlySpaced&amp;#34; format=&amp;#34;boolean&amp;#34; /&amp;gt; 9 &amp;lt;attr name=&amp;#34;tabTextColor&amp;#34; format=&amp;#34;color&amp;#34; /&amp;gt; 10 &amp;lt;attr name=&amp;#34;tabTextSize&amp;#34; format=&amp;#34;dimension&amp;#34; /&amp;gt; 11 &amp;lt;attr name=&amp;#34;buttomLineColor&amp;#34; format=&amp;#34;color|reference&amp;#34; /&amp;gt; 12 &amp;lt;attr name=&amp;#34;scroll&amp;#34; format=&amp;#34;boolean&amp;#34; /&amp;gt; 13 &amp;lt;attr name=&amp;#34;repeatClick&amp;#34; format=&amp;#34;boolean&amp;#34; /&amp;gt; 14 &amp;lt;attr name=&amp;#34;add&amp;#34; format=&amp;#34;boolean&amp;#34; /&amp;gt; 15 &amp;lt;attr name=&amp;#34;tabSpace&amp;#34; format=&amp;#34;dimension&amp;#34; /&amp;gt; 16 &amp;lt;attr name=&amp;#34;edgeSpace&amp;#34; format=&amp;#34;dimension&amp;#34; /&amp;gt; 17 &amp;lt;/declare-styleable&amp;gt; 参考内容  activity ：com.</description>
    </item>
    
    <item>
      <title>Mpaas其他组件-刷新</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/mpaas/othercomponent/dgg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/mpaas/othercomponent/dgg/</guid>
      <description>##导入包
 mpaas 提供Android studio 插件，在插件中选择使用。
 1// ui 库 2 api &amp;#39;com.mpaas.android:antui&amp;#39; 刷新组件  AURefreshListView 这个本身就是一个listview. AUPullRefreshView 这个是一个容器，需要内部添加。  AURefreshListView xml 使用，本身就是一个listview.不用内部填充listview.
1 &amp;lt;com.alipay.mobile.antui.load.AURefreshListView 2 android:id=&amp;#34;@+id/refresh_list&amp;#34; 3 android:layout_width=&amp;#34;match_parent&amp;#34; 4 android:layout_height=&amp;#34;match_parent&amp;#34;/&amp;gt; 方法  关闭刷新头和加载更多都需要在ui线程中使用。
  setLoadingText 这个是下拉刷新未松手的自定义文本。 setLoadingView 提供修改刷新头的背景和刷新头样式，提供两种样式。比如说：AntLoadingView.STYLE_WHITE  1 AntLoadingView 2 public static final java.lang.String STYLE_BLUE = &amp;#34;_BLUE&amp;#34;; 3 public static final java.lang.String STYLE_WHITE = &amp;#34;_WHITE&amp;#34;;  setLoadingView 传入自定义的loadingview. setOnLoadMoreListener 设置加载更多监听。 updateLoadMore(isShowLoad,hasMore) 在ui线程调用 setOnPullRefreshListener 刷新监听 finishRefresh() 关闭刷新。UI 线程调用。 setLoadingView() 和设置加载刷新头样式差不多。  自定义刷新头实例代码  参考AntLoadingView。 加载更多类似。</description>
    </item>
    
    <item>
      <title>Mpaas其他组件-图标</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/mpaas/othercomponent/dgg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/mpaas/othercomponent/dgg/</guid>
      <description>##导入包
 mpaas 提供Android studio 插件，在插件中选择使用。
 1// ui 库 2 api &amp;#39;com.mpaas.android:antui&amp;#39; AUIconView  资源化的图标和阿里提供的图标。两种使用图标方式。
AUIconView 为 iconfont 矢量图控件，可以同时实现 TextView 及 ImageView 的功能。
iconfont 图片控件（可当做 TextView 来使用）实际是通过 TextView 的 TTF 字体文件，定义特殊的 Unicode 码对应一类图片字体。也就是说，iconfont 相当于是加载了一个字体，一个字体对应了多张图片，每个图片有一个 Unicode 码。
每个 iconfont 集合实际就是一个 TTF 字体文件，因此可以加载多个 TTF 字体文件。每个 TTF 字体文件有一个名称，默认 AntUI 的 TTF 字体文件名称为 auiconfont。
 图标资源    资源 ID 对应的示例名称     com.alipay.mobile.antui.R.string.iconfont_more 更多   com.alipay.mobile.antui.R.string.iconfont_cancel 取消   com.</description>
    </item>
    
    <item>
      <title>Mpaas其他组件-开关组件</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/mpaas/othercomponent/dgg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/mpaas/othercomponent/dgg/</guid>
      <description>##导入包
 mpaas 提供Android studio 插件，在插件中选择使用。
 1// ui 库 2 api &amp;#39;com.mpaas.android:antui&amp;#39; 正文  1package com.alipay.mobile.antui.basic; AUSwitch 2AUSwitch 基于Android Switch ，  修改内容  主要修改内容：
 1 this.setThumbResource(drawable.au_switch_thumb); 2 this.setTrackResource(drawable.au_switch_track); 3 this.setSwitchMinWidth(DensityUtil.dip2px(this.getContext(), 70.0F)); 4 this.setTextOn(&amp;#34; &amp;#34;); 5 this.setTextOff(&amp;#34; &amp;#34;); 6 this.textOn = this.getResources().getString(string.opened); 7 this.textOff = this.getResources().getString(string.closed); xml 使用 1&amp;lt;com.alipay.mobile.antui.basic.AUSwitch 2 android:id=&amp;#34;@+id/change_switch&amp;#34; 3 android:layout_height=&amp;#34;wrap_content&amp;#34; 4 android:layout_width=&amp;#34;wrap_content&amp;#34; 5 android:layout_marginTop=&amp;#34;8dp&amp;#34; 6 android:checked=&amp;#34;false&amp;#34; 7 android:layout_marginBottom=&amp;#34;8dp&amp;#34; 8/&amp;gt; 自定义图片 1AUSwitch change_switch= view.findViewById(R.id.change_switch); 2change_switch.setThumbResource(R.drawable.keyboard_switch); 3change_switch.setThumbResource(R.drawable.keyboard_switch_press); 效果  有点丑，主要是证明他是可以修改的。需要自己约束好这个调调。可能对于圆角类型的switch 不是太友好。</description>
    </item>
    
    <item>
      <title>Mpaas其他组件-按钮</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/mpaas/othercomponent/dgg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/mpaas/othercomponent/dgg/</guid>
      <description>##导入包
 mpaas 提供Android studio 插件，在插件中选择使用。
 1// ui 库 2 api &amp;#39;com.mpaas.android:antui&amp;#39; AUButton 1&amp;lt;com.alipay.mobile.antui.basic.AUButton 2 style=&amp;#34;@style/mainButtonStyle&amp;#34; 3 android:layout_margin=&amp;#34;12dp&amp;#34; 4 android:clickable=&amp;#34;true&amp;#34; 5 android:text=&amp;#34;主要操作 Normal&amp;#34; /&amp;gt;  基于 android.widget.Button
 Style 接口    属性名 说明 tag     mainButtonStyle 页面主按钮 main   subButtonStyle 页面次按钮 sub   warnButtonStyle 警告按钮 warn   assMainButtonStyle 辅助主按钮 ass   assButtonStyle 辅助次按钮 ass   listButtonStyle 列表按钮 list    基于style 自定义样式 1&amp;lt;item name=&amp;#34;android:tag&amp;#34;&amp;gt;main&amp;lt;/item&amp;gt; 这个属性一定要重置，否则自定义样式可能不会生效。</description>
    </item>
    
    <item>
      <title>Mpaas其他组件-换肤</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/mpaas/othercomponent/dgg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/mpaas/othercomponent/dgg/</guid>
      <description>##导入包
 mpaas 提供Android studio 插件，在插件中选择使用。
 1// ui 库 2 api &amp;#39;com.mpaas.android:antui&amp;#39; 前言  说回正题，换肤这个功能，在好多app中都用。因为比较急促的开始整mpaas,导致文档没有看全，我也没有搜索到换肤这个调调。 但是在好多mpaas 控件中，这个调调是可以统一设置的。因为涉及到换肤，所以，控件并没有代码设置这一项。卑微，之前换肤切style不是这么写的。 作为一个老搬砖工了，经验害死人呀。 所有控件中不可更改属性都应该优先查找主题中是否支持修改。而不是考虑用父类原生使用，经验告诉我改不了。
 换肤  作为大厂的东西，mpaas Android 组件中支持 2中换肤模式，一种是全局设置，一种是界面设置。
  全局设置 界面设置  内容资料  在demo中的 package com.alipay.mobile.antui.viewdemo; ChangeSkinActivity有详细介绍。
本笔记也是基于这个activity进行描述扩展。
 换肤存储 1 AUThemeManager.setCurrentThemeKey(AUThemeManager.THEMEKEY_DEFAULT); 2 SharedPreferences sharedPreferences = getSharedPreferences(&amp;#34;com.alipay.mobile.antui&amp;#34;, MODE_MULTI_PROCESS); 3 SharedPreferences.Editor editor = sharedPreferences.edit(); 4 editor.putString(&amp;#34;CurrentThemeKey&amp;#34;, AUThemeManager.THEMEKEY_DEFAULT); 5 editor.commit(); 换肤自定义  换肤是基于Java 代码实现，所以所有的子类都应该继承于 AUAbsTheme。ChangeThemeImpl提供了简单的使用方式。
 key 值来源  AUThemeKey 中包含所以mpaas ui 中支持的换肤的属性。AUAbsTheme中设置主题的key,应该从这个地方来。</description>
    </item>
    
    <item>
      <title>Mpaas其他组件-操作条组件</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/mpaas/othercomponent/dgg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/mpaas/othercomponent/dgg/</guid>
      <description>##导入包
 mpaas 提供Android studio 插件，在插件中选择使用。
 1// ui 库 2 api &amp;#39;com.mpaas.android:antui&amp;#39; AUCardOptionView 1&amp;lt;com.alipay.mobile.antui.basic.AUCardOptionView 2 android:id=&amp;#34;@+id/card_option_view&amp;#34; 3 android:layout_width=&amp;#34;match_parent&amp;#34; 4 android:layout_height=&amp;#34;wrap_content&amp;#34; 5 android:layout_marginTop=&amp;#34;50dp&amp;#34;/&amp;gt; 控件需要代码添加。类型固定，包含，点赞，打赏，评论。 默认是基于父布局均分的。参数私有，无法通过继承等方式增加类型，图标更改应该还是在主题设置中配置。
1public static final java.lang.String TYPE_PRAISE = &amp;#34;praise&amp;#34;; 2public static final java.lang.String TYPE_REWARD = &amp;#34;reward&amp;#34;; 3public static final java.lang.String TYPE_COMMENT = &amp;#34;comment&amp;#34;; // 创建一个子view。
1 AUCardOptionView.CardOptionItem optionItem1 = new AUCardOptionView.CardOptionItem(); 2 optionItem1.type = AUCardOptionView.TYPE_PRAISE; 3 optionItem1.hasClicked = false; 参数设置 1// 这个可以使文本保持不变。 比如说点赞过了，但是文本还是点赞两个字。 2optionView.setViewInfo(optionItems,AUCardOptionView.TEXT_NOT_CHANGE); 1// 这个会计数。没有点赞数的时候显示赞，有赞的时候显示数量。 2optionView.setViewInfo(optionItems); 1 optionView.</description>
    </item>
    
    <item>
      <title>Mpaas其他组件-索引组件</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/mpaas/othercomponent/dgg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/mpaas/othercomponent/dgg/</guid>
      <description>##导入包
 mpaas 提供Android studio 插件，在插件中选择使用。
 1// ui 库 2 api &amp;#39;com.mpaas.android:antui&amp;#39; 3 4 https://help.aliyun.com/document_detail/71741.html?spm=a2c4g.11186623.6.1506.29b84e8a480Z08 正文 1 &amp;lt;com.alipay.mobile.antui.basic.AUBladeView 2 android:layout_width=&amp;#34;24dp&amp;#34; 3 android:layout_height=&amp;#34;wrap_content&amp;#34; 4 app:top1Text=&amp;#34;⊙&amp;#34; 5 app:top2Text=&amp;#34;オ&amp;#34;/&amp;gt; 自定义属性    属性名 说明 类型     top1Text 自定义第一个文本字符 reference   top2Text 自定义第二个文本字符 reference   showSelectPop 是否显示滑动或者点击过程中中间弹出的浮层 boolean    监听 1 /** 2 * 设置字母选中监听 3 */ 4 public void setOnItemClickListener(OnItemClickListener listener) 5 public interface OnItemClickListener { 6 /** 7 * 设置字母选中监听 8 * @param clickChar 点击或者选中的字母 9 */ 10 void onItemClick(String clickChar); 11 /** 12 * 手指抬起的事件，无特殊需求，无需关注此方法 13 */ 14 void onClickUp(); 15 } 分栏   默认加载数据为a到z#。 可以添加两个头，在a 之前。 默认文本应该是12号，#999999的颜色值。   </description>
    </item>
    
    <item>
      <title>Mpaas阿里系列 AntUI初步采坑</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/mpaas/dgg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/mpaas/dgg/</guid>
      <description>前言 顺便推一下博客主页
正文  现在公司决定使用这个调调，然后呢，就是我们需要学习使用这个调调。 Mpaas 阿里文档
   [AntUI]https://help.aliyun.com/document_detail/71733.html?spm=a2c4g.11186623.6.1468.52ca2dedLmEE5H
 导入包  mpaas 提供Android studio 插件，在插件中选择使用。但是还是会存在一些使用问题，比如说不知道这个包是干啥的。所以就是这个笔记存在的意义。
 1// ui 库 2 api &amp;#39;com.mpaas.android:antui&amp;#39; </description>
    </item>
    
    <item>
      <title>Mpaas阿里系列Android使用目录</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/mpaas/dgg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/mpaas/dgg/</guid>
      <description>前言 顺便推一下博客主页
正文  现在公司决定使用这个调调，然后呢，就是我们需要学习使用这个调调。 Mpaas 阿里文档 mpaas 提供Android studio 插件，在插件中选择使用。但是还是会存在一些使用问题，比如说不知道这个包是干啥的。所以就是这个笔记存在的意义。
  这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接   这个能写多少，大概就是我能够狗多久了。加油，还有两年继续狗吧。
 </description>
    </item>
    
    <item>
      <title>Rxbinding学习笔记</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxbinding/rxbinding%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxbinding/rxbinding%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</guid>
      <description>》 顺便推一下博客主页
前言  RxBinding GitHub地址
 正文  主要是自己定义了一个Observable，然后调用Rx相关的api.因为Observable消息的发送就是在Observable中，所以可以自定义Observable 逻辑达到自己想要的效果。
 事件防止重复  因为android 上的pop或者dialog并不是第一时间加载出来的。所以点击事件在逻辑上可能出现点击了很多次，然后弹窗才出现，如果点击事件没有弹窗遮挡事件，那么就可能导致同一个方法或者网络请求被请求了多次，这个就很骚了。 所以点击事件防止重复点击还是蛮重要的。
 现阶段，android都在国内搬砖多年了，各种成熟的方法都有。这篇博客就写的很细《Android处理按钮重复点击事件》 。
 记录调用时间，在某个时间段内可以return。 封装上一个逻辑，然后统一调用。 基于Rxjava的延时等过滤操作符自己实现Observable，然后设置操作符。 Aspectj 这个没有用过。  Rxbinding Rxjava  这个调调主要是提供了一个各种view的Observable。
  debounce  结束   </description>
    </item>
    
    <item>
      <title>Rxjava中过滤相关</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E4%B8%AD%E8%BF%87%E6%BB%A4%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/rxjava/rxjava%E4%B8%AD%E8%BF%87%E6%BB%A4%E7%9B%B8%E5%85%B3/</guid>
      <description>》 顺便推一下博客主页
前言  在应用开发去去抖动还是很有必要的，或者说节流。最常见的就是事件的重复性。比如说方法重复调用，导致对象重复初始化，或者按钮重复点击等等。大体来说就是要过滤一些东西。比如说只是抓取第一次，其他的过滤，也可以是抓取最后一次，前面的 过滤。当然了一般都有时间限制。 比如说 300毫秒呢的重复点击只有一次生效，或者抢东西的时候，第一次生效。当然了，这个调调是可以通过严谨的代码逻辑去控制的，但是，写的地方多了，就烦了。所以说过滤就很重要。过滤掉那些不需要的调用，可以明确逻辑，然后减少些莫名其妙bug.最重要的是防止被搞，比如说，后台大佬没有对请求进行过滤，然后点一下，请求一下，就一直开脚本点，手机不炸我不停止，还是有点恶心人的。还有一些东西，全局就初始化一次，你经常去初始化人家就不行。
 正文 过滤这个调调，在Rxjava 中有两个大的分类。
 throttle 相关的时间控制  Throttle throttleFirst throttleLast throttleWithSelector throttleWithTimeout   一个是发送控制.  Debounce —仅在经过特定时间跨度时才从Observable发出一项，而不发出另一项 Distinct -抑制可观察对象发出的重复项 ElementAt—仅发射可观察对象发射的项目n Filter —仅从可观察对象中发出通过谓词测试的项 First —仅从Observable发射第一项或满足条件的第一项 Last —只发射可观察对象发射的最后一个项目(直接调用，发送next没有监听到回调) Sample —定期发射Observable发射的最新项目 Skip—抑制Observable发出的前n个项目 SkipLast—抑制Observable发出的最后n个项目 Take—仅发射可观察对象发射的前n个项目 TakeLast—只发射可观察对象发射的最后n个项目    其实他们有很多是通用的，比如说Debounce的官方介绍文档和throttle的介绍文档是一样的。区别就在于，一个是基于时间的，一个是基于发送对象的。反正都是要过滤，所以就一套整完整。Rxjava感觉主要的控制Observable 发送消息，比如说:
1observer.onNext(); 2observer.onComplete(); 3observer.onError(); 4observer.onSubscribe(); 无论时间控制还是发送控制，都是基于上面几个方法的。其他的回调，方法什么的没有自定义的地步。通常都是自定义observer，处理发送消息罢了。比如说RxBinding。</description>
    </item>
    
    <item>
      <title>享元模式</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_flyweight_mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_flyweight_mode/</guid>
      <description> 顺便推一下博客主页
 正文  主要详细理解设计模式。感觉这个设计模式蛮重要的。内容来源
 享元模式  运用共享技术来有效的支持大量细粒度对象的复用，他通过共享已经存在的对象来大幅度减少需要创建对象的苏亮，避免大量相似类的开销，从而提高系统资源的利用率。 享元模式的本质是缓存共享对象，降低内存消耗。
 </description>
    </item>
    
    <item>
      <title>代理模式</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_proxy_mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_proxy_mode/</guid>
      <description> 顺便推一下博客主页
 正文  主要详细理解设计模式。感觉这个设计模式蛮重要的。内容来源
 代理模式  由于某些原因，需要给某对象提供一个代理以控制该对象的访问，这时候，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。
  代理模式可以在客户端与目标对象之间起中介作用和保护目标对象。 代理对象可以扩展目标对象功能。  代理模式的应用场景  远程代理，这种方式通常是为了隐藏目标对象，方便客户端访问。 虚拟代理，比如图片很大，可以先在某些场景使用小图。 安全代理，用于控制不同权限的对象访问。虽然工厂模式也行。 延迟加载，通过代理中间层实现等待，和干涉原对象。  代码模式结构  抽象主题subject，通过接口或者抽象类声明真实主题和代理对象的实现的业务方法。 真实主题，real subject,实现了抽象主题中的具体业务，是代理对象所代表的真实对象。 代理proxy,提供了与真实对象的接口，内部包含对真实对象的引用，可以控制，访问，扩展真实对象的功能。  </description>
    </item>
    
    <item>
      <title>关于主页</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/about/</guid>
      <description>用途 当前主页，主要用于本人学习总结笔记。不作为商业用途。
当前主页基于Hugo，由Gitee page 提供服务支持。
采用主题：Clarity 博客主页
主页源码
主页运行位置
感谢Gitee Pages提供静态网页服务。
发布 个人觉得还行的技术类型的笔记会推到掘金等平台。其他笔记就算了。
关于作者 一个普普通通的Android 应用端开发人员，感觉大家会的我可能会。2016年毕业后开始从事Android开发，感谢当时的Android就业环境吧，我从一个懵懵懂懂的boy,混到了现在一个波澜不惊的老油条。主要搬砖工具就是JAVA了,也用过Kotlin写过一个项目。这么多年了，感觉不是在看别人的代码，就是在下载别人代码的路上，也经常摸鱼什么的。
18年算是比较倒霉的一年吧(个人经历太过难受就不分享了)。也就中断了之前的笔记日子。感觉也是这段时间开始认真思考技术和沉淀技术的吧，虽然感觉也没有沉淀到什么，整体来说，思考的深度可能不一样了，慢慢培养去理解别人代码的能力，从会用，到理解写法，到可以改动，到可以半脱离式的尝试写一个类似简单的。这一步步的，别人可能比我走的更快吧。普普通通的，在身边也找不到一个活生生的高点，除了职业不一样，感觉有点抽象，但是人终究是没法挣到认知范围外的钱，技术也一样，基础知识很容易就知道了，这些基础知识如何组装成一个技术，还是需要认知的。整体来说，就是很大佬们知识互动太少了，感觉还是要多参加一些活动。
从16年毕业，出来就开始独立写Android app。虽然是一个现在看起来很简单的项目，也总结了很多问题，比如说，post 请求和git 请求传参，后台接收到的信息可能存储后乱码？解决方式就是改成post.但是baidu却搜索不到。然后开始做直播类型app,当然主要还是第3方云服务支持的那种，国内大多数IM 推送都接入过。后来就是视频播放app，整了一个抖音推荐页效果+广告，然后就是正常的app 列表，列表播放，这个还是遇到很多问题，老板要求换了很多播放器内核，反正android 能用的内核都换过，然后基于这些内核播放器样式界面也写过。然后就是现在的摸鱼日子了。这边主要感觉像一个打杂的角色吧，也不是我主导项目，所以摸鱼时间蛮多了，主要就是捏界面.文件处理，业务功能实现等等，顺便对sqlite和IM 打打杂。
2020 下半年，也才开始打算将有道云笔记转换到博客和个人主页里面。
愿你我安好，愿我顺顺利利的搬砖就好。</description>
    </item>
    
    <item>
      <title>关于代码规范和编码规范</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E5%85%B3%E4%BA%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E5%85%B3%E4%BA%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</guid>
      <description> 顺便推一下博客主页
 正文  其实阿里巴巴提供的代码规范已经很规范了。但是由于一直都是 自己整，配合的蛮少的。所以规范这个东西，就是懂几点，实际上使用的很少。 #阿里巴巴Android技术规范 这个目录下还有一个Java 规范，比如比如包括 数据库查询的时候不适用* 查询所有，而是适用真实的字段，当然，如果全部查询用*和全字段的区别，还没有看，感觉没有什么区别，但是 一个表应该还是有不需要查询出来的字段的。比如说描述什么的。
 代码注释和格式化   之前写代码并不怎么注意这个问题，最近被大佬点化后，发现，格式化是真的好，代码看起来舒服了不少。 然后就是注释，这个调调也很重要，比如说提供给别人使用，比如说时隔多年再去看一个代码，有注释就自己方便，别人方便吧，导出为Javadoc 也完整，以后装逼使用还是蛮好的。 还有一个问题，当你的注释写的详细了，应用内 重复功能才会减少。   然后就是图片处理   压缩处理还是蛮重要，无论是资源文件还是网络资源。在合适的手机尽量使用最小的内存。这么可以减少应用卡顿和提升应用流畅度的。 网络图片缓存，网络图片一般使用框架都缓存了的。所以图片通常只需要显示的时候压缩后显示。 图片选择也是，需要压缩上传。 资源文件，大图放超高清里面。尽量多分辨率适配呗。 图片渲染格式，在忽略透明度的图片中，尽量使用RGB_565   然后是重复事件   Android中对于重复事件还是蛮多的，比如说点击，同一个时间段内，可能只需要一次。那么就可以使用RXjava 防止重复点击。以最后点击生效。 然后就是toast，这个也可以使用Rxjava ,防止重复显示，当然也可以自定义toast。 loading层，这个对于多个网络请求 使用Rxjava 合并请求。   然后是命名   命名就简单了，资源文件就是 模块+功能+类型   最后就是设计模式了  这个很重要。设计模式尽量多用，才可以提升的快、
 </description>
    </item>
    
    <item>
      <title>关于顶呱呱Android应用中baseActivity设计思路</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E9%A1%B6%E5%91%B1%E5%91%B1baseactivity%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E9%A1%B6%E5%91%B1%E5%91%B1baseactivity%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/</guid>
      <description>顺便推一下博客主页
 正文  当前项目 基于AndroidX,使用jetpack为基础设计。使用databinding。
 变量  viewModel jetpack基础。 viewDataBinding databinding LoadService 对于服务器数据进行界面响应切换模块等。需要手动在需要的代码模块注册。 Context 带生命周期上下文，为当前activity。  方法 onCreate  判断getSupportActionBar 是否为空，为空就隐藏 bar. 设置context 注册路由 ARouter 提供初始化之前方法。initContentViewBefore();可重写 提供初始化databinding方法 performDataBinding(); 提供初始化view方法 initView();需要实现。 提供初始化数据方法 initData();需要实现。 提供view监听设置方法 initListener() 需要实现  onDestroy  viewmodule销毁  getLayoutId  需要实现 传递当前layout id
 performDataBinding 1 public void performDataBinding() { 2 viewDataBinding = DataBindingUtil.setContentView(this, getLayoutId()); 3 initViewModel(); 4 viewDataBinding.setLifecycleOwner(this); 5 if (getBindingVariable() &amp;gt; 0) { 6 viewDataBinding.</description>
    </item>
    
    <item>
      <title>关于项目中使用BuildSrc</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E5%85%B3%E4%BA%8E%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8buildsrc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E5%85%B3%E4%BA%8E%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8buildsrc/</guid>
      <description> 顺便推一下博客主页
 正文  2021年2月22日。突然发现发现项目根目录下有一个BuildSrc文件夹，而且没有在setting.gradle中使用。抱着不懂就百度的思想，就开整。 在百度之前，还是简单的看了下里面的内容，好像是gradle 中的配置。之前一般都写在一个base 中，然后导入base ,或者写到一个特定文件中便于统一管理。 但是写到buildScr 中，还是头一次见到，学到了。直接上官网连接。查看buildSrc配置
  复杂的构建逻辑通常很适合作为自定义任务或二进制插件进行封装。自定义任务和插件实现不应存在于构建脚本中。buildSrc只要不需要在多个独立项目之间共享代码，就可以非常方便地使用该代码。 该目录buildSrc被视为包含的构建。发现目录后，Gradle会自动编译并测试此代码，并将其放入构建脚本的类路径中。对于多项目构建，只能有一个buildSrc目录，该目录必须位于根项目目录中。 buildSrc应该比脚本插件更可取，因为它更易于维护，重构和测试代码。 buildSrc使用适用于Java和Groovy项目的相同源代码约定。它还提供对Gradle API的直接访问。其他依赖项可以在专用的build.gradle下声明buildSrc。
 </description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_singleton_mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_singleton_mode/</guid>
      <description> 顺便推一下博客主页
 正文  主要详细理解设计模式。感觉这个设计模式蛮重要的。内容来源
 单例模式 优点 只有一个对象，单线程中，减少内存开销，避免资源多重占用，资源共享。
缺点 扩展困难，多线程操作需要单独处理，单例模式 功能复杂不利于更新维护。
使用  懒汉单例，需要的时候才创建对象 饿汉单例，类加载就创建对象，可以避免多线程创建对象。 对于频繁使用的创建单例。 创建过程消耗巨大的创建单例 数据共享也可以创建单例  </description>
    </item>
    
    <item>
      <title>原型模式</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_prototype_mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_prototype_mode/</guid>
      <description> 顺便推一下博客主页
 正文  主要详细理解设计模式。感觉这个设计模式蛮重要的。内容来源
 原型模式  应用场景,针对大量重复数据，通过new 去创建比较消耗时间。 Java 自带的原型模式基于内存二进制流复制，性能上比new更加优良。 便于实现类似于事务功能，比如撤销什么的。返回上一步什么的。 重新创建成本过大，又不能使用单例的时候。 创建对象需要的流程过于复杂等。
 实现方式  java 中需要将被复制对象实现 Cloneable 接口。对象调用特定方法：clone()实现对象复制。
 </description>
    </item>
    
    <item>
      <title>基于阿里系列的路由工具ARouter</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E5%9F%BA%E4%BA%8E%E9%98%BF%E9%87%8C%E7%B3%BB%E7%9A%84%E8%B7%AF%E7%94%B1%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E5%9F%BA%E4%BA%8E%E9%98%BF%E9%87%8C%E7%B3%BB%E7%9A%84%E8%B7%AF%E7%94%B1%E5%B7%A5%E5%85%B7/</guid>
      <description> 顺便推一下博客主页
 正文  老规矩，还是先贴官网。基于阿里系列的路由工具ARouter
 </description>
    </item>
    
    <item>
      <title>外观模式</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_facade_mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_facade_mode/</guid>
      <description> 顺便推一下博客主页
 正文  主要详细理解设计模式。感觉这个设计模式蛮重要的。内容来源
 外观模式  外观模式是一种通过为多个复杂的子系统提供一个一致的接口，使得子系统更加容易访问。 阿里的路由工具ARouter 应该就是外观模式的较好实现。
 </description>
    </item>
    
    <item>
      <title>工厂模式和抽象工厂模式</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_factory_mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_factory_mode/</guid>
      <description> 顺便推一下博客主页
 正文  主要详细理解设计模式。感觉这个设计模式蛮重要的。内容来源
 工厂模式和抽象工厂模式  这个可能是简单工厂模式的抽象版本。将功能具体化，一个工厂提供同类的服务，一个工厂对应于一个抽象对象接口。
 主要角色:
 抽象产品 (同一类产品的公共属性合集) 具体产品 (继承与抽象产品) 抽象工厂（这个可以不要，直接由具体工厂通过不同的方法返回 抽象产品就好，方法实现具体产品） 具体工厂 （有抽象工厂需要实现抽象工厂，提供不同的方法生产具体产品，返回抽象产品，通常和抽象工厂搭配使用，也可以返回具体产品）  </description>
    </item>
    
    <item>
      <title>建造者模式</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_builder_mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_builder_mode/</guid>
      <description> 顺便推一下博客主页
 正文  主要详细理解设计模式。感觉这个设计模式蛮重要的。内容来源
 建造者模式  建造者模式是指，将一个复杂对象的构造与他的表示分离。使同样的够着过程可以创建不同的表示。 Android 很多就实现了建造者模式。比如弹窗。
  产品角色，他包含多个组成部件的复杂对象，由具体建造者来创建其他各个零部件。 抽象建造者builder。包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法。 具体建造者，实现builder接口，完成复杂产品的各个部件的具体创建方法。 指挥者director，他调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品。  应用场景  建造者模式唯一区别于工厂模式的是针对复杂对象的创建，如果是简单对象，通常使用工厂模式创建，如果是创建复杂对象，就可以考虑使用建造者模式。
  相同的方法，不同的执行顺序，产生不同的结果。 多个部件或者零件，都可以装配到一个对象中，但是产生的结果又不相同。 产品类非常复杂，或者产生类中的不同的调用顺序产生不同的作用。 初始化一个对象特别复杂，参数多，而且很多参数都具有默认值。  建造者模式和工厂模式的区别  建造者模式更加注重方法的调用顺序，工厂模式更加注重对象的创建。 创建对象的力度不同，建造者模式创建复杂对象，由各个复杂部件组成，工厂模式创建出来的对象都是一样的。 关注点不一样，工厂模式只需要创建对象，建造者模式需要创建对象，还要知道部件。 建造者模式根据建造过程顺序不一样，生成的对象部件也不一样。 如果建造者创建的产品类只有一个，只需要一个具体的建造者，可以省略到抽象建造者，甚至可以省略调指挥者。  </description>
    </item>
    
    <item>
      <title>探索 Jetpack 库</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E6%8E%A2%E7%B4%A2-jetpack-%E5%BA%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E6%8E%A2%E7%B4%A2-jetpack-%E5%BA%93/</guid>
      <description>顺便推一下博客主页
 正文  还是老规矩，先上官网 官网 ，然后就是 jetpack 支持些什么。支持与包含 ，最后是找到demo地址，然后拉demo源码 学习了。demo地址 这里就需要着重点一下设计模式了。常见的mvc.mvp,mvvm.而 jetpack 就支持了mvvm.当然也不是说，用了jetpack就不能写MVC不能写mvp了。 但是一个项目中最好固定一种设计模式。一套写法是最好的。而mvvm 只要注释写得好，比其他两个更好维护和阅读。 既然是mvvm.和mvp和mvc 还是有区别的，mvp和mvc Google并没有提供对应的组件，一般都是自己封装，需要注意生命周期什么的。但是mvvm,Google 开始提供对应的组件。同时开始优化开发流程和代码可读性了。
 ViewModel 教程地址 提供数据，这里面可以写的和 P层差不多，获取数据，处理数据什么的。 LiveData 提供数据更新观察能力，和生命周期绑定。和viewModel绑定，而P层大概就是ViewModel+liveDate的集合体。 databinding 主要是负责 界面渲染数据，这个可以少一层，findviewbyid。 然后模块解耦，虽然这个mvvm是一个整体，但是搬砖过程中，难免会遇到 不同模块的子模块有相同的，不解耦的话，就会出现一个东西重复出现调用，虽然可以通过设计模式设置不同的server实现。也可以了解下依赖注入。 最后就是数据缓存 sqlite 和room的使用了。room骚的是 他基本上是一个表一个库，所以需要注意连接池中的连接逻辑，通常只有一个数据库处于连接状态（待确认）。   ViewModel  教程地址 Android 框架可以管理界面控制器（如 Activity 和 Fragment）的生命周期。Android 框架可能会决定销毁或重新创建界面控制器，以响应完全不受您控制的某些用户操作或设备事件。 如果系统销毁或重新创建界面控制器，则存储在其中的任何瞬态界面相关数据都会丢失。例如，应用可能会在它的某个 Activity 中包含用户列表。为配置更改重新创建 Activity 后，新 Activity 必须重新提取用户列表。对于简单的数据，Activity 可以使用 onSaveInstanceState() 方法从 onCreate() 中的捆绑包恢复其数据，但此方法仅适合可以序列化再反序列化的少量数据，而不适合数量可能较大的数据，如用户列表或位图。 另一个问题是，界面控制器经常需要进行可能需要一些时间才能返回的异步调用。界面控制器需要管理这些调用，并确保系统在其销毁后清理这些调用以避免潜在的内存泄漏。此项管理需要大量的维护工作，并且在为配置更改重新创建对象的情况下，会造成资源的浪费，因为对象可能需要重新发出已经发出过的调用。 诸如 Activity 和 Fragment 之类的界面控制器主要用于显示界面数据、对用户操作做出响应或处理操作系统通信（如权限请求）。如果要求界面控制器也负责从数据库或网络加载数据，那么会使类越发膨胀。为界面控制器分配过多的责任可能会导致单个类尝试自己处理应用的所有工作，而不是将工作委托给其他类。以这种方式为界面控制器分配过多的责任也会大大增加测试的难度。 从界面控制器逻辑中分离出视图数据所有权的操作更容易且更高效。
 主要还是图片问题，无论是自己绘制的还是网络过来的，虽然可以有多级缓存。但是还是得自己去整一套吧。这个用得少，问题1，他缓存的数据我们应该不用管，然后正常关闭的再打开的数据，应该还是要从本地或者服务器拉去吧、 在配置更改期间会自动保留 ViewModel 对象，以便它们存储的数据立即可供下一个 Activity 或 Fragment 实例使用。这句话，感觉没懂，再配置更改期间是什么意思。 那么懂 “配置更改期间” 这个范围就很重要了。处理配置变更 这个里面对配置变更就有描述:</description>
    </item>
    
    <item>
      <title>探索 Jetpack 库</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%BE%97mvvm%E4%B8%AD%E7%9A%84viewmodel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%BE%97mvvm%E4%B8%AD%E7%9A%84viewmodel/</guid>
      <description>顺便推一下博客主页
 正文  莫得啥说的，直接上代码
 调用方式
1 return (VM) new ViewModelProvider(DggBaseActivity.this).get(new ClassNewInstanceUtil().getClass(this)); 工具类代码
1public class ClassNewInstanceUtil&amp;lt;T&amp;gt; { 2 3 public ClassNewInstanceUtil() { 4 } 5 6 public T createViewModel(Object object){ 7 try { 8 Type superClass = object.getClass().getGenericSuperclass(); 9 assert superClass != null; 10 if (superClass instanceof ParameterizedType){ 11 Type type = ((ParameterizedType) superClass).getActualTypeArguments()[1]; 12 Class&amp;lt;?&amp;gt; clazz = getRawType(type); 13 return (T) clazz.newInstance(); 14 } 15 } catch (Exception e) { 16// e.</description>
    </item>
    
    <item>
      <title>探索 Jetpack 库</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E9%A1%B6%E5%91%B1%E5%91%B1basefragment%E6%87%92%E5%8A%A0%E8%BD%BD%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E9%A1%B6%E5%91%B1%E5%91%B1basefragment%E6%87%92%E5%8A%A0%E8%BD%BD%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/</guid>
      <description>顺便推一下博客主页
 正文  和fragment 类似。
 方法 onCreate  提供 initParameters 初始化参数。 ARouter 阿里组件化初始化。  onCreateView  初始化viewdatabinding 获取rootView 设置创建为true isViewCreated 初始化viewmodel  onViewCreated  viewmodel 绑定UI 初始化数据监听 当界面可见的时候，统一进行数据处理  1if (!isHidden() &amp;amp;&amp;amp; getUserVisibleHint()) { 2// 可见状态,进行事件分发 3dispatchUserVisibleHint(true); 4} setUserVisibleHint  修改Fragment的可见性 setUserVisibleHint 被调用有两种情况： 1）在切换tab的时候，会先于所有fragment的其他生命周期，先调用这个函数，可以看log 2) 对于之前已经调用过setUserVisibleHint方法的fragment后，让fragment从可见到不可见之间状态的变化
 onHiddenChanged 用FragmentTransaction来控制fragment的hide和show时， 那么这个方法就会被调用。每当你对某个Fragment使用hide 或者是show的时候，那么这个Fragment就会自动调用这个方法。
dispatchUserVisibleHint  父fragment不可见的时候 不做处理 设置状态为不显示的时候不做处理。 如果界面可见，且为第一次可见，onFragmentFirstVisible调用 如果界面可见，可能不是第一可见，onFragmentResume();将次状态定义为真正可见。 dispatchChildVisibleState 将事件分发到内联fragment。 如果界面不可见，onFragmentPause() 定义为真正的不可见。 dispatchChildVisibleState 通知内联fragment 不可见了。  dispatchChildVisibleState  通过父层的fragment可见性 传参，拉去子类的fragment管理器，控制其子fragment是否可见。  isParentInvisible  判断父fragment的可见性</description>
    </item>
    
    <item>
      <title>探索 Jetpack 库</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E9%A1%B6%E5%91%B1%E5%91%B1basefragment%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E9%A1%B6%E5%91%B1%E5%91%B1basefragment%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/</guid>
      <description> 顺便推一下博客主页
 正文  同样基于 jetpack中的mvvm.和baseactivity类似，
 方法 onCreate  提供初始化参数方法。initParameters  onCreateView  通过id生成databinding 通过反射生成viewmodel  onViewCreated  绑定UI 初始化view,需要实现 初始化数据 viewModel中的数据livedata监听 初始化数据 需要实现 初始化view监听  setLoadSir  设置多层界面。需要手动调用。
 使用工具  LoadSir 界面多状态切换 工具。空界面，错误界面，成功界面等等。  </description>
    </item>
    
    <item>
      <title>探索 Jetpack 库</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E9%A1%B6%E5%91%B1%E5%91%B1viewmodel%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E9%A1%B6%E5%91%B1%E5%91%B1viewmodel%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/</guid>
      <description> 顺便推一下博客主页
 正文  基于jetpack.viewModel 基于livedata 进行数据更新监听。所以数据外层需要使用livedata壳进行包装。
 正常的列表数据 1public final MutableLiveData&amp;lt;List&amp;lt;? extends BaseCustomModel&amp;gt;&amp;gt; loadContentList = new MutableLiveData&amp;lt;&amp;gt;(); 正常的单model数据 1 2 public final MutableLiveData&amp;lt;BaseCustomModel&amp;gt; loadContentModel = new MutableLiveData&amp;lt;&amp;gt;(); 3 空数据 包装 1 public final MutableLiveData&amp;lt;Boolean&amp;gt; loadEmptyData = new MutableLiveData&amp;lt;&amp;gt;(); 非正常code 包装 1 public final MutableLiveData&amp;lt;BaseFailData&amp;gt; loadFailData = new MutableLiveData&amp;lt;&amp;gt;(); 加载更多为空包装  可能没有下一页。
 1public final MutableLiveData&amp;lt;Boolean&amp;gt; loadMoreEmptyData = new MutableLiveData&amp;lt;&amp;gt;(); 加载更多发生错误 1 public final MutableLiveData&amp;lt;BaseFailData&amp;gt; loadMoreFailData = new MutableLiveData&amp;lt;&amp;gt;(); </description>
    </item>
    
    <item>
      <title>探索 Jetpack 库</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E9%A1%B6%E5%91%B1%E5%91%B1%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E9%A1%B6%E5%91%B1%E5%91%B1%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6/</guid>
      <description> 顺便推一下博客主页
 正文 标题栏  基于LinearLayout 实现view控制。
DggTitleBar 自动适配 高度。
  cpCenterTitle 设置中间标题名称 cpRightTitle 右边标题名称 左边点击返回点击事件自动实现，如果是activity就关闭。  刷新控件 CpsSmartRefreshLayout  基于smart
 BaseQuickAdapter recyleView adapter </description>
    </item>
    
    <item>
      <title>探索 Jetpack 库</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E9%A1%B6%E5%91%B1%E5%91%B1%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E9%A1%B6%E5%91%B1%E5%91%B1%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9B%B8%E5%85%B3/</guid>
      <description>顺便推一下博客主页
 正文  网络请求相关。
 数据回调 采用基于livedata的 LiveEventBus 进行数据传输回调更改。
loading层控制 采用拦截器机制。
网络请求相关步骤  创建一个类A，继承于MvvmBaseViewModel。 为A创建一个view接口 为A 创建一个Request B，B继承于BaseModel B 提供一个网络请求方法。提供给A调用，方法传参需要提供网络请求数据，和A的回调。  B中的接口相关  创建模块接口 定义 接口请求返回参数和接口地址，传入参数等等。  1 //获取首页定位列表 2 @GET(&amp;#34;nk/home/get_city_list.do&amp;#34;) 3 Observable&amp;lt;BaseData&amp;lt;LocationCity&amp;gt;&amp;gt; getLocationCityList();  提供一个帮助类，提供一个静态方法，用于提供网络请求实体对象。  1 //获取登录api service 2 public static HomeApi getHomeApi() { 3 return RxHttpUtils.createApi(&amp;#34;home&amp;#34;, ConstantUrl.TEST_Home_URL, HomeApi.class); 4 }  网络请求调用  1 HomeApiHelp 2 .getHomeApi() 3 .getHomeCommodityData(jsonData) 4 .compose(Transformer.switchSchedulers()) 5 .subscribe(new BaseConsumer&amp;lt;List&amp;lt;HomeCommodityEntity&amp;gt;&amp;gt;() { 6 @Override 7 protected void onSuccess(List&amp;lt;HomeCommodityEntity&amp;gt; data) { 8 callBack.</description>
    </item>
    
    <item>
      <title>探索 Jetpack 库</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E9%A1%B6%E5%91%B1%E5%91%B1%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E9%A1%B6%E5%91%B1%E5%91%B1%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/</guid>
      <description> 顺便推一下博客主页
 路由配置  采用阿里巴巴提供的路由工具 ARouter
 配置 对需要跳转的activity 配置
1@Route(path = &amp;#34;/test/activity&amp;#34;) 跳转 1// 1. 应用内简单的跳转(通过URL跳转在&amp;#39;进阶用法&amp;#39;中) 2ARouter.getInstance().build(&amp;#34;/test/activity&amp;#34;).navigation(); 3 4// 2. 跳转并携带参数 5ARouter.getInstance().build(&amp;#34;/test/activity&amp;#34;) 6 .withLong(&amp;#34;key1&amp;#34;, 666L) 7 .withString(&amp;#34;key3&amp;#34;, &amp;#34;888&amp;#34;) 8 .withObject(&amp;#34;key4&amp;#34;, new Test(&amp;#34;Jack&amp;#34;, &amp;#34;Rose&amp;#34;)) 9 .navigation(); </description>
    </item>
    
    <item>
      <title>桥接模式</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_bridge_mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_bridge_mode/</guid>
      <description> 顺便推一下博客主页
 正文  主要详细理解设计模式。感觉这个设计模式蛮重要的。内容来源
 桥接模式  主要是减少继承实现的内容。 定义:将抽象与实现分离，使得他们可以独立变化。 这个应该Android 中的各种上下文应该是这种逻辑吧。
 模式结构  抽象化角色abstraction，定义抽象类。并包含一个对象实现话对象的引用。 扩展抽象化角色refined abstraction，是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。 实现化角色implementtor，定义实现化角色的接口，供抽象化角色调用。 具体实现化角色 concrete implementor,给出实现化角色接口的具体实现。  应用场景  当一个类存在两个独立变化的维度，且两个维度都需要进行扩展的时候。 当一个系统不希望使用继承或因为多层次继承导致系统内的类的个数急剧增加的时候。 当一个系统需要在构建的抽象化角色和具体化角色之间增加灵活性的时候。  感悟  这个感觉和适配器是不是有点像，都是衔接多个，适配器写法也可以加功能吧。  </description>
    </item>
    
    <item>
      <title>简单工厂模式</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_simple_factory_mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_simple_factory_mode/</guid>
      <description> 顺便推一下博客主页
 正文  主要详细理解设计模式。感觉这个设计模式蛮重要的。内容来源
 简单工厂模式  这个没有啥可以写的，大概就是 一个静态类通过 不同的参数或者方法 获得不同的东西。和一个工具类中包含多个功能差不多。 这个不配存在于我的设计模式 列表中。
 </description>
    </item>
    
    <item>
      <title>装饰器模式</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_decorator_mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_decorator_mode/</guid>
      <description> 顺便推一下博客主页
 正文  主要详细理解设计模式。感觉这个设计模式蛮重要的。内容来源
 装饰器模式  看介绍怎么感觉和dagger2 和桥接模式这么像，不过定义上:指在不改变现有对象结构的情况下，动态的给该对象增加一些职责。 而桥接模式是抽象与实现分离。等于说其实装饰器模式和dagger2是最接近的。但是有一个词很重要职责。和dagger2 基础增加变量还是有区别的。
 模式结构  抽象构建角色 component，定义一个抽象接口以规范准备接收附加责任对象。 具体构建角色 concretecomponent，实现抽象构建，通过装饰角色为其添加一些职责。 抽象装饰角色 decorator，继承抽象构建，包含具体构建的实例，可以通过其子类扩展具体构建功能。 具体装饰角色 concreteDecorator,实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。  应用场景  需要对一个类添加附加功能，又不能采用生成子类的方法进行扩展的时候。比如该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类。 当对象的功能要求可以动态添加，也可以动态撤销的时候。 当需要通过现有的一组基本功能进行排列组合而产生非常多的功能的时候。继承就很难理继承逻辑。通过加方法就可以。  非场景使用感悟  对一个类增加功能，其实变量也是功能，对于将变量加到对象中好像不行。常用增加功能一般是继承，继承可以增加变量方法什么的。 看写法，现在还是没有感受到这种写法的好处。 可能对于大对象中，只是针对小部分进行增加功能，这么写，会不会好一点。只是在扩展功能，内存会不会小一点。  </description>
    </item>
    
    <item>
      <title>记一个关于Android studio 无法查看Java源码的bug</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/%E8%AE%B0%E4%B8%80%E4%B8%AAjava%E4%BB%A3%E7%A0%81%E6%BA%90%E7%A0%81%E6%97%A0%E6%B3%95%E6%9F%A5%E7%9C%8B%E7%9A%84bug/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/%E5%85%B6%E4%BB%96/%E8%AE%B0%E4%B8%80%E4%B8%AAjava%E4%BB%A3%E7%A0%81%E6%BA%90%E7%A0%81%E6%97%A0%E6%B3%95%E6%9F%A5%E7%9C%8B%E7%9A%84bug/</guid>
      <description>前言 顺便推一下博客主页
正文 最近换到到Windows电脑，安装新的idea，才发现的问题。
1 // IntelliJ API Decompiler stub source generated from a class file 2 // Implementation of methods is not available 3 /* compiled code */ 因为无法查看源码，导致搬砖效率都低了好多。
解决方式 检查路径：File-&amp;gt;setting-&amp;gt;Plugins，然后下拉，找到Java Bytecode Decompiler。 但是Android studio 11:34	Plugin Error Plugin &amp;quot;GsonFormat&amp;quot; is incompatible (supported only in IntelliJ IDEA). Plugin &amp;quot;Java Decompiler IntelliJ Plugin&amp;quot; is incompatible (supported only in IntelliJ IDEA).
 换到idea 就行
 </description>
    </item>
    
    <item>
      <title>设计模式目录</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern/</guid>
      <description>顺便推一下博客主页
 正文  主要详细理解设计模式。感觉这个设计模式蛮重要的。内容来源
 设计模式主要分类:
 创建型模式  创建型模式主要关注点是，如何创建对象，他的主要特点是将对象的创建与使用分离，可以降低耦合度。
  工厂方法模式  (通过定义一个对象接口，然后由工厂类决定或者子类决定输出对象) 抽象工厂模式 (和工厂模式差不多) 单例模式  (某个类只能存在一个实例，该类提供了一个全局访问点供外部使用，但是反射好像打破了这种设计模式) 建造者模式  (将复杂的对象拆分为多个子类。和合成复用原则吻合) 原型模式  (将一个对象作为原型，通过对其复制出多个和原型类型的新的实例)   结构型模式  结构型模式描述如何将类或者对象按照某种布局组成更大的结构，它分为类结构模式和对象结构模式，前者采用继承机制来组织接口类，后者采用组合或聚合来组合对象。组合或者聚合耦合度低。
  适配器模式  将一个类的接口转换成客户端希望的另外一个接口，使得原本不兼容的的接口或者内可以一起工作。 装饰器模式  动态的给对象增加一些职责，增加其额外功能。 代理模式  为某对象提供一种代理以控制该对象的访问，从而限制或者增强或修改该对象的一些特性。 外观模式  为多个复杂的子系统提供一个一致的接口，使得子系统更容易被访问。 桥接模式  将抽象与实现分离，使得他们可以独立变化，他是使用组合关系替代继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。 组合模式  将对象组合成树状层，使用户对单个对象和组合对象具有一致的访问性。 享元模式  运用共享技术，来有效的支持大量细粒度对象的复用。   行为模式  策略模式 模板方法模式 观察者模式 迭代子模式 责任链模式 命令模式 备忘录模式 状态模式 访问者模式 中介者模式 解释器模式   并发型模式 线程池模式  设计模式原则 开闭原则 &amp;gt; 对扩展开发，对修改关闭.</description>
    </item>
    
    <item>
      <title>适配器模式</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_adapter_mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_adapter_mode/</guid>
      <description> 顺便推一下博客主页
 正文  主要详细理解设计模式。感觉这个设计模式蛮重要的。内容来源
 适配器模式  这种模式 在Android 中及其常见，先回顾下适配器模式的定义:将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的类可以一起工作。 Android中的所有view和数据的绑定，都可以看做适配器模式的设计。 感觉这个可以通过代理模式(扩展真实对象功能，就可以包括适配)解决这个问题，或者建造者（建造者可能麻烦点，但是依靠建造者服务可以统一处理），工厂模式相对来说会复杂点。 但是也不是不能使用。基于数据模型，key-v模型，是没有这个问题，但是这个主要是解决接口设计部对等导致的问题，两个接口不可改的时候就需要中间接口服务实现这个调调了。
 </description>
    </item>
    
    <item>
      <title>重学Viewpager</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/%E9%87%8D%E5%AD%A6viewpager/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/%E9%87%8D%E5%AD%A6viewpager/</guid>
      <description>》 顺便推一下博客主页
前言  viewpager 通常用于加载Fragment或者banner图，因为其良好的交互效果，被设计大佬广泛使用。默认情景下，viewpager 会加载缓存左右的view。滑出去之后就会删除对应的item。 这么就导致了fragment中layout的重复创建和重复赋值，不停的网络请求，所以才有了懒加载等等相关逻辑，但是viewpager某种意义上就是懒加载逻辑呀。 往往为了解决重复请求，重复加载等等问题，我们通常是设置缓存个数和重写item的删除逻辑，为了更加通透的理解viewpager，所以重学是必要的。
 正文 viewPager 结束 </description>
    </item>
    
    <item>
      <title>顶呱呱搬砖日常</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/dgg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/dgg/</guid>
      <description>前言 顺便推一下博客主页
正文  2021年2月18日 入职顶呱呱，大概3个月的试用。想着找一个地方继续狗命来着。这个主要是记录下在顶呱呱的技术学习路程吧。
  这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接 这个是超级链接   这个能写多少，大概就是我能够狗多久了。加油，还有两年继续狗吧。
 </description>
    </item>
    
    <item>
      <title>顶呱呱视频项目详细设计</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/dgg%E9%A1%B9%E7%9B%AE%E8%A7%86%E9%A2%91%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/dgg%E9%A1%B9%E7%9B%AE%E8%A7%86%E9%A2%91%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/</guid>
      <description>前言  530 项目？基于，当前项目基于必懂项目新增视频相关逻辑。所有视频播放都不涉及后台播放，但是需要处理界面重启（app 进入后台）
 参考文献地址:  功能设计-概要设计-原型设计？ 视频项目名词定义 蓝湖地址 缺省图 接口地址 阿里云视频点播主页 视频点播-文档 文档地址： demo 下载地址：  结构图 模块拆解和功能区分  当前设计只是兼顾C端。
 个人主页 视频聚合界面 关注 推荐 大讲堂 视频 薯条计划 1 修改  当前修改基于必懂之前的设计。热榜无更改。
 1.1 首页tab  支持整个页面左右滑动切换频道
 1.1.1 涉及改动接口  新增查询 视频相关tab的逻辑。  1.1.2 交互 参考上图。
 视频所在tab 如果处于选中状态下，可以点击下拉，弹出分类筛选弹窗，默认选中 默认排序，点击热度排序更改排序规则。 如果视频没有被选中，需要清除下拉图标。参考： 再次点击视频按钮，会拖放展示选择条件；点击其他地方或视频按钮，则上拉隐藏筛选。 操作弹窗中，新增，视频讲堂分类。操作逻辑区别于其他分类。  1.2 关注列表  关注用户列 表新增关注的视频发布作者 关注用户动态列表 新增关注的视频发布作者的视频动态。   1.2.1 item 分解  1 视频点赞数量。 2 视频评论数量 3 视频时长 4 视频封面图 5 必懂时间格式化逻辑+视频（比如：27分钟前·发布了视频）时间格式化参考(公共说明): 6 视频标题。  1.</description>
    </item>
    
    <item>
      <title>项目管理</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E9%A1%B6%E5%91%B1%E5%91%B1%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/dgg/%E9%A1%B6%E5%91%B1%E5%91%B1%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3/</guid>
      <description> 顺便推一下博客主页
 正文  参考文件。项目管理
 项目质量的定义  功能性 可靠性 易用性 效率 维护性 可移植性 正确性 健壮性 安全性 可用性 可理解性 可测试性 可再用性。  数据模型  通常采用数据建模。数据建模的思想在较高的抽象层次（概念层）对应用相关大体数据进行关系建模处理。数据模型用实体关系图描述。
 实体关系图 (E-R图)  矩形框表示实体，在框框中写入实体名称 菱形框： 表示联系 椭圆形框表示实体或者联系的属性。 连线 表示联系，联系属性之间采用直线相连，并且在直线上标注联系的类型。需要标注1对1,1对N,n对N.  功能模型  功能建模的思想是用抽象模型的概念，按照软件内部数据传递和变换的关系，自顶向下分解，直到找到满足功能的要求的可实现的软件为止。 功能模型采用数据流程图DFD来描述。
 数据流程图 DFD  带背景颜色的矩形框，外部实体 箭头，数据流 圆角矩形或者圆 表示数据交换 缺边矩形框，表示数据存储。  环境图  仅仅包括一个数据处理过程，确定输入输出边界，通常需要完成一个步骤的闭环，从哪里出发，数据应该回到哪里。 还是使用数据流程图 相关控件的定义。
 行为模型  主要是对复杂流程中的状态事件或者事件导致多种状态进行描述。 大概样子:  </description>
    </item>
    
  </channel>
</rss>
