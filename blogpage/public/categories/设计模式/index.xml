<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>设计模式 on 个人主页</title>
    <link>http://lalalaxiaowifi.gitee.io/pictures/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
    <description>Recent content in 设计模式 on 个人主页</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2020-2099</copyright><atom:link href="http://lalalaxiaowifi.gitee.io/pictures/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>享元模式</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_flyweight_mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_flyweight_mode/</guid>
      <description> 顺便推一下博客主页
 正文  主要详细理解设计模式。感觉这个设计模式蛮重要的。内容来源
 享元模式  运用共享技术来有效的支持大量细粒度对象的复用，他通过共享已经存在的对象来大幅度减少需要创建对象的苏亮，避免大量相似类的开销，从而提高系统资源的利用率。 享元模式的本质是缓存共享对象，降低内存消耗。
 </description>
    </item>
    
    <item>
      <title>代理模式</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_proxy_mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_proxy_mode/</guid>
      <description> 顺便推一下博客主页
 正文  主要详细理解设计模式。感觉这个设计模式蛮重要的。内容来源
 代理模式  由于某些原因，需要给某对象提供一个代理以控制该对象的访问，这时候，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。
  代理模式可以在客户端与目标对象之间起中介作用和保护目标对象。 代理对象可以扩展目标对象功能。  代理模式的应用场景  远程代理，这种方式通常是为了隐藏目标对象，方便客户端访问。 虚拟代理，比如图片很大，可以先在某些场景使用小图。 安全代理，用于控制不同权限的对象访问。虽然工厂模式也行。 延迟加载，通过代理中间层实现等待，和干涉原对象。  代码模式结构  抽象主题subject，通过接口或者抽象类声明真实主题和代理对象的实现的业务方法。 真实主题，real subject,实现了抽象主题中的具体业务，是代理对象所代表的真实对象。 代理proxy,提供了与真实对象的接口，内部包含对真实对象的引用，可以控制，访问，扩展真实对象的功能。  </description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_singleton_mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_singleton_mode/</guid>
      <description> 顺便推一下博客主页
 正文  主要详细理解设计模式。感觉这个设计模式蛮重要的。内容来源
 单例模式 优点 只有一个对象，单线程中，减少内存开销，避免资源多重占用，资源共享。
缺点 扩展困难，多线程操作需要单独处理，单例模式 功能复杂不利于更新维护。
使用  懒汉单例，需要的时候才创建对象 饿汉单例，类加载就创建对象，可以避免多线程创建对象。 对于频繁使用的创建单例。 创建过程消耗巨大的创建单例 数据共享也可以创建单例  </description>
    </item>
    
    <item>
      <title>原型模式</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_prototype_mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_prototype_mode/</guid>
      <description> 顺便推一下博客主页
 正文  主要详细理解设计模式。感觉这个设计模式蛮重要的。内容来源
 原型模式  应用场景,针对大量重复数据，通过new 去创建比较消耗时间。 Java 自带的原型模式基于内存二进制流复制，性能上比new更加优良。 便于实现类似于事务功能，比如撤销什么的。返回上一步什么的。 重新创建成本过大，又不能使用单例的时候。 创建对象需要的流程过于复杂等。
 实现方式  java 中需要将被复制对象实现 Cloneable 接口。对象调用特定方法：clone()实现对象复制。
 </description>
    </item>
    
    <item>
      <title>外观模式</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_facade_mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_facade_mode/</guid>
      <description> 顺便推一下博客主页
 正文  主要详细理解设计模式。感觉这个设计模式蛮重要的。内容来源
 外观模式  外观模式是一种通过为多个复杂的子系统提供一个一致的接口，使得子系统更加容易访问。 阿里的路由工具ARouter 应该就是外观模式的较好实现。
 </description>
    </item>
    
    <item>
      <title>工厂模式和抽象工厂模式</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_factory_mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_factory_mode/</guid>
      <description> 顺便推一下博客主页
 正文  主要详细理解设计模式。感觉这个设计模式蛮重要的。内容来源
 工厂模式和抽象工厂模式  这个可能是简单工厂模式的抽象版本。将功能具体化，一个工厂提供同类的服务，一个工厂对应于一个抽象对象接口。
 主要角色:
 抽象产品 (同一类产品的公共属性合集) 具体产品 (继承与抽象产品) 抽象工厂（这个可以不要，直接由具体工厂通过不同的方法返回 抽象产品就好，方法实现具体产品） 具体工厂 （有抽象工厂需要实现抽象工厂，提供不同的方法生产具体产品，返回抽象产品，通常和抽象工厂搭配使用，也可以返回具体产品）  </description>
    </item>
    
    <item>
      <title>建造者模式</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_builder_mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_builder_mode/</guid>
      <description> 顺便推一下博客主页
 正文  主要详细理解设计模式。感觉这个设计模式蛮重要的。内容来源
 建造者模式  建造者模式是指，将一个复杂对象的构造与他的表示分离。使同样的够着过程可以创建不同的表示。 Android 很多就实现了建造者模式。比如弹窗。
  产品角色，他包含多个组成部件的复杂对象，由具体建造者来创建其他各个零部件。 抽象建造者builder。包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法。 具体建造者，实现builder接口，完成复杂产品的各个部件的具体创建方法。 指挥者director，他调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品。  应用场景  建造者模式唯一区别于工厂模式的是针对复杂对象的创建，如果是简单对象，通常使用工厂模式创建，如果是创建复杂对象，就可以考虑使用建造者模式。
  相同的方法，不同的执行顺序，产生不同的结果。 多个部件或者零件，都可以装配到一个对象中，但是产生的结果又不相同。 产品类非常复杂，或者产生类中的不同的调用顺序产生不同的作用。 初始化一个对象特别复杂，参数多，而且很多参数都具有默认值。  建造者模式和工厂模式的区别  建造者模式更加注重方法的调用顺序，工厂模式更加注重对象的创建。 创建对象的力度不同，建造者模式创建复杂对象，由各个复杂部件组成，工厂模式创建出来的对象都是一样的。 关注点不一样，工厂模式只需要创建对象，建造者模式需要创建对象，还要知道部件。 建造者模式根据建造过程顺序不一样，生成的对象部件也不一样。 如果建造者创建的产品类只有一个，只需要一个具体的建造者，可以省略到抽象建造者，甚至可以省略调指挥者。  </description>
    </item>
    
    <item>
      <title>日常搬砖模板</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern__mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern__mode/</guid>
      <description> 顺便推一下博客主页
 正文  主要详细理解设计模式。感觉这个设计模式蛮重要的。内容来源
 </description>
    </item>
    
    <item>
      <title>桥接模式</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_bridge_mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_bridge_mode/</guid>
      <description> 顺便推一下博客主页
 正文  主要详细理解设计模式。感觉这个设计模式蛮重要的。内容来源
 桥接模式  主要是减少继承实现的内容。 定义:将抽象与实现分离，使得他们可以独立变化。 这个应该Android 中的各种上下文应该是这种逻辑吧。
 模式结构  抽象化角色abstraction，定义抽象类。并包含一个对象实现话对象的引用。 扩展抽象化角色refined abstraction，是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。 实现化角色implementtor，定义实现化角色的接口，供抽象化角色调用。 具体实现化角色 concrete implementor,给出实现化角色接口的具体实现。  应用场景  当一个类存在两个独立变化的维度，且两个维度都需要进行扩展的时候。 当一个系统不希望使用继承或因为多层次继承导致系统内的类的个数急剧增加的时候。 当一个系统需要在构建的抽象化角色和具体化角色之间增加灵活性的时候。  感悟  这个感觉和适配器是不是有点像，都是衔接多个，适配器写法也可以加功能吧。  </description>
    </item>
    
    <item>
      <title>简单工厂模式</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_simple_factory_mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_simple_factory_mode/</guid>
      <description> 顺便推一下博客主页
 正文  主要详细理解设计模式。感觉这个设计模式蛮重要的。内容来源
 简单工厂模式  这个没有啥可以写的，大概就是 一个静态类通过 不同的参数或者方法 获得不同的东西。和一个工具类中包含多个功能差不多。 这个不配存在于我的设计模式 列表中。
 </description>
    </item>
    
    <item>
      <title>装饰器模式</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_decorator_mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_decorator_mode/</guid>
      <description> 顺便推一下博客主页
 正文  主要详细理解设计模式。感觉这个设计模式蛮重要的。内容来源
 装饰器模式  看介绍怎么感觉和dagger2 和桥接模式这么像，不过定义上:指在不改变现有对象结构的情况下，动态的给该对象增加一些职责。 而桥接模式是抽象与实现分离。等于说其实装饰器模式和dagger2是最接近的。但是有一个词很重要职责。和dagger2 基础增加变量还是有区别的。
 模式结构  抽象构建角色 component，定义一个抽象接口以规范准备接收附加责任对象。 具体构建角色 concretecomponent，实现抽象构建，通过装饰角色为其添加一些职责。 抽象装饰角色 decorator，继承抽象构建，包含具体构建的实例，可以通过其子类扩展具体构建功能。 具体装饰角色 concreteDecorator,实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。  应用场景  需要对一个类添加附加功能，又不能采用生成子类的方法进行扩展的时候。比如该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类。 当对象的功能要求可以动态添加，也可以动态撤销的时候。 当需要通过现有的一组基本功能进行排列组合而产生非常多的功能的时候。继承就很难理继承逻辑。通过加方法就可以。  非场景使用感悟  对一个类增加功能，其实变量也是功能，对于将变量加到对象中好像不行。常用增加功能一般是继承，继承可以增加变量方法什么的。 看写法，现在还是没有感受到这种写法的好处。 可能对于大对象中，只是针对小部分进行增加功能，这么写，会不会好一点。只是在扩展功能，内存会不会小一点。  </description>
    </item>
    
    <item>
      <title>设计模式目录</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern/</guid>
      <description>顺便推一下博客主页
 正文  主要详细理解设计模式。感觉这个设计模式蛮重要的。内容来源
 设计模式主要分类:
 创建型模式  创建型模式主要关注点是，如何创建对象，他的主要特点是将对象的创建与使用分离，可以降低耦合度。
  工厂方法模式  (通过定义一个对象接口，然后由工厂类决定或者子类决定输出对象) 抽象工厂模式 (和工厂模式差不多) 单例模式  (某个类只能存在一个实例，该类提供了一个全局访问点供外部使用，但是反射好像打破了这种设计模式) 建造者模式  (将复杂的对象拆分为多个子类。和合成复用原则吻合) 原型模式  (将一个对象作为原型，通过对其复制出多个和原型类型的新的实例)   结构型模式  结构型模式描述如何将类或者对象按照某种布局组成更大的结构，它分为类结构模式和对象结构模式，前者采用继承机制来组织接口类，后者采用组合或聚合来组合对象。组合或者聚合耦合度低。
  适配器模式  将一个类的接口转换成客户端希望的另外一个接口，使得原本不兼容的的接口或者内可以一起工作。 装饰器模式  动态的给对象增加一些职责，增加其额外功能。 代理模式  为某对象提供一种代理以控制该对象的访问，从而限制或者增强或修改该对象的一些特性。 外观模式  为多个复杂的子系统提供一个一致的接口，使得子系统更容易被访问。 桥接模式  将抽象与实现分离，使得他们可以独立变化，他是使用组合关系替代继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。 组合模式  将对象组合成树状层，使用户对单个对象和组合对象具有一致的访问性。 享元模式  运用共享技术，来有效的支持大量细粒度对象的复用。   行为模式  策略模式 模板方法模式 观察者模式 迭代子模式 责任链模式 命令模式 备忘录模式 状态模式 访问者模式 中介者模式 解释器模式   并发型模式 线程池模式  设计模式原则 开闭原则 &amp;gt; 对扩展开发，对修改关闭.</description>
    </item>
    
    <item>
      <title>适配器模式</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_adapter_mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/designpatterns/design_pattern_adapter_mode/</guid>
      <description> 顺便推一下博客主页
 正文  主要详细理解设计模式。感觉这个设计模式蛮重要的。内容来源
 适配器模式  这种模式 在Android 中及其常见，先回顾下适配器模式的定义:将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的类可以一起工作。 Android中的所有view和数据的绑定，都可以看做适配器模式的设计。 感觉这个可以通过代理模式(扩展真实对象功能，就可以包括适配)解决这个问题，或者建造者（建造者可能麻烦点，但是依靠建造者服务可以统一处理），工厂模式相对来说会复杂点。 但是也不是不能使用。基于数据模型，key-v模型，是没有这个问题，但是这个主要是解决接口设计部对等导致的问题，两个接口不可改的时候就需要中间接口服务实现这个调调了。
 </description>
    </item>
    
  </channel>
</rss>
