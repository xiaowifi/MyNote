<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>android基础 on 个人主页</title>
    <link>http://lalalaxiaowifi.gitee.io/pictures/categories/android%E5%9F%BA%E7%A1%80/</link>
    <description>Recent content in android基础 on 个人主页</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2020-2099</copyright>
    <lastBuildDate>Mon, 28 Dec 2020 00:00:00 +0000</lastBuildDate><atom:link href="http://lalalaxiaowifi.gitee.io/pictures/categories/android%E5%9F%BA%E7%A1%80/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>fragment生命周期导致数据初始化问题</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/fragment%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
      <pubDate>Mon, 28 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/fragment%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
      <description>前言 话说，activity 和fragment 都是有生命周期的，而且加载也并不是new完对象就加载出来了的，new 一个activity并不多见，但是基于activity new 一个fragment还是很常见的，但是很少有需要在activity中调用fragment方法的时候，但是存在可能性。 因为fragment加载的特性，所以像loading层保证唯一，这样子的就不能直接判断fragmentmanger 中是否包含了，需要一个其他值去判断。而且传参方面，也是这个样子。 比如说我的createPresenter() 方法是当fragment 走oncreate() 的时候创建调用的，但是我上一行代码创建完fragment就直接调用presenter 就会抛空指针异常。
解决思路 思路1 绑定生命周期 我们知道 fragment.getLifecycle().addObserver(observer) 这个可以添加生命周期监听，那么我们对fragment 添加了监听，等走到对应的生命周期的方法才执行对应的代码就好。这样也就避免了，activity 不知道fragment什么时候加载完成导致调用问题了。 但是这种情况下，如果我fragment中再嵌套一个fragment呢？内部的fragment 生命周期万一也关联到外部的activity调用呢？用多个observer去调出来，就是有点怪怪的。那么只能从代码设计上更改了。
思路2 更改设计模式 修改绑定生命周期部分 这个思路肯定是不行的，绑定生命周期就是为了优化内存使用的，而且绑定生命周期也对view的加载显示控制提供了生命范围，防止错误的时间，错误的地点导致操作崩溃。
那就修改功能对应的界面的设计  先说功能吧，对某个数据表进行 折线图，饼图，柱状图等图表的显示，这些图表支持 日周月年的时间切换。先进入某个功能点，确定数据来源，然后选择图表类型，进入下一个界面，最后是选择时间切换。默认加载天的数据。 我就一想，既然每个图表需求显示的view是固定的，那么activity只需要加载一个fragment，由fragment 内部加载不同的图表fragment，图表fragment 只需要显示fragment传入的数据就行。fragment进行数据获取和数据转换，activity进行时间更改转化，然后传入进去。 那么问题就来了，因为activity控制时间，所以第一次的时间需要由activity传入到fragment中，然而，activity并不知道fragment是否加载完成，所以activity需要知道fragment的生命周期，fragment拿到数据知道，也不知道图表fragment是否加载完成，所以也需要拿到生命周期，如果不做延时处理，那么activity就需要拿到两层fragment的生命周期，再传入值。 但是做线程延时，判断生命周期调用，也需要先将 我传入的值存储到两个fragment里面，等到需要的生命周期再显示，这个和我直接通过对象方法传参没有任何区别吧。所以还是生命周期传参导致的问题。 那么就优化设计逻辑，activity 只持有一层图表fragment，图表fragment进行数据拉取和处理显示就好，只是图表层的presenter 需要将所有的功能点的数据全部拉取一遍罢了。当然进行时间切换的时候，也需要判断当前fragment是否加载出来。
 总结 感觉，mvp和mvvm 其实也是一种代码规范，感觉通过activity 向fragment对象方法传参就有点违背了这种规范的初衷吧。所以像eventbus 这种传参，就很实用,完全不需要考虑生命周期，当然Android 提供的广播也是可以的。 EventBus GitHub
activity中注册后，在fragment中就不用再注册监听了，提供方法就直接会调用。因为fragment属于延时加载，所以尽量使用postSticky 。接收：
1 @Subscribe(threadMode = ThreadMode.MAIN, sticky = true) 2 public void onChangeData(ChartDetailsMessage message){ 3 getPresenter().getDatas(message); 4 } </description>
    </item>
    
    <item>
      <title>摸鱼Android Fragmentmanger</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android-fragmentmanger/</link>
      <pubDate>Tue, 20 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android-fragmentmanger/</guid>
      <description>前言 话说，搬砖多年，我们的好朋友fragment已经需要适配到AndroidX了，毕竟我之前老是喜欢用V4包下的fragment。但是这个笔记却不是关于更新到Android X的,毕竟如果要整Android X，要改的地方应该有点多，还不知道 Android X和support 包可以共存吗？感觉没法共存，毕竟从activity 到view好像都变了，毕竟第3方包如果没有适配Android X就没法改。自己整是不可能自己整的，毕竟老板没有要求，那我们就永远不适配AndroidX的代码。感觉有点和Android 最新时代已经脱轨了。
好了，回归正文，我们主要是整fragmentmanager。
顺便推一下博客主页
正文 显示fragment吧，这个老朋友了，不需要介绍，app 下的fragment和v4下的fragment调用对应的fragmentmanager就好了。而显示fragment 一般有几种:
 通过ViewPager 加载 通过FrameLayout 通过dialogFragment 显示  这个地方主要整:基于FrameLayout 显示fragment。
显示fragment 代码大概是需要显示成这个样子。
1public Fragment showFragment(String className, FragmentManager fragmentManager, int id) { 2 Fragment fragment = null; 3 try { 4 5 FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction(); 6 //隐藏所有的那个啥。 7 for (Fragment fra : fragmentManager.getFragments()) { 8 fragmentTransaction.hide(fra); 9 } 10 Fragment fragmentByTag = fragmentManager.findFragmentByTag(className); 11 if (fragmentByTag !</description>
    </item>
    
    <item>
      <title>摸鱼DialogFragment</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/%E6%91%B8%E9%B1%BCdialogfragment/</link>
      <pubDate>Mon, 19 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/%E6%91%B8%E9%B1%BCdialogfragment/</guid>
      <description>前言 话说dialogfragment。这个调调，我用的还是蛮多的。像popwindow,loading，或者一些dialog如果能够用dialogfragment 实现，我一般会选择用这个调调。毕竟有生命周期，感觉和写fragment没有区别。这就导致我基于dialog 实现自定义dialog的能力比较差，主要还是主题设置，设置好了还是感觉差不多的。当然了popwindow的优点还是dialog 或者dialogfragment 无法比拟的。还有一个原因，我比较喜欢将一些值存储到activity的intent中(这么写，还是要提供完整的注释的，要不然不习惯这种写法的会看得很难受)，感觉dialog 中获取activity 没有fragment中那么方便。但是我看好多UI库都是自己写了一个dialog(比如说QMUI) ?搞得我有点懵逼。但是我看别人的代码，很少用dialogfragment 为啥我看到的代码里面，大家都用dialog 而不是dialogfragment ?这个以后探讨吧。
顺便推一下博客主页
正文 话说这个调调DialogFragment和其他控件差不多，也是从28以后移出出去了。看来把代码适配更新到Android X是需要提上日程了。关于基础用法这个网络上很多大佬写过博客的，我觉得没有重复的必要的，和fragment 差不多，还是重要的一点，配置style会影响dialogfragment的显示效果的，状态栏也可以按照需求配置的。
主题 我所使用的主题。通常是全屏的。这个需要通过自己的需求配置
1&amp;lt;style name=&amp;#34;Dialog.FullScreen&amp;#34; parent=&amp;#34;AppTheme&amp;#34;&amp;gt; 2 &amp;lt;item name=&amp;#34;android:windowNoTitle&amp;#34;&amp;gt;true&amp;lt;/item&amp;gt; 3 &amp;lt;item name=&amp;#34;android:windowBackground&amp;#34;&amp;gt;@color/transparent&amp;lt;/item&amp;gt; 4 &amp;lt;item name=&amp;#34;android:windowIsFloating&amp;#34;&amp;gt;false&amp;lt;/item&amp;gt; 5 &amp;lt;item name=&amp;#34;android:textColor&amp;#34;&amp;gt;@color/color_333333&amp;lt;/item&amp;gt; 6 &amp;lt;item name=&amp;#34;android:textSize&amp;#34;&amp;gt;14sp&amp;lt;/item&amp;gt; 7 &amp;lt;item name=&amp;#34;android:backgroundDimEnabled&amp;#34;&amp;gt;true&amp;lt;/item&amp;gt; 8&amp;lt;/style&amp;gt; 9 10&amp;lt;style name=&amp;#34;DialogNoDim&amp;#34; parent=&amp;#34;Dialog.FullScreen&amp;#34;&amp;gt; 11 &amp;lt;item name=&amp;#34;android:backgroundDimEnabled&amp;#34;&amp;gt;false&amp;lt;/item&amp;gt; 12 &amp;lt;/style&amp;gt; 使用:
1@Override 2public void onCreate(@Nullable Bundle savedInstanceState) { 3 super.onCreate(savedInstanceState); 4 setStyle(STYLE_NORMAL, R.style.Dialog_FullScreen); 5} 其他设置：
1@Nullable 2@Override 3public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) { 4 getDialog().</description>
    </item>
    
    <item>
      <title>Android时间相关view</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3view/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3view/</guid>
      <description>》 顺便推一下博客主页
前言  话说，Android 上整时间相关的情况也是蛮多的，比如时间选择器，日期选择器，显示一个时钟，显示一个详细时间，验证码倒计时（计时器）等等。 选择器相关的就不多描述了，一般都是通过wheelVew 做滚动联动或者就是列表做联动，或者就是第3方的控件拖进来，当前属于笔记就不整这些了。 搬砖多年，突然看到基本Android基础书籍，才发现自己好多都忘记了。
 正文 模拟时钟 AnalogClock
详细时间 DigitalClock
计时器 这个就比较骚了，很少有想到有基础控件的，我看过很多都是handle 去实现，或者梦想点就是Rxjava,区别在于有些大佬杀界面重新进去会复活之前已经刷新过的倒计时，有些大佬不会。
Chronometer
结束 </description>
    </item>
    
    <item>
      <title>Android行高和文本显示于设计冲突</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android%E8%A1%8C%E9%AB%98%E5%92%8C%E6%96%87%E6%9C%AC%E6%98%BE%E7%A4%BA%E4%BA%8E%E8%AE%BE%E8%AE%A1%E5%86%B2%E7%AA%81/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android%E8%A1%8C%E9%AB%98%E5%92%8C%E6%96%87%E6%9C%AC%E6%98%BE%E7%A4%BA%E4%BA%8E%E8%AE%BE%E8%AE%A1%E5%86%B2%E7%AA%81/</guid>
      <description>》 顺便推一下博客主页
前言  话说，Android textview 应该算是最常用的控件了。但是现在的设计文本大多数都是内容居中对齐。 但是 textview 却搞事情的有一个内间距。
 正文 1 &amp;lt;item name=&amp;#34;android:includeFontPadding&amp;#34;&amp;gt;false&amp;lt;/item&amp;gt; 将上面代码放到 全局的style中就可以达到效果了。 然后是行距，这个就需要手动算了。 android:lineSpacingExtra=&amp;quot;3dp&amp;quot;
代码可以设置行高的，所以行间距 也可以不自己算了。
结束 </description>
    </item>
    
    <item>
      <title>日常搬砖模板</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/ali/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/ali/%E6%97%A5%E5%B8%B8%E6%90%AC%E7%A0%96%E6%A8%A1%E6%9D%BF/</guid>
      <description>》 顺便推一下博客主页
前言 结束 </description>
    </item>
    
    <item>
      <title> 加载反馈页管理工具</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/%E5%8A%A0%E8%BD%BD%E5%8F%8D%E9%A6%88%E9%A1%B5%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/%E5%8A%A0%E8%BD%BD%E5%8F%8D%E9%A6%88%E9%A1%B5%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid>
      <description>》 顺便推一下博客主页
前言 参考资料.
 GitHub LoadSir DggBaseActivity DggLazyFragment  正文  LoadSir是一个高效易用，低碳环保，扩展性良好的加载反馈页管理框架，在加载网络或其他数据时候，根据需求切换状态页面， 可添加自定义状态页面，如加载中，加载失败，无数据，网络超时，如占位图，登录失效等常用页面。可配合网络加载框架，结合返回 状态码，错误码，数据进行状态页自动切换，封装使用效果更佳。
 初始化 结束 </description>
    </item>
    
    <item>
      <title>Alibaba旗下android中RecycleView的manger笔记</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/vlayout/alibaba%E6%97%97%E4%B8%8Bandroid%E4%B8%ADrecycleview%E7%9A%84manger%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/vlayout/alibaba%E6%97%97%E4%B8%8Bandroid%E4%B8%ADrecycleview%E7%9A%84manger%E7%AC%94%E8%AE%B0/</guid>
      <description>》 顺便推一下博客主页
前言  话说，android 中recycleView 是一个好东西。阿里巴巴的vlayout 其实了解了很久了，只是没有时间上手写笔记。像首页的聚合界面呀。tab相关的呀都可以用这个实现，当然了他只是提供LayoutManager。 但是也不影响。反正都是搬砖嘛。
阿里巴巴 android vlayout GitHub地址
 正文 结束 </description>
    </item>
    
    <item>
      <title>androidX下的fragment懒加载</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android-x-%E4%B8%8B%E7%9A%84fragment-%E6%87%92%E5%8A%A0%E8%BD%BD-/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android-x-%E4%B8%8B%E7%9A%84fragment-%E6%87%92%E5%8A%A0%E8%BD%BD-/</guid>
      <description>前言 fragment懒加载到处都可以搜索到。2021年7月26 在调试本地fragment懒加载的时候，发现未达到效果，搜索懒加载相关代码的时候，偶然发现android X下的懒加载写法。 故记录一波。
参考资料  Google 在 Androidx 在 FragmentTransaction 中增加了 setMaxLifecycle 方法来控制 Fragment 所能调用的最大的生命周期函数。 在 FragmentPagerAdapter 与 FragmentStatePagerAdapter 新增了含有 behavior 字段的构造函数。如果 behavior 的值为 BEHAVIOR_SET_USER_VISIBLE_HINT，那么当 Fragment 对用户的可见状态发生改变时，setUserVisibleHint 方法会被调用。 如果 behavior 的值为 BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT ，那么当前选中的 Fragment 在 Lifecycle.State#RESUMED 状态 ，其他不可见的 Fragment 会被限制在 Lifecycle.State#STARTED 状态。 参考内容:android X下的fragment 懒加载 ViewPager2 本身就支持对实际可见的 Fragment 才调用 onResume 方法。(所以要用viewpager 2 而不是viewpager,好的，马上改代码)  正文 所以说，基于上面的参考资料。可以通过 setMaxLifecycle在 onResume上面做懒加载？
结束 </description>
    </item>
    
    <item>
      <title>android上的设计模式</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android%E4%B8%8A%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android%E4%B8%8A%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>》 顺便推一下博客主页
前言  今天写demo的时候，顺便发现了自己对设计模式感觉搞迷糊了。然后就整理一波设计模式。现在android常用的是mvc，mvp,mvvm。其他设计模式先放过了，先不整，主要是用得少。话说面试的时候，一般都会问自己写代码的设计模式，才出来的时候说mvc,基于大佬的代码复制一套mvp,然后基于jetpack说是mvvm.似乎从来没有仔细理解过这几种设计模式的优缺点，为啥要用这些设计模式等等。 为啥用，因为大家都在用，我不用就落伍了，这可能是我这类搬砖工这么用的原因。我记得有大佬在自己博客上说过类似的话.&amp;quot;设计模式，他是一种思维逻辑，而不是一种简单的代码规范，要体验到诸多设计模式的优点，只有自己用得多了，而不是看的多，用得多了才有自己的感悟，否则一直都是代码规范是没法理解到他的优点的“。 内容资料大多数源于百度百科
 正文  android搬砖工，所以基本上从android应用上去理解，如果有理解错误的地方，欢迎指正。
 mvc  经典MVC模式中，M是指业务模型，V是指用户界面，C则是控制器，使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。其中，View的定义比较清晰，就是用户界面。 百度百科MVC
 理解一波  这个调调，感觉更适合当初的jsp和H5开发。要说android上使用，前期开发的时候，一般用别人的框架工具之类的，通常是activity 处理业务模型M，作为Vew用户界面，作为控制器处理事件和网络请求数据缓存之类的。 有将数据处理和事件单独拿到一个类中处理的，我就没有遇到过，拿到一个类处理的，人家都说是高贵的MVP开发了。所以那个时候，m在activity里面，v是activity，c是activity，fragment也是这个样子。view层的压力太大了。 这么久导致一个问题，那就是界面层代码太多了，如果网络请求和数据处理没有进行封装，那也太长了，如果不写注释，接盘的大佬也太惨了。 当然了，在这个基础上也不乏有一些大佬是将数据处理单独到一个class里面的，毕竟后台大佬和自己对M的定义不一样，先写界面就需要数据转换了。 android 的databinding 出来之后，就觉得有必要将事件处理提到一个class里面了。这就有了简单搬代码位置的思路。databinding 的事件处理当然也可以在view里面整。
 MVP  mvp的全称为Model-View-Presenter，Model提供数据，View负责显示，Controller/Presenter负责逻辑的处理。MVP与MVC有着一个重大的区别：在MVP中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，而在MVC中View会直接从Model中读取数据而不是通过 Controller。 百度百科MVP
 理解一波  这个感觉和mvc的控制层抽离方式很像，毕竟网络请求和数据处理也算控制层中的内容。而p层主要的作用就是写数据控制和事件处理，emmmmmm? 起码我点击事件没有拿到P层和C层过。 个人觉得他的View不直接操作M,这个才是这个MVP的特点，毕竟如果是服务器一套模型，本地一套模型，中间转换层就只要写到P层就好了，写的位置统一了，以后也好改一点。 只要将数据处理好，然后通过接口或者eventBus,或者类似的工具收到就行，这么就导致View 层的逻辑很清晰。因为P层进行数据事件处理，和可能出现的两套数据模型，P就承担了和C层一样的功能了。
 MVVM(jetpack)  MVVM是Model-View-ViewModel的简写。它本质上就是MVC 的改进版。MVVM 就是将其中的View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开.
 理解一波  主要还是jetpack 这一套东西太好用了，不用处理生命周期。数据恢复，数据绑定更新。只要按照他的开发规则整，android 开发就简单很多了。不像之前生命周期数据刷新都要代码控制。当然也有大佬写过很严谨的代码，主要萌新可能会有疏漏。 之前的P或者C都是将事件处理和数据，现在改到ViewModel 中了，当然了，viewModel 可以只是处理事件，然后再搞一个子类，单独处理网络请求和数据缓存，然后回调到viewModel 中，因为ViewModel 是进行事件的，所以，数据M应该让View使用就好，由ViewModel持有更新。如果将M数据放到View中和MVC又有什么区别。
 结合实际  上面的主要是个人总结的理论东西，然后实际情况，可能有点出入。
 mvc  如果是view 持有Model，充当C,那就没有必要整了。小项目感觉通常就是这么整的，逻辑不复杂，也不需要太多的事件，不处理太多的数据处理。过于复杂的地方也可以将复杂的逻辑数据化，单独写一个类处理这些东西。单独写的这个类可能和View一起充当C层了。</description>
    </item>
    
    <item>
      <title>android基于MMKV整一个数据缓存</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android%E5%9F%BA%E4%BA%8Emmkv%E6%95%B4%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android%E5%9F%BA%E4%BA%8Emmkv%E6%95%B4%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98/</guid>
      <description>》 顺便推一下博客主页
前言  这是一个巨骚的想法，从某些意义上讲，是可以使用的，但是这个主要是作为一种骚想法去实现。 mmkv介绍上说的是 比SharePreferences 性能更好，SharePreferences支持多xml 存储，他也支持。SharePreferences初始化后就存储到内存中了，他不会也是这个样子吧，他本身就是用来替换这个的。 所以不建议使用 mmkv 做接口数据缓存。但是数据库又不想写，骚操作嘛，那就无所谓了。 自从我知道 Java 可以通过某些手段获取到其实现子类之后，骚想法是一个接着一个，但是这个调调尤为突出。 但是真的不建议 这个用来存储接口数据，嗯，真的不建议。
 结束 </description>
    </item>
    
    <item>
      <title>android滚动事件相关-1</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android%E6%BB%9A%E5%8A%A8%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E7%9B%B8%E5%85%B31/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android%E6%BB%9A%E5%8A%A8%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E7%9B%B8%E5%85%B31/</guid>
      <description>》 顺便推一下博客主页
前言  现在第3方的或者android自己的写的太好了。导致大多数情况下，滑动处理都不需要自己处理了，比如说吸顶效果。比如说两个滚动view联动。 参考资料
 正文  比如说吸顶效果的实现方式有多种，感觉最完美的CoordinatorLayout。
  CoordinatorLayout是android support design推出的新布局，主要用于作为视图根布局以及协调子控件的行为，而Behavior就是用于直接子控件来协调自身CoordinatorLayout以及和其他子控件的关系，使用Behavior的控件必须是直接从属于CoordinatorLayout。 在传统的事件分发流程中，在子控件处理事件过程中，父控件是可以进行拦截的，但一旦父控件进行拦截，那么这次事件只能由父控件处理，而不能再由子控件处理了。
  在android5.0之后新的嵌套滑动机制中，引入了：NestScrollChild和NestedScrollingParent两个接口，用于协调子父控件滑动状态，而CoordinatorLayout实现了NestedScrollingParent接口，在实现了NestScrollChild这个接口的子控件在滑动时会调用NestedScrollingParent接口的相关方法，将事件发给父控件，由父控件决定是否消费当前事件，在CoordinatorLayout实现的NestedScrollingParent相关方法中会调用Behavior内部的方法。 我们实现Behavior的方法，就可以嵌入整个CoordinatorLayout所构造的嵌套滑动机制中，可以获取到两个方面的内容：
  1、某个view监听另一个view的状态变化，例如大小、位置、显示状态等 需要重写layoutDependsOn和onDependentViewChanged方法
  2、某个view监听CoordinatorLayout内NestedScrollingChild的接口实现类的滑动状态 重写onStartNestedScroll和onNestedPreScroll方法。注意：是监听实现了NestedScrollingChild的接口实现类的滑动状态，这就可以解释为什么不能用ScrollView而用NestScrollView来滑动了。
 所以可以定义两种。
 NestScrollChild和NestedScrollingParent两个接口，用于协调子父控件滑动状态 在CoordinatorLayout中实现Behavior  结束 </description>
    </item>
    
    <item>
      <title>Android自定义Toast</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android%E8%87%AA%E5%AE%9A%E4%B9%89toast/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/android%E8%87%AA%E5%AE%9A%E4%B9%89toast/</guid>
      <description>》 顺便推一下博客主页
前言  话说toast 这个调调 在Android上使用蛮频繁的。通常就是通过自己的自定义，如果不自定义的话，可能会提一个 toast重复提示的bug，虽然这个可以通过其他逻辑控制与限制。 写笔记嘛，那就都写。
 正文 toast 单例  toast 自定义1，单例。直接抄一个阿里的toast 单例。
 1 2public class ToastUtils { 3 4 private static Toast mToast; 5 private static Field mFieldTN; 6 private static Field mFieldTNHandler; 7 8 static { 9 if (Build.VERSION.SDK_INT == 25) { 10 try { 11 mFieldTN = Toast.class.getDeclaredField(&amp;#34;mTN&amp;#34;); 12 mFieldTN.setAccessible(true); 13 mFieldTNHandler = mFieldTN.getType().getDeclaredField(&amp;#34;mHandler&amp;#34;); 14 mFieldTNHandler.setAccessible(true); 15 } catch (Exception e) { 16 e.</description>
    </item>
    
    <item>
      <title>Databinding笔记整理呀</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/databinding%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%E5%91%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/databinding%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%E5%91%80/</guid>
      <description>顺便推一下博客主页
 前言  由于现在jetpack的流行，这个还是蛮香的，之前databinding才出来的时候，简单了解过。那个时候还没有写本地entity的习惯，数据都是依赖于服务器模型。现在好了，都是本地模型和服务器模型互转。就没有这个问题了， 这个调调还是可以省很多时间精力的。但是这个就得考验设计能力了，不像之前随便搬砖什么的。
 正文 开启databinding的使用能力  有一段时间迷糊了，以为需要手动导入包什么的。其实只需要配置一下，gradle就帮忙导入了，不需要在dependencies声明。比如像这个样子:
 1// 启用databinding 放到android 下面。 2 android { 3 dataBinding { 4 enabled = true 5 } 6} xml使用  这个调调主要是在xml 中配置数据绑定，事件处理什么的，所以都是操作xml.emmmmmm? 那我viewmodel 不就处理数据了。奈斯.png。还有一个问题，事件还是应该写到界面层吧，但是我决定viewmodel 也可以处理事件来着。 比如说，mvp 的事件就是在p层，但是p层我处理网络请求了，结果事件写到view层，然后事件真实处理就到了界面层。有点晕，M层是啥。 容我捋一捋。mvc中，m是业务逻辑，v是视图也就是界面层，c是中间层进行m和v的联动。mvp中m是业务逻辑数据，v还是视图和界面层，p是数据处理，emmmmm?和C莫得区别吧。百度上说”在MVP中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，而在MVC中View会直接从Model中读取数据而不是通过 Controller。“ 我肯定是没有睡醒，现在C和P傻傻分不清楚了。算了，待会开一个笔记整理一波。
 因为创建的时候，默认不是创建databinding类型的layout,所以需要手动改一下。 打开布局文件，选中根布局的 ViewGroup，按住 Alt + 回车键，点击 “Convert to data binding layout”，就可以生成 DataBinding 需要的布局规则
1&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; 2&amp;lt;layout xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34; 3 xmlns:app=&amp;#34;http://schemas.android.com/apk/res-auto&amp;#34; 4 xmlns:tools=&amp;#34;http://schemas.android.com/tools&amp;#34;&amp;gt; 5 &amp;lt;data&amp;gt; 6 &amp;lt;/data&amp;gt; 7&amp;lt;/layout&amp;gt; 能够在xml中定义什么，完全是看xml支持什么。databinding主要是基于xml 去生成一个class，而不是修改xml.</description>
    </item>
    
    <item>
      <title>fragment嵌套生命周期走查（懒加载有问题）</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/fragment%E5%B5%8C%E5%A5%97%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%B5%B0%E6%9F%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/fragment%E5%B5%8C%E5%A5%97%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%B5%B0%E6%9F%A5/</guid>
      <description>前言  话说，搬砖过程中fragment+viewpager相当常见。按照道理讲不应该出现这个bug的。主要是太久没有写代码了。emmmmm? 变菜了，能怪我？ 还有一个问题。感觉viewpager+fragment 导致的生命周期就很奇怪，最近有大佬提供的懒加载fragment，so。
 正文  话说，viewpager主要是通过adapter设置预加载数量。
  setOffscreenPageLimit()   然后是通过adapter设置相关的东西
  FragmentPagerAdapter   我们知道viewpager 默认加载3个，就是当前的和左右一边一个。其他的item都会默认销毁。所以我们的懒加载fragment的实现就尤为重要了。
 懒加载fragment  懒加载的实现模式大概就这么一个样子，都很成熟了。
  记录一个fragment中onCreateView 的创建状态。 在onViewCreated中对!isHidden() &amp;amp;&amp;amp; getUserVisibleHint() 进行事件分发。 实现setUserVisibleHint 相关逻辑。 实现onHiddenChanged 可见不可见逻辑。 实现 判断子类可见与否的逻辑。 onResume 实现第一次可见。   整个大概就这个样子:
 1public abstract class BaseLazyFragment extends Fragment { 2 3 /** 4 * mFragmentTag 5 */ 6 public String TAG = &amp;#34;&amp;#34;; 7 /** 8 * mLoadService 9 */ 10 String title; 11 public BaseLazyFragment setShow(String title){ 12 this.</description>
    </item>
    
    <item>
      <title>基于各种播放器的一些基础</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/videoplayer/%E5%9F%BA%E4%BA%8E%E5%90%84%E7%A7%8D%E6%92%AD%E6%94%BE%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/videoplayer/%E5%9F%BA%E4%BA%8E%E5%90%84%E7%A7%8D%E6%92%AD%E6%94%BE%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80/</guid>
      <description>》 顺便推一下博客主页
前言  不知不觉搬砖多年了，却还是在搬砖的路上，其实蛮累的，不知道路在哪里，只是知道每天能学习一点就是进步。主要还是人格问题。需要慢慢的从自闭中走出来。身体也需要慢慢的变好，都20多岁了。 话说，播放器相关的写过蛮多的控制层的，但是总结的很少，所以才有了写笔记的想法。虽然身体变好了，但是我可能需要用更多的脑力来计算其他的，而不是单纯的代码。
 正文 全局单播放器思考  这个业务逻辑还是蛮多的。比如横竖屏幕的切换，比如点击播放的列表播放器，比如点击播放的列表播放器全屏。 这个为了保证播放进度和避免重复缓存，一般情况下就用通一个mediaPlayer，至于画布和控制层，都可以重新加载，但是画布的加载是异步的，所以这个还是看写法。 写得简单点基本上就是把画布控制层和mediaPlayer封到一个view里面。对当前view 进行唯一处理，通过addView 和removeView 去实现。 因为一个view只会出现一个父类的原因，所以添加前需要把view从父类中移除。
 将view 从父类中移除。 1 public void removePlayerParent() { 2 if(null ==playerView){ 3 return; 4 } 5 ViewParent parent = playerView.getParent(); 6 if (parent != null) { 7 RelativeLayout frameLayout = (RelativeLayout) parent; 8 frameLayout.removeView(playerView); 9 playerView.onStop(); 10 playerView.reset(); 11 } 12 } ViewParent 这个对象很骚，因为只有viewGroup 实现了这个接口，而removeView也是相当viewGroup 实现的。所以需要对象转换。 为了防止移除的时候绘制界面，所以便捷的处理方式是暂停播放。当然也可以不暂停播放，看需求。比如切换列表播放item的时候，就需要暂停，横屏切换到竖屏的时候就不需要暂停。
全屏逻辑  既然我们可以直接将view的父类移除，所以添加逻辑实现全屏是可行的。全屏就存在两个设计，1个是添加到一个dialog中，dialog设置全屏和屏幕适配，返回键等等，另外一种逻辑就是直接添加到activity的根布局中。 按照逻辑讲，应该使用dialogFragment去实现全屏。 但是无论如何都需要旋转屏幕。所以屏幕方法保持不变是可以的，但是旋转屏幕可以通过旋转画布实现和旋转view替代，这个可以减少一些设置导致生命周期错乱问题。虽然都可以逻辑控制，但是这个调调，很容易出现逻辑控制缺省的情况。
 添加到activity的根布局中   结束 </description>
    </item>
    
    <item>
      <title>基于现有网络框架扩展网络请求防止重复工具类</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/%E5%9F%BA%E4%BA%8E%E7%8E%B0%E6%9C%89%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E6%89%A9%E5%B1%95%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E9%98%B2%E6%AD%A2%E9%87%8D%E5%A4%8D%E5%B7%A5%E5%85%B7%E7%B1%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/%E5%9F%BA%E4%BA%8E%E7%8E%B0%E6%9C%89%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E6%89%A9%E5%B1%95%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E9%98%B2%E6%AD%A2%E9%87%8D%E5%A4%8D%E5%B7%A5%E5%85%B7%E7%B1%BB/</guid>
      <description>》 顺便推一下博客主页
前言 正文 Java 3大器 过滤器 监听器 拦截器 结束 </description>
    </item>
    
    <item>
      <title>手抄一手阿里播放器中手势分发</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/ali/%E6%89%8B%E6%8A%84%E4%B8%80%E6%89%8B%E9%98%BF%E9%87%8C%E6%92%AD%E6%94%BE%E5%99%A8%E4%B8%AD%E6%89%8B%E5%8A%BF%E5%88%86%E5%8F%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/ali/%E6%89%8B%E6%8A%84%E4%B8%80%E6%89%8B%E9%98%BF%E9%87%8C%E6%92%AD%E6%94%BE%E5%99%A8%E4%B8%AD%E6%89%8B%E5%8A%BF%E5%88%86%E5%8F%91/</guid>
      <description>》 顺便推一下博客主页
前言 阿里云点播服务文档 阿里云点播demo下载 正文 结束 </description>
    </item>
    
    <item>
      <title>重学Viewpager</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/%E9%87%8D%E5%AD%A6viewpager/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/%E9%87%8D%E5%AD%A6viewpager/</guid>
      <description>》 顺便推一下博客主页
前言  viewpager 通常用于加载Fragment或者banner图，因为其良好的交互效果，被设计大佬广泛使用。默认情景下，viewpager 会加载缓存左右的view。滑出去之后就会删除对应的item。 这么就导致了fragment中layout的重复创建和重复赋值，不停的网络请求，所以才有了懒加载等等相关逻辑，但是viewpager某种意义上就是懒加载逻辑呀。 往往为了解决重复请求，重复加载等等问题，我们通常是设置缓存个数和重写item的删除逻辑，为了更加通透的理解viewpager，所以重学是必要的。
 正文 viewPager 结束 </description>
    </item>
    
    <item>
      <title>阿里云Android播放器控制层代码分层解析</title>
      <link>http://lalalaxiaowifi.gitee.io/pictures/posts/android/ali/%E9%98%BF%E9%87%8C%E4%BA%91android%E6%92%AD%E6%94%BE%E5%99%A8%E4%BB%A3%E7%A0%81%E5%88%86%E5%B1%82%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://lalalaxiaowifi.gitee.io/pictures/posts/android/ali/%E9%98%BF%E9%87%8C%E4%BA%91android%E6%92%AD%E6%94%BE%E5%99%A8%E4%BB%A3%E7%A0%81%E5%88%86%E5%B1%82%E8%A7%A3%E6%9E%90/</guid>
      <description>》 顺便推一下博客主页
前言  虽然搬砖多年，代码复制了很多。然后尝试去理解别人代码，但是整理相关代码设计逻辑还是大姑娘上花轿头一回。
这次项目基于AndroidX。所以和Android 有一些区别，在拖代码的过程中，就存在需要理解代码了。
阿里云点播服务文档 阿里云点播demo下载  正文 当前笔记基于阿里云点播Android 播放器 AliyunVodPlayerView 。
分层  基于RelativeLayout 添加view。按照功能继续view的分解。
  控制层，用于实现播放器控制效果，包含，全屏，小屏，播放，暂停，进度条，拖拽条，截屏，标题，返回键，倍速，分辨率等功能文本显示。 手势层，用于进行手势分发，比如切换明暗度，声音，进度条拖拽，点击，双击。 视频画面层。这个就是视频播放画面，单纯的视频播放。 引导层，用于第一次操作时候的引导。 播放器封面 提示层，比如网络提示，播放完成，播放错误等等。这个提示层 内部又进行了分发封装。 播放内核内核+视频画布层。  监听回调  这个比较多，大体就是在分层上进行处理。比如说返回事件，在控制层，提示层中都有，而且提示层中，包含错误，播放完成，网络提示，这些都有占位view，所以，实现方式大概就是。 错误层的返回事件回调到提示层的监听中，提示层的监听是单独的接口，播放器实现提示的监听接口，去调用播放器中的返回事件。
整体思路就是，每一层都有自己的实现，自己的实现去调用上一层的实现。最终同一个功能会归集到一个实现方法上面。
 view的添加  添加view 就很简单，初始化的时候直接添加到view中
 1 private void addSubView(View view) { 2 LayoutParams params = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT); 3 //添加到布局中 4 addView(view, params); 5 } 基础控件的隐藏  这个主要是控制层的几秒后自动隐藏，这个内部实现handler，然后自己调用 隐藏方法。
 结束 </description>
    </item>
    
  </channel>
</rss>
