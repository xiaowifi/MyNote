H.264码流中的NALU进行了一个简单的划分，标出了NALU的类型和长度等信息。因为我们在解析SPS和PPS中要使用到指数哥伦布编码的解析，所有有必要了解一下指数哥伦布编码。

### 指数哥伦布编码（理论篇）

指数哥伦布码（Exponential-Golomb code， 即Exp-Golomb code）是熵编码的一种编码方式，正常来说，可以拓展位k阶，但是在H264中使用的是0阶指数哥伦布编码，在H.264中使用ue(v)表示0阶无符号指数哥伦布编码的解码过程，用se(v)表示0阶有符号指数哥伦布编码过程

#### 1、无符号指数哥伦布编码

用来表示无符号整数k阶指数哥伦布编码的生成步骤如下：

（1）将数字以二进制形式写出，去掉最低位的k个比特位，之后加1

（2）计算留下的比特数位数，将此数减1，即是需要增加的前导0的个数

（3）将第一步中去掉的最低个比特位补回到比特串尾部

#### 1.1、0阶无符号指数哥伦布编码过程

0阶无符号指数哥伦布编码最后生成的比特串格式为"前缀1后缀"，前缀和后缀的长度是相同的。

假如我们待编码的数字codeNum = 4，0阶无符号指数哥伦布编码的步骤如下：

（1）将数字以二进制写出，4的二进制为100，因为0阶指数哥伦布编码所有不用去掉低位

（2）将上面的二进制+1，100加1为101，留下的比特数为3，3-1=2，所有需要增加前导0的个数为2

（3）因为第一步没有去掉，所有这一步不进行任何操作，最终生成的比特串为00101

0阶指数哥伦布编码可以简化为如下步骤

（1）将codeNum+1，4+1=5

（2）将加1后的数字用二进制表示，5的二进制位101，1后缀=101，后缀位01，长度2

（3）前缀与后缀长度相同，在前面加上2个0 

下面对不同codeNum进行编码结果

| codeNum | codeNum+1 | codeNum+1的二进制 | 需补前缀0的个数 | 编码后的比特串（红色表示补的前缀0） |
| ------- | --------- | ----------------- | --------------- | ----------------------------------- |
| 0       | 1         | 1                 | 0               | 1                                   |
| 1       | 2         | 10                | 1（0）          | 010                                 |
| 2       | 3         | 11                | 1（0）          | 011                                 |
| 3       | 4         | 100               | 2（00）         | 00100                               |
| 4       | 5         | 101               | 2（00）         | 00101                               |
| 5       | 6         | 110               | 2（00）         | 00110                               |
| 6       | 7         | 111               | 2（00）         | 00111                               |

0阶无符号指数哥伦布编码的解析过程如下

（1）找到第一个不为0的bit，并记录总共找到了0的个数（num），这个时候读到的这个bit肯定是1

（2）然后读num个后缀

（3）1后缀转变成十进制就是原来的codeNum，codeNum = (1 <<i) + 后缀(十进制) - 1;

比如比特串的二进制为：00111，首先找到第一个不为0的比特，前面0的个数为2，然后再读2个后缀11，11十进制为3，这个时候codeNum = （1 << 2） + 3 - 1 = 4 + 3 - 1 = 6

#### 1.2、k阶无符号指数哥伦布编码过程

（1）将codeNum加上2^k

（2）将加上2^k的数字用二进制表示

（3）计算二进制的长度len，然后再前面加上len-1-k个0

比特串的格式位"前缀1后缀"。前缀 = 后缀 - k

| codeNum | k=1          | len-1-k | 编码后比特串 | k=2           | len-1-k | 编码后比特串 |
| ------- | ------------ | ------- | ------------ | ------------- | ------- | ------------ |
| 1       | 1+2^1=3(11)  | 2-1-1=0 | 11           | 1+2^2=5(101)  | 3-1-2=0 | 101          |
| 2       | 2+2^1=4(100) | 3-1-1=1 | 0100         | 2+2^2=6(110)  | 3-1-2=0 | 110          |
| 3       | 3+2^1=5(101) | 3-1-1=1 | 0101         | 3+2^2=7(111)  | 3-1-2=0 | 111          |
| 4       | 4+2^1=6(110) | 3-1-1=1 | 0110         | 4+2^2=8(1000) | 4-1-2=1 | 01000        |

#### 2、有符号指数哥伦布编码

有符号指数哥伦布编码一般使用se(v)表示，输出可能是负数，有符号指数哥伦布编码解析的过程是在无符号指数哥伦布编码解析过程之上进行的，遇到se(v)需要先调用ue(v)得到codeNum，然后再调用se(v)的过程.

value = (-1)^(codeNum+1) * (codeNum+1)/2;

(-1)^(codeNum+1)：表示如果codeNum为奇数那么是1，偶数为-1