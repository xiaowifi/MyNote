## 前言
从某种意义上而言，我们写的所有代码都叫标准格式化文本文件。只是通过编译器或者虚拟机去编译成了计算机执行的指令。
而对于已有的计算机数据架构而言，他只能识别二进制内容。所以我们需要定义一些规范，用于保证数据都安全及其完整性。序列化和反序列化和文件读写还是有一些区别。
我们编辑的是JAVA 文件，所以转换出来的数据里面包含JAVA文件的信息等等。
# 正文
JAVA 提供的序列化操作的接口是Serializable 接口，通常我们需要自定义
```aidl
    private final static long serialVersionUID=1L;
```
## 序列化的意义及其技术方案
无论是什么技术方案的序列化，他的核心需求都是需要传输，无论是跨物理设备还是进程，线程，对象作用域等等，他的使用场景都是传输。所以明确使用场景是非常重要的。
比如网络场景：那么数据稳定，平台支持，就是重点。传输数据都大小反而次之。<br>
如果是本机内部的，序列化与反序列化速度和数据大小就是核心问题。当然还有复杂程度相关的问题。<br>
常见的技术方案：
* xml 目前通常做配置
* json 通用网络接口的方案 
* Serializable JAVA的技术方案。
* protobuf 存储方案中特别常见
* parcelable Android 独有的技术方案


## Serializable 
这玩意基于JAVA信息和固定格式的json 相比，更慢。一次序列化的过程就是深克隆（重新创建一个对象）。而且他的诉求点是传输和数据持久化。

* 如果我一个class序列化数据后存储了起来，然后把class 的变量更改了(增删改)会报错吗？

JAVA 基于objectInputStream 和objectOutputStream 两个包装流工具将class信息和数据进行拆分出来或将拆分出来的字节生成一个class对象。
这么一理解，似乎和数据库的表是类似的。只是数据库的表是可视化的数据结构，而serializable出来的数据我们看不懂。当然数据库文件不凭借特定的工具也看不懂。
因为我们数据模型可能需要经常更新，这么数据库表更新到关联是类似的。而serializable也提供了类似的东西：
````aidl
    private final static long serialVersionUID=1L;
````
如果不赋值或读写的serialVersionUID不一致就会跑错，如果一致，新增的变量的复制会是Null，哪怕有默认值，而改类型(逻辑上来说算删除后添加，但是请不要玩这么骚，please)
* 如果说一个类中有些字段，不先参与序列化与反序列化应该怎么办？

transient是一个关键字，这个关键字标记的字段不会参与序列化。

* 如果子类实现了serializable但是父类没有，会出现什么问题吗？

可以序列化成功，但是反序列化后父类是没有数据的。如果需要有数据，子类需要自己实现两个函数：readObject,writeObject,然后把父类需要的序列化与反序列的数据整进去或读取出来。
这么写似乎不怎么方便，有没有更方便的呢？JAVA 提供了另外一个接口，用于处理需要自定义序列化和反序列的业务的接口：Externalizable，但是这接口实现后readObject和writeObject就不会被调用了。
* 为啥需要一个无参构造函数？

因为反序列化的时候，他反射的是一个无参数的构造函数，所以，需要提供一个这个玩意儿。
* 如果说，父类实现类serializable，但是子类没有，会出现什么问题吗？

这个问题，逻辑上是错误的，继承关系上而言，父类实现了，子类也就实现了，至于需要子类不参与序列化或反序列化，那么就直接实现readObject和writeObject自己排除就行。

* 为什么serializable比json慢？

这个就需要深入他的实现源码了，他整个输出流的字节里面，会输出字段名称，类型，值，类信息等等，而json 输出的只有字段名称和值，都是通过反射生成对象，更多的信息解析也就会导致更多的时间了。

## parcelable

他的实现而serializable类似，但是他的实现和诉求是不一致的，他是为了满足Android跨进程通信而产生的，实现上采用C去实现部分功能，用于减少反射相关代码。

## protobuf
这个调调在mmkv 中便有使用。

## json
这玩意儿，通常都不需要我们自己写解析代码，第三方工具特别多。例如gson

