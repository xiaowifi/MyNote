# 前言
> 任何设计模式都是一种代码写法，为了具体业务诉求进行服务。每一种标准的设计模式都是一种业务形态的解决方案，而业务诉求往往并没有百分百和任何一种设计模式一致，所以往往会存在设计模式的变种或者非一致的写法，同时受限于资源，并不一定需要完整的设计模式。设计模式都是为了业务诉求服务，而不是业务诉求服务于设计模式。
## 资料
* [runoob:设计模式](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)
# 正文
## 设计模式原则
### 开闭原则
    > 对扩展开发，对修改关闭.当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。
### 里斯代换原则 LSP
    > 任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。
    > 里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。
### 依赖倒转原则
    > 依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。
       
        * 每个类尽量提供接口或抽象类，或者两者都具备。
        * 变量的声明类型尽量是接口或者是抽象类。
        * 任何类都不应该从具体类派生。
        * 使用继承时尽量遵循里氏替换原则。
### 单一职责原则
    > 单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分
    > 单一职责同样也适用于方法。一个方法应该尽可能做好一件事情。如果一个方法处理的事情太多，其颗粒度会变得很粗，不利于重用。
###  接口隔离原则
    > 要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。

接口隔离原则的优点
  * 接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。
  * 将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。
  * 接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。
  * 如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。
  * 使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。
  * 能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。

### 迪米特法则
> 如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。但是会增加中间层代码量。
### 合成复用原则
> 它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。
> 合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。

## 设计模式主要分类
### 创建型模式
  > 创建型模式主要关注点是，如何创建对象，他的主要特点是将对象的创建与使用分离，可以降低耦合度。
  * 工厂方法模式 []() (通过定义一个对象接口，然后由工厂类决定或者子类决定输出对象)
  * 抽象工厂模式[]() (和工厂模式差不多)
  * 单例模式 []() (某个类只能存在一个实例，该类提供了一个全局访问点供外部使用，但是反射好像打破了这种设计模式)
  * 建造者模式 []() (将复杂的对象拆分为多个子类。和合成复用原则吻合)
  * 原型模式 []() (将一个对象作为原型，通过对其复制出多个和原型类型的新的实例)
### 结构型模式
  > 结构型模式描述如何将类或者对象按照某种布局组成更大的结构，它分为类结构模式和对象结构模式，前者采用继承机制来组织接口类，后者采用组合或聚合来组合对象。组合或者聚合耦合度低。
  * 适配器模式 []() 将一个类的接口转换成客户端希望的另外一个接口，使得原本不兼容的的接口或者内可以一起工作。
  * 装饰器模式 []() 动态的给对象增加一些职责，增加其额外功能。
  * 代理模式 []() 为某对象提供一种代理以控制该对象的访问，从而限制或者增强或修改该对象的一些特性。
  * 外观模式 []() 为多个复杂的子系统提供一个一致的接口，使得子系统更容易被访问。
  * 桥接模式 []() 将抽象与实现分离，使得他们可以独立变化，他是使用组合关系替代继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。
  * 组合模式 []() 将对象组合成树状层，使用户对单个对象和组合对象具有一致的访问性。
  * 享元模式 []() 运用共享技术，来有效的支持大量细粒度对象的复用。
###  行为模式
  * 策略模式
  * 模板方法模式
  * 观察者模式
  * 迭代子模式
  * 责任链模式
  * 命令模式
  * 备忘录模式
  * 状态模式
  * 访问者模式
  * 中介者模式
  * 解释器模式
###  并发型模式
###  线程池模式  

## 设计模式总结 
[23总设计模式总结](23总设计模式总结.md)




















